
- LeetCode Cookbook <https://books.halfrost.com/leetcode/>
- 代码随想录 <https://github.com/youngyangyang04/leetcode-master>

## 代码语法总结

### 传递 值拷贝 vs 指针

典型的问题是遍历二叉树, 例如 113题(找到二叉树路径和为目标值的所有路径), 需要维护一个历史的path.

- go中将slice作为参数传递/赋值(Python中将list作为参数传递也类似), 传递的还是类似指针的类型; 因此相较于值拷贝, 内存开销会小一点.
- 因此, 在对于这个类型进行修改的时候, 需要注意对于外层变量的影响

#### go语言中的slice 传递 & 复制

- go中的slice本质上还是包括了len, cap 属性的一个指针, 可表示为 `[3/5]0xc42003df10`, 传递给函数是浅复制(**仍然指向源slice的底层数组**), 若在函数内进行了修改
  - 若函数内部对slice进行扩容，扩容时生成了一个新的底层数组, 两个 slice 的内存指向就不同了, 不会影响外层slice
  - 若没有进行扩容, 修改了底层数组, 则外层同样引用这一底层数组的slice会被改变
- **复制** slice
  - 可以使用 cope 函数, `copy(s2, s1)` 将s1复制到s2, 若s1较长会被截断, 较短则复制s1那部分(s2后面的部分不变, len也不变); 函数返回成功复制的数量
  - 或者是字面量 `append([]int{}, s1...)`

### 全局变量 vs 传参

参见 113 题(找到二叉树路径和为目标值的所有路径).

- 对于 `pathSum(root *TreeNode, targetSum int) [][]int` 这样的问题
  - **传参**, 递归函数 `pathSumRec(node *TreeNode, sum int, paths *[][]int, tmp []int)`; 这里用了指针 `paths [][]int{}`, 因为初始化的 `[][]int{}` 类型长度为0, 若在函数内部进行 append, 会因为进行了扩容而开辟一个新的内存, 从而无法修改到外层的 slice
  - **全局变量+内部函数**, 在函数内部定义 `var dfs func(root *TreeNode, target int)`, 从而直接修改全局变量, 从而避免了外部定义一个函数, 需要考虑的传参问题

之所以会有这样的困扰, 因为之前没看过 go 的内部函数语法; 从实际应用上来看, 「全局变量+内部函数」的方式无疑更简单和优雅.

## 分类小结

总结一下每道题的思路:

### 07 DP

- 5 最长回文子字符串, `中`
  - 解法四 `DP`, 时间复杂度 O(n^2), 空间复杂度 O(n^2)
  - 解法三 `中心扩散` 法, 时间复杂度 O(n^2), 空间复杂度 O(1)
  - 解法二 `滑动窗口`, 时间复杂度 O(n^2), 空间复杂度 O(1)
  - 解法一 Manacher's algorithm, 时间复杂度 O(n), 空间复杂度 O(n)
- 22 生成所有指定长度的括号对, `中`
  - 解法一 DFS, O(2^n), O(n)
  - `模拟`: 根据记录的数量模拟每一步合法的括号
- 32 最长合法的括号序列 `难`
  - 注意需要记录的其实是「上一个没有被匹配的右括号的下标」
  - 解法一 `栈`, 这里初始化栈底为 -1 并在扫描过程中保证栈不为空, O(n), O(n)
  - 解法二 `双指针` O(n), O(1), 算是对栈方法提升了空间消耗 —— 注意每次需要记录的实际上只有「上一个没有被匹配的右括号的下标」, 因此只需要再配合两个计数器分别记录左右括号出现的数量, 从而判断当前序列是否合法即可; 注意到会忽略 `(()` 这样的终止条件,因此还要从右往左扫描一遍.
- 42 接雨水 `难`
  - 本题是想求针对每个 i，找到它左边最大值 leftMax，右边的最大值 rightMax，然后 `min(leftMax，rightMax)` 为能够接到水的高度
  - 解法一 `扫描`, O(n), O(n), 两次遍历分别记录每个 index 的左右最大值;
  - 解法二 `双指针`, O(n), O(1), 若用双指针一次遍历, 这里维护「全局」的左右最大值 `maxLeft, maxRight`, 需要对于每个 index(遍历的左右指针) 都是合理的, 这里通过控制左右指针的移动 (每次移动较高的那一个) 来更新左右最大值.
- 45 跳跃游戏 `中`
  - 解法一: `贪心/模拟`, O(n), O(1). 注意到, 由于可选择当前位置条约的步数, 因此**可达的最远位置之前的所有格子一定也可达**, 因此可考虑贪心. 扫描步数数组, 维护当前能够到达最大下标的位置, 记为能到达的最远边界, 如果扫描过程中到达了最远边界, 更新边界并将跳跃次数 + 1.
- 53 最大子数组和 `易`, 但个人觉得算 `中`
  - 解法一 `DP`, O(n), O(n), 设计 `dp[i]` 是所有以 i 结尾的区间和的最大值, 状态转移方程是 `dp[i] = nums[i] + dp[i-1] (dp[i-1] > 0), dp[i] = nums[i] (dp[i-1] ≤ 0)`.
  - 解法二 `模拟`, O(n), O(1), 注意到这里实际用到的只是 dp[i-1] —— 事实上可以改写转移方程 `dp[i] = max{dp[i-1], 0} + nums[i]`, 迭代过程中维护这个数字即可
- 55 跳跃游戏, 判断是否可达 `易`
  - 关联 45, 顺序扫描即可, 记录可达的最远距离, 若扫描位置超过该 maxRight 则说明不可达
- 62 矩形到达另一个叫的路径数量, 杨辉三角
- 63 增加 obstacle
- 64 矩形每个坐标有对应数字, 求最小路径 `易` 以上几题都是基本的 DP; 需要注意的是可能可以用节省内存 (但面试/做题时候应该不用考虑). 另外注意64题可以直接在输入矩阵上计算.
- 70 爬楼梯, O(n)
  - 每次一步或两步, 问爬n阶楼梯有几种方式, 递推公式 `dp[i]=dp[i-1]+dp[i-2]` —— 正是斐波那契数列
  - 也可以用 `滚动数组` 节省空间; 公式 `f,g = g, f+g`
- 91 对字母用数字 1-26 编码, 问给定一个数字字符串的解码数量
  - 需要特殊考虑的是0, 要注意 "06" 是不合法的.
  - DP递推公式: `dp[i] += dp[i-1]` (当 1 ≤ s[i-1 : i] ≤ 9)；`dp[i] += dp[i-2]` (当 10 ≤ s[i-2 : i] ≤ 26)
  - 这题和上面的都可以考虑 `哨兵` 的思想, 避免起始的边界情况
- 95 给定一个数字生成所有的元素为1-n的 BST’s (binary search trees) `中` 但个人觉得挺难的 `structure`
  - 这里函数定义是 `func generateTrees(n int) []*TreeNode`, 只需要返回node指针即可.
  - 思路其实比较简单: 注意到对于**二叉搜索树**, 一个节点左边的数均小于该节点; 此题场景下, 递归 `func generateBSTrees(start, end int) []*TreeNode` 即可;
  - 要注意终止条件, 这里可以设置为 `start>end`
- 96 求上面二叉树的数量
  - 在上一题思路下就很简单了: 递推公式 `dp[i] = dp[0] * dp[n-1] + dp[1] * dp[n-2] + …… + dp[n-1] * dp[0]`
- 97 交错字符串 `中`
  - 两个字符串能否在不改变顺序的情况下, 拼接组成第目标字符串; 递推公式 `dp[i][j] = dp[i-1][j]&&s1[i-1]==s3[i+j-1] || dp[i][j-1]&&s2[j-1]==s3[i+j-1]`
  - 注意到第 i 行仅依赖于 第 i-1 行, 因此可以 `滚动数组` 优化空间

### 08 Backtracking

- 17 电话号码的字母组合
  - 直接回溯, 写成DFS即可
- 37 解数独 `难`
  - 注意回溯的思路: 对于每一个为空的格子, 尝试填入所有可能的数字(通过 `checkSudoku(board *[][]byte, pos position, val int) bool` 函数判断是否可行), 最后要把格子还原为空;
  - 终止搜索: 只要找到一个解即可, 因此判断没有剩余的空格时, 直接返回 (最开始阶段, 扫描一遍数独, 将空格子记录到一个数组中).
- 19 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合 `中`
  - 先对candidates排序避免重复, 回溯, 每次填入所有可能的数字(不超过target), 递归函数 `findcombinationSum(candidates []int, target int, index int, currentList []int, res *[][]int)` 其中的target为剩余的目标值, index是当前填入的数字所在指标

-

### 09 DFS

- 94 中序遍历一棵二叉树 `易`
- 98 判断二叉搜索树是否合法 `中`
  - 注意需要一个节点合法, 需要满足「大于左子树上的所有节点, 小于右子树上的所有节点」
  - 递归函数形式 `isValidbst(root *TreeNode, min, max float64) bool`
  - 检查条件 `return v>min && v<max && isValidbst(root.Left, min, v) && isValidbst(root.Right, v, max)`
  - 边界(root): `isValidbst(root, math.Inf(-1), math.Inf(1))`
- 99 **二叉搜索树**中的两个节点被错误地交换。恢复这棵树。`中`, 偏 `难`
  - see [here](https://leetcode-cn.com/problems/recover-binary-search-tree/solution/hui-fu-er-cha-sou-suo-shu-by-leetcode-solution/)
  - 解法一 中序遍历转为列表. 核心思路是, 二叉搜索树中序遍历等价于一个递增列表, 直接转化为列表后处理
    - 对于交换两个元素, 可能出现一个或两个位置不满足 `a[i]<a[i+1]`, 我们在中序遍历得到的列表中找到要交换的节点即可
    - 若交换的是相邻元素, 例如 [1,3,2,4,5,6,7], 保留指针 i, i+1即可, 若不相邻, 例如 [1,6,3,4,5,2,7], 则会有 i,j 两个元素不满足递增条件, 保留 i+1, j; 综上, 可以通过一次遍历得到要交换的两个节点
  - 解法二 上面是「显式中序遍历」, 将中序遍历的值序列保存在一个数组中, 我们也可以隐式地在中序遍历的过程就找到被错误交换的节点.
    - 思路其实是一样的, 我们只关心中序遍历的值序列中**每个相邻的位置的大小关系是否满足条件**(且错误交换后最多两个位置不满足条件). 因此在中序遍历的过程我们只需要维护**当前中序遍历到的最后一个节点**, 然后在遍历到下一个节点的时候，看两个节点的值是否满足前者小于后者即可，如果不满足说明找到了一个交换的节点，且在找到两次以后就可以终止遍历。
    - 具体实现上, 又可分为递归和用 stack 来记录两种方案. 1. 官答用了栈来记录当前节点的「右父亲列表」(注意, 对一个节点, 其中序遍历的下一个点是其右子树中最小的节点, 即不断尝试访问左儿子); 2. [halforest](https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0099.Recover-Binary-Search-Tree/) 的解答用的是递归, 更为直观
      - 注意这里的递归函数形式 `inOrderTraverse(root, prev, target1, target2 *TreeNode) (*TreeNode, *TreeNode, *TreeNode)` root 为当前节点, prev 为中序遍历的上一个节点, target1, target2 为要找的两个节点; 返回 prev, target1, target2.
  - 解法三 取消栈空间, 略
- 100 判断两个二叉树是否完全相同
  - 深度优先即可
- 101 判断二叉树是否对称
- 104 二叉树的深度
  - DFS 递归
    - 当递归到 nil 时返回 0
    - 节点部位空时返回 `return max(maxDepth(root.Left), maxDepth(root.Right)) + 1`
  - BFS 用stack保存每一层的节点
- 110 判断一棵树是不是平衡二叉树。平衡二叉树的定义是：树中每个节点都满足左右两个子树的高度差 <= 1 的这个条件 `易`
  - DFS 递归 `isBalancedHight(root *TreeNode) (bool, int)` 返回这棵子树是否平衡, 以及树高
- 111 给定一个二叉树，找出其最小深度。最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量
  - 叶子节点是指没有子节点的节点
  - 和 104 的区别在于, 若左右孩子只有一个为空, 则应该根据另一个子树的深度计算; 只有当左右均不为空时才返回 `min(minDepth(root.Left), minDepth(root.Right)) + 1`
- 112 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。说明: 叶子节点是指没有子节点的节点。
  - 还是注意叶子节点的判断
- 113 找出上题中的所有路径 `中`
  - 难度倒是不大, 利用一个变量记录目前的路径, 倒是在 go 和 python 的指针传递上尝试了好久; 详见代码语法总结部分「全局变量 vs 传参」「传递 值拷贝 vs 指针」
- 114 将二叉树展开为链表, 先序遍历
  - 解法一 递归: 对于递归函数 `flatten2(root *TreeNode)`, 分别将左右孩子完成flat, 由于是先序遍历, 所以 `root->root.left->...->root.right` 即可, 注意是左子树转化的链表最末尾连接右子树
  - 解法二 非递归 每次找到左子树的最右(也即链表最后一个元素), 然后将右子树连接上去, 参见 [here](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/)

### 11 binary search 二分查找

- 4 寻找两个有序数组的中位数 `难`
  - 简单起见, 合并更方便
  - 二分搜索, 参见 [here](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)
  - 这里go的实现, 通过维护数组的分界点来找, 思路也很清晰
- 33 搜索旋转排序数组 `中`, 没有重复, 返回索引值
  - 可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 `[l, mid]` 和 `[mid + 1, r]` 哪个部分是有序的
  - 如果 `[l, mid - 1]` 是有序数组 (即 `nums[mid]>=nums[0]`)，且 target 的大小满足 `[nums[l],nums[mid])`，则我们应该将搜索范围缩小至 `[l, mid - 1]`，否则在 `[mid + 1, r]` 中寻找。
  - 反之, 若 `nums[mid]<=nums[-1]`, 则可直接根据 target 是否在 `(nums[mid], nums[r]]` 判断是否在右半部分, 否则在另一边搜索
- 34 找出给定目标值在排序数组中的开始位置和结束位置
  - 基本变体: 找第一个/最后一个等于 target 的元素
- 35 查找有序数组插入位置 `中`
  - 经典变体, 即「在有序数组中找到最后一个比 target 小的元素」
- 69 实现 sqrt
  - 解法二 `牛顿法`, 即求 `f(x)=x^2-n` 的零点
  - 更 fancy 的还可以更快
- 74 搜索二维有序数组 `中`
  - 基本的二分搜索
- 81 搜索旋转排序数组Ⅱ, 和33题相比多个可重复
  - 其实仅仅多了一种情况: 当 `nums[mid] == nums[l] && nums[mid]==nums[r]` 时无法判断哪一部分是有序的, 因此只能 `l++; r--`
- 153 搜索旋转排序数组 中的最小值(旋转点) `中`
  - 由于旋转数组也可以是正常升序数组, 因此判断条件应该是和 high 比较而不能只和 low 比较
  - 解法一 其实也可以用基本的二分范式 `l<=r`, 判断条件复杂一点
  - 解法二 这类题目也可以用 `low < high` 作为终止条件, 相较于基本范式, 这里 high 和 low 的是不对等的. high 只是用来缩减搜索范围, 而 low为输出结果的指针
- 154 相较于 153 增加了可重复条件 `难`
  - 如果还是用基本范式, 判断条件会更复杂一点; 但用双指针逼近的思路会更清楚
- 162 找到数组中的「**山峰**」 `中`
  - 算是二分的经典变体, 和 153 一样用 high low 进行判断会比较简单; 基于 `nums[mid+1] >= nums[mid]` 进行更新
- 167 找到两数之和为目标值的index
  - 和第 1 题一样, 不过时排好序的, 可以用双指针逼近, 从而免去了map空间
- 209 长度最小的子数组 `中`
  - 正数数组, 找到 >=target 的连续子数组的最小长度.
  - 解法一 先计算 cumsum, 然而对于每一个子数组开始位置, 可以用二分搜索找到最小长度, 时间 O(nlogn), O(n)
  - 解法二 「**滑动窗口**」在滑动窗口 [i,j]之间不断往后移动，如果总和小于 s，就扩大右边界 j，不断加入右边的值，直到 sum > s，之和再缩小 i 的左边界，不断缩小直到 sum < s，这时候右边界又可以往右移动。以此类推。 O(n), O(1)

总结了二分查找的注意点:

- 循环退出条件，注意是 low <= high，而不是 low < high。
- mid 的取值，mid := low + (high-low)»1
- low 和 high 的更新。low = mid + 1，high = mid - 1。

四个基本的变种

- 二分查找第一个与 target 相等的元素，时间复杂度 O(logn)
- 二分查找最后一个与 target 相等的元素，时间复杂度 O(logn)
- 二分查找第一个大于等于 target 的元素，时间复杂度 O(logn)
- 二分查找最后一个小于等于 target 的元素，时间复杂度 O(logn)

另外一类常见的: 基本有序数组. 在山峰数组中找山峰，在旋转有序数组中找分界点。第 33 题，第 81 题，第 153 题，第 154 题，第 162 题，第 852 题

### 12 math

- 2 两数相加, 形式为逆序链表. `中`
  - 定义了基本的 `ListNode` 结构, 并定义 `List2Ints, IntsList` 实现数组和链表的方便转换.
- 7 反转32位整数 `中`
  - 这题主要的限制是在要防止 32位 sign int 溢出, 讨巧的思路可以用更长的整数类型/字符串来保存. 「标准」思路应该是每次 `*10` 之前进行检查 (或者说, 和 `math.MinInt32/10` 进行比较) 防止溢出.
- 9 Palindrome 回文数
  - 同样可以采用 1. 反转数字; 2. 转为数组; 3. 转为字符串等方式.
  - 直接反转可能溢出 (虽然此时必然不是回文数); 思路是「反转整数长度的一半」(即循环条件 `x>rev`), 最后的判断条件: 若 x 为回文数且长度为偶数, 则 `x==rev`; 若为奇数, 则 `x==rev/10`
- 12, 13 罗马数字转阿拉伯数字
  - 就是所使用的基数不用, 累计即可
- 60 Permutation-Sequence 找出以一定的数字作为元素的排列中的第 k 个 `难`
  - 思路一 也即官方的 [缩小问题规模](https://leetcode-cn.com/problems/permutation-sequence/solution/di-kge-pai-lie-by-leetcode-solution/); 其实也可理解为贪婪剪枝的 DFS?
    - 使用 go 来实现的时候没有 Python 中好用的 `math.perm` 函数, 方便的类型转换等. 解答中用到的一些技巧值得学习. 例如, 1. 构造了 factorial 来实现 Python 中的 math.perm; 2. 用 valid 数组标记还没有用过的数字
    - 重点还是要明确公式: `a_i=(k-1)mod(n-1)!+1`
  - 反过来的问题: 对于给定的排列确定其为顺序第几个?
    - 公式 `k=sum(order_i*(n-1)!)+1`, 其中的 order_i 是在 序列 `a_i+1...a_n` 中小于 a_i 的元素数量
- 29 整除 `中`
  - 思路一 类似二分查找, 每次将除数 `*2` 找到小于等于被除数的最大的那一个, 迭代终止条件是 `dividend<divisor`, 即不断减去除数的倍数之后, 剩余的部分小于除数
  - 思路二 `倍增法` 实际上在除数递增的过程中即可将被除数相减, 当增大到接近被除数之后再不断 `/2`, 终止条件是因子 `cnt==0`, 也即 `dividend<divisor`

## 周赛笔记

### 268

- 2078. 两栋颜色不同且距离最远的房子
- 2079. 给植物浇水
  - 模拟法
- 2080. 区间内查询数字的频率 `中`
  - 需求是查询子数组 arr[left...right] 中 value 的 频率; 考虑到查询数量可能较大, 因此设计一个数据结构存储数据分布信息
  - 解法: 用 map 保存数字所出现的位置列表, 从而查询时候可以用**二分查找**.
    - Python 可以直接用 `bisect.bisect` 好方便!
- 2081. k 镜像数字的和 `难`
  - 找到前 n 个, 在 10进制 和k进制下均为回文数的数字, 返回其最大值
  - 注意题目要求, 2 <= k <= 9, 1 <= n <= 30 当k和n均取较大值时会超时(约10**10量级); 因此重点是如何所见搜索空间.
    - 由于是回文数, 因此只需遍历前半部分即可, 注意可生成奇数或偶数长度的, 例如 1234 -> 1234321 或 12344321;
    - 另外, 每次遍历 [1,9], [10,99]... 的数字, 对于j位十进制数, 可分别生成 2j-1, 2j 位十进制数

### 269

- 2089. 找出数组排序后的目标下标
- 2090. 半径为 k 的子数组平均值
- 2091. 从数组中移除最大值和最小值
  - 滑动平均
- 2092. 找出知晓秘密的所有专家 `难`
  - 包括 (x, y, time) 的三元组, 若 x 和 y 中某一个知道了「秘密」, 则会进行传播; 要求最后知道「秘密」的所有人
  - 解法一: **构建图**, 传播
    - 按照时间排序, 难点在于判断同一时间的多人传播关系 —— 简单的方案是构建图
    - 解法的具体实现: 利用 edges 字典记录连接关系, 建立图后, 利用 一个 `deque` 记录所有激活节点, 迭代直至队列空
  - 解法二: **并查集**

### 270

- 2094. 找出 3 位偶数
  - 给你一个整数数组, 找出所有的三位偶数(也即要求首位不为 0), 顺序输出(直接排序即可)
  - 简单题 (也可根据提示的范围知道不复杂) 别想太多, 直接暴力遍历即可; 为了避免重复可以用 set()
- 2095. 删除链表的中间节点 `中`
  - 长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始）
  - 解法一: 快慢指针即可, 可以在最开始加上一个「哨兵」
- 2096. 从二叉树一个节点到另一个节点每一步的方向 `中`
  - 找到二叉树两个节点之间的路径
  - 解法一: 直接 DFS 找到两个点从 root 出发的路径, 除去公共路径即可
- 2097. 合法重新排列数对 `难`
  - 给定 pairs(表示区间), 重新排列要求排列后每个区间首尾数字相同; 核心在于理解「[欧拉通路](https://oi-wiki.org/graph/euler/)」, 将问题转换
  - `Hierholzer 算法`: 首先很容易想到, 若仅为「**半欧拉图**」(即存在两个奇数度数节点), 可以确定开始和结束的数字, 否则为「欧拉图」随便选择初始数字/节点即可.
    - 若随便选择一条边, 则可能走到「死路」, 注意此时剩下的图构成了一个「欧拉图」 —— 可以用DFS探索
    - 因此, 1. 每次选择一条边, 在图上删去这条边; 2. 递归; 3. 记录这条边. 注意这里的边是在遍历之后加入记录的 (也即是逆序的, 最后要再逆序输出), 这样可以保证可能漏过的「欧拉图」在此之前被遍历.
  - 参见 「332. 重新安排行程」「753. 破解保险箱」
  - 332 重新安排行程, `难`
    - 区别在于, 需要返回所有的通路中, 字母排序最小的那一个 —— 也即, 每次应该选择较小的那一个节点
    - [solution](https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/) 非常清楚
  - 753. 破解保险箱, `难`
    - 密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。要求返回一个最短字符串, 其子字符串包括所有可能的密码.
    - 关键在于将其转化为一个规范的欧拉通路问题: see [here](https://leetcode-cn.com/problems/cracking-the-safe/solution/po-jie-bao-xian-xiang-by-leetcode-solution/) 官方解答有点fancy
    - 解法: 转换为**欧拉通路问题**
      - 简言之, 要求的是 n 长序列, 都可将其看成 n-1长序列加上 0~k-1 的数字. 因此, 可以构建一个图, 节点为所有的 n-1长序列, 其第i个出边就是在最后加上数字i并去除第一位数字, 跳到相应的节点上.
      - 例如, 节点u的第v的出边就跳转到数值为 u*k % (k**(n-1)) + v 的节点上.
      - 可知, 这样构造的图, 每个节点都有 k条出边和入边, 共可代表 $k^{n-1} * k$ 个不同的数字, 正好对应了所有可能的密码.
      - 显然, 这张图是欧拉图, 并且可基于一个欧拉回路对应一个题目所要求的字符串.

## 题目记录
