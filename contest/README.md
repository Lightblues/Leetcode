
- LeetCode Cookbook <https://books.halfrost.com/leetcode/>
- 代码随想录 <https://github.com/youngyangyang04/leetcode-master>
- Labulalong <https://labuladong.github.io/algo/>; Github <https://github.com/labuladong/fucking-algorithm>

- 编程语言
  - JAVA 廖雪峰课程 <https://www.liaoxuefeng.com/wiki/1252599548343744>
  - Python 库 LearnKu <https://learnku.com/docs/pymotw>

## 代码语法总结

### 传递 值拷贝 vs 指针

典型的问题是遍历二叉树, 例如 113题(找到二叉树路径和为目标值的所有路径), 需要维护一个历史的path.

- go中将slice作为参数传递/赋值(Python中将list作为参数传递也类似), 传递的还是类似指针的类型; 因此相较于值拷贝, 内存开销会小一点.
- 因此, 在对于这个类型进行修改的时候, 需要注意对于外层变量的影响

#### go语言中的slice 传递 & 复制

- go中的slice本质上还是包括了len, cap 属性的一个指针, 可表示为 `[3/5]0xc42003df10`, 传递给函数是浅复制(**仍然指向源slice的底层数组**), 若在函数内进行了修改
  - 若函数内部对slice进行扩容，扩容时生成了一个新的底层数组, 两个 slice 的内存指向就不同了, 不会影响外层slice
  - 若没有进行扩容, 修改了底层数组, 则外层同样引用这一底层数组的slice会被改变
- **复制** slice
  - 可以使用 cope 函数, `copy(s2, s1)` 将s1复制到s2, 若s1较长会被截断, 较短则复制s1那部分(s2后面的部分不变, len也不变); 函数返回成功复制的数量
  - 或者是字面量 `append([]int{}, s1...)`

### 全局变量 vs 传参

参见 113 题(找到二叉树路径和为目标值的所有路径).

- 对于 `pathSum(root *TreeNode, targetSum int) [][]int` 这样的问题
  - **传参**, 递归函数 `pathSumRec(node *TreeNode, sum int, paths *[][]int, tmp []int)`; 这里用了指针 `paths [][]int{}`, 因为初始化的 `[][]int{}` 类型长度为0, 若在函数内部进行 append, 会因为进行了扩容而开辟一个新的内存, 从而无法修改到外层的 slice
  - **全局变量+内部函数**, 在函数内部定义 `var dfs func(root *TreeNode, target int)`, 从而直接修改全局变量, 从而避免了外部定义一个函数, 需要考虑的传参问题

之所以会有这样的困扰, 因为之前没看过 go 的内部函数语法; 从实际应用上来看, 「全局变量+内部函数」的方式无疑更简单和优雅.

## 分类小结

总结一下每道题的思路:

### 07 DP

- 5 最长回文子字符串, `中`
  - 解法四 `DP`, 时间复杂度 O(n^2), 空间复杂度 O(n^2)
  - 解法三 `中心扩散` 法, 时间复杂度 O(n^2), 空间复杂度 O(1)
  - 解法二 `滑动窗口`, 时间复杂度 O(n^2), 空间复杂度 O(1)
  - 解法一 Manacher's algorithm, 时间复杂度 O(n), 空间复杂度 O(n)
- 22 生成所有指定长度的括号对, `中`
  - 解法一 DFS, O(2^n), O(n)
  - `模拟`: 根据记录的数量模拟每一步合法的括号
- 32 最长合法的括号序列 `难`
  - 注意需要记录的其实是「上一个没有被匹配的右括号的下标」
  - 解法一 `栈`, 这里初始化栈底为 -1 并在扫描过程中保证栈不为空, O(n), O(n)
  - 解法二 `双指针` O(n), O(1), 算是对栈方法提升了空间消耗 —— 注意每次需要记录的实际上只有「上一个没有被匹配的右括号的下标」, 因此只需要再配合两个计数器分别记录左右括号出现的数量, 从而判断当前序列是否合法即可; 注意到会忽略 `(()` 这样的终止条件,因此还要从右往左扫描一遍.
- 42 接雨水 `难`
  - 本题是想求针对每个 i，找到它左边最大值 leftMax，右边的最大值 rightMax，然后 `min(leftMax，rightMax)` 为能够接到水的高度
  - 解法一 `扫描`, O(n), O(n), 两次遍历分别记录每个 index 的左右最大值;
  - 解法二 `双指针`, O(n), O(1), 若用双指针一次遍历, 这里维护「全局」的左右最大值 `maxLeft, maxRight`, 需要对于每个 index(遍历的左右指针) 都是合理的, 这里通过控制左右指针的移动 (每次移动较高的那一个) 来更新左右最大值.
- 45 跳跃游戏 `中`
  - 解法一: `贪心/模拟`, O(n), O(1). 注意到, 由于可选择当前位置条约的步数, 因此**可达的最远位置之前的所有格子一定也可达**, 因此可考虑贪心. 扫描步数数组, 维护当前能够到达最大下标的位置, 记为能到达的最远边界, 如果扫描过程中到达了最远边界, 更新边界并将跳跃次数 + 1.
- 53 最大子数组和 `易`, 但个人觉得算 `中`
  - 解法一 `DP`, O(n), O(n), 设计 `dp[i]` 是所有以 i 结尾的区间和的最大值, 状态转移方程是 `dp[i] = nums[i] + dp[i-1] (dp[i-1] > 0), dp[i] = nums[i] (dp[i-1] ≤ 0)`.
  - 解法二 `模拟`, O(n), O(1), 注意到这里实际用到的只是 dp[i-1] —— 事实上可以改写转移方程 `dp[i] = max{dp[i-1], 0} + nums[i]`, 迭代过程中维护这个数字即可
- 55 跳跃游戏, 判断是否可达 `易`
  - 关联 45, 顺序扫描即可, 记录可达的最远距离, 若扫描位置超过该 maxRight 则说明不可达
- 62 矩形到达另一个叫的路径数量, 杨辉三角
- 63 增加 obstacle
- 64 矩形每个坐标有对应数字, 求最小路径 `易` 以上几题都是基本的 DP; 需要注意的是可能可以用节省内存 (但面试/做题时候应该不用考虑). 另外注意64题可以直接在输入矩阵上计算.
- 70 爬楼梯, O(n)
  - 每次一步或两步, 问爬n阶楼梯有几种方式, 递推公式 `dp[i]=dp[i-1]+dp[i-2]` —— 正是斐波那契数列
  - 也可以用 `滚动数组` 节省空间; 公式 `f,g = g, f+g`
- 91 对字母用数字 1-26 编码, 问给定一个数字字符串的解码数量
  - 需要特殊考虑的是0, 要注意 "06" 是不合法的.
  - DP递推公式: `dp[i] += dp[i-1]` (当 1 ≤ s[i-1 : i] ≤ 9)；`dp[i] += dp[i-2]` (当 10 ≤ s[i-2 : i] ≤ 26)
  - 这题和上面的都可以考虑 `哨兵` 的思想, 避免起始的边界情况
- 95 给定一个数字生成所有的元素为1-n的 BST’s (binary search trees) `中` 但个人觉得挺难的 `structure`
  - 这里函数定义是 `func generateTrees(n int) []*TreeNode`, 只需要返回node指针即可.
  - 思路其实比较简单: 注意到对于**二叉搜索树**, 一个节点左边的数均小于该节点; 此题场景下, 递归 `func generateBSTrees(start, end int) []*TreeNode` 即可;
  - 要注意终止条件, 这里可以设置为 `start>end`
- 96 求上面二叉树的数量
  - 在上一题思路下就很简单了: 递推公式 `dp[i] = dp[0] * dp[n-1] + dp[1] * dp[n-2] + …… + dp[n-1] * dp[0]`
- 97 交错字符串 `中`
  - 两个字符串能否在不改变顺序的情况下, 拼接组成第目标字符串; 递推公式 `dp[i][j] = dp[i-1][j]&&s1[i-1]==s3[i+j-1] || dp[i][j-1]&&s2[j-1]==s3[i+j-1]`
  - 注意到第 i 行仅依赖于 第 i-1 行, 因此可以 `滚动数组` 优化空间

### 08 Backtracking

- 17 电话号码的字母组合
  - 直接回溯, 写成DFS即可
- 37 解数独 `难`
  - 注意回溯的思路: 对于每一个为空的格子, 尝试填入所有可能的数字(通过 `checkSudoku(board *[][]byte, pos position, val int) bool` 函数判断是否可行), 最后要把格子还原为空;
  - 终止搜索: 只要找到一个解即可, 因此判断没有剩余的空格时, 直接返回 (最开始阶段, 扫描一遍数独, 将空格子记录到一个数组中).
- 19 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合 `中`
  - 先对candidates排序避免重复, 回溯, 每次填入所有可能的数字(不超过target), 递归函数 `findcombinationSum(candidates []int, target int, index int, currentList []int, res *[][]int)` 其中的target为剩余的目标值, index是当前填入的数字所在指标

-

### 09 DFS

- 94 中序遍历一棵二叉树 `易`
- 98 判断二叉搜索树是否合法 `中`
  - 注意需要一个节点合法, 需要满足「大于左子树上的所有节点, 小于右子树上的所有节点」
  - 递归函数形式 `isValidbst(root *TreeNode, min, max float64) bool`
  - 检查条件 `return v>min && v<max && isValidbst(root.Left, min, v) && isValidbst(root.Right, v, max)`
  - 边界(root): `isValidbst(root, math.Inf(-1), math.Inf(1))`
- 99 **二叉搜索树**中的两个节点被错误地交换。恢复这棵树。`中`, 偏 `难`
  - see [here](https://leetcode-cn.com/problems/recover-binary-search-tree/solution/hui-fu-er-cha-sou-suo-shu-by-leetcode-solution/)
  - 解法一 中序遍历转为列表. 核心思路是, 二叉搜索树中序遍历等价于一个递增列表, 直接转化为列表后处理
    - 对于交换两个元素, 可能出现一个或两个位置不满足 `a[i]<a[i+1]`, 我们在中序遍历得到的列表中找到要交换的节点即可
    - 若交换的是相邻元素, 例如 [1,3,2,4,5,6,7], 保留指针 i, i+1即可, 若不相邻, 例如 [1,6,3,4,5,2,7], 则会有 i,j 两个元素不满足递增条件, 保留 i+1, j; 综上, 可以通过一次遍历得到要交换的两个节点
  - 解法二 上面是「显式中序遍历」, 将中序遍历的值序列保存在一个数组中, 我们也可以隐式地在中序遍历的过程就找到被错误交换的节点.
    - 思路其实是一样的, 我们只关心中序遍历的值序列中**每个相邻的位置的大小关系是否满足条件**(且错误交换后最多两个位置不满足条件). 因此在中序遍历的过程我们只需要维护**当前中序遍历到的最后一个节点**, 然后在遍历到下一个节点的时候，看两个节点的值是否满足前者小于后者即可，如果不满足说明找到了一个交换的节点，且在找到两次以后就可以终止遍历。
    - 具体实现上, 又可分为递归和用 stack 来记录两种方案. 1. 官答用了栈来记录当前节点的「右父亲列表」(注意, 对一个节点, 其中序遍历的下一个点是其右子树中最小的节点, 即不断尝试访问左儿子); 2. [halforest](https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0099.Recover-Binary-Search-Tree/) 的解答用的是递归, 更为直观
      - 注意这里的递归函数形式 `inOrderTraverse(root, prev, target1, target2 *TreeNode) (*TreeNode, *TreeNode, *TreeNode)` root 为当前节点, prev 为中序遍历的上一个节点, target1, target2 为要找的两个节点; 返回 prev, target1, target2.
  - 解法三 取消栈空间, 略
- 100 判断两个二叉树是否完全相同
  - 深度优先即可
- 101 判断二叉树是否对称
- 104 二叉树的深度
  - DFS 递归
    - 当递归到 nil 时返回 0
    - 节点部位空时返回 `return max(maxDepth(root.Left), maxDepth(root.Right)) + 1`
  - BFS 用stack保存每一层的节点
- 110 判断一棵树是不是平衡二叉树。平衡二叉树的定义是：树中每个节点都满足左右两个子树的高度差 <= 1 的这个条件 `易`
  - DFS 递归 `isBalancedHight(root *TreeNode) (bool, int)` 返回这棵子树是否平衡, 以及树高
- 111 给定一个二叉树，找出其最小深度。最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量
  - 叶子节点是指没有子节点的节点
  - 和 104 的区别在于, 若左右孩子只有一个为空, 则应该根据另一个子树的深度计算; 只有当左右均不为空时才返回 `min(minDepth(root.Left), minDepth(root.Right)) + 1`
- 112 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。说明: 叶子节点是指没有子节点的节点。
  - 还是注意叶子节点的判断
- 113 找出上题中的所有路径 `中`
  - 难度倒是不大, 利用一个变量记录目前的路径, 倒是在 go 和 python 的指针传递上尝试了好久; 详见代码语法总结部分「全局变量 vs 传参」「传递 值拷贝 vs 指针」
- 114 将二叉树展开为链表, 先序遍历
  - 解法一 递归: 对于递归函数 `flatten2(root *TreeNode)`, 分别将左右孩子完成flat, 由于是先序遍历, 所以 `root->root.left->...->root.right` 即可, 注意是左子树转化的链表最末尾连接右子树
  - 解法二 非递归 每次找到左子树的最右(也即链表最后一个元素), 然后将右子树连接上去, 参见 [here](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/)

### 11 binary search 二分查找

- 4 寻找两个有序数组的中位数 `难`
  - 简单起见, 合并更方便
  - 二分搜索, 参见 [here](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)
  - 这里go的实现, 通过维护数组的分界点来找, 思路也很清晰
- 33 搜索旋转排序数组 `中`, 没有重复, 返回索引值
  - 可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 `[l, mid]` 和 `[mid + 1, r]` 哪个部分是有序的
  - 如果 `[l, mid - 1]` 是有序数组 (即 `nums[mid]>=nums[0]`)，且 target 的大小满足 `[nums[l],nums[mid])`，则我们应该将搜索范围缩小至 `[l, mid - 1]`，否则在 `[mid + 1, r]` 中寻找。
  - 反之, 若 `nums[mid]<=nums[-1]`, 则可直接根据 target 是否在 `(nums[mid], nums[r]]` 判断是否在右半部分, 否则在另一边搜索
- 34 找出给定目标值在排序数组中的开始位置和结束位置
  - 基本变体: 找第一个/最后一个等于 target 的元素
- 35 查找有序数组插入位置 `中`
  - 经典变体, 即「在有序数组中找到最后一个比 target 小的元素」
- 69 实现 sqrt
  - 解法二 `牛顿法`, 即求 `f(x)=x^2-n` 的零点
  - 更 fancy 的还可以更快
- 74 搜索二维有序数组 `中`
  - 基本的二分搜索
- 81 搜索旋转排序数组Ⅱ, 和33题相比多个可重复
  - 其实仅仅多了一种情况: 当 `nums[mid] == nums[l] && nums[mid]==nums[r]` 时无法判断哪一部分是有序的, 因此只能 `l++; r--`
- 153 搜索旋转排序数组 中的最小值(旋转点) `中`
  - 由于旋转数组也可以是正常升序数组, 因此判断条件应该是和 high 比较而不能只和 low 比较
  - 解法一 其实也可以用基本的二分范式 `l<=r`, 判断条件复杂一点
  - 解法二 这类题目也可以用 `low < high` 作为终止条件, 相较于基本范式, 这里 high 和 low 的是不对等的. high 只是用来缩减搜索范围, 而 low为输出结果的指针
- 154 相较于 153 增加了可重复条件 `难`
  - 如果还是用基本范式, 判断条件会更复杂一点; 但用双指针逼近的思路会更清楚
- 162 找到数组中的「**山峰**」 `中`
  - 算是二分的经典变体, 和 153 一样用 high low 进行判断会比较简单; 基于 `nums[mid+1] >= nums[mid]` 进行更新
- 167 找到两数之和为目标值的index
  - 和第 1 题一样, 不过时排好序的, 可以用双指针逼近, 从而免去了map空间
- 209 长度最小的子数组 `中`
  - 正数数组, 找到 >=target 的连续子数组的最小长度.
  - 解法一 先计算 cumsum, 然而对于每一个子数组开始位置, 可以用二分搜索找到最小长度, 时间 O(nlogn), O(n)
  - 解法二 「**滑动窗口**」在滑动窗口 [i,j]之间不断往后移动，如果总和小于 s，就扩大右边界 j，不断加入右边的值，直到 sum > s，之和再缩小 i 的左边界，不断缩小直到 sum < s，这时候右边界又可以往右移动。以此类推。 O(n), O(1)

总结了二分查找的注意点:

- 循环退出条件，注意是 low <= high，而不是 low < high。
- mid 的取值，mid := low + (high-low)»1
- low 和 high 的更新。low = mid + 1，high = mid - 1。

四个基本的变种

- 二分查找第一个与 target 相等的元素，时间复杂度 O(logn)
- 二分查找最后一个与 target 相等的元素，时间复杂度 O(logn)
- 二分查找第一个大于等于 target 的元素，时间复杂度 O(logn)
- 二分查找最后一个小于等于 target 的元素，时间复杂度 O(logn)

另外一类常见的: 基本有序数组. 在山峰数组中找山峰，在旋转有序数组中找分界点。第 33 题，第 81 题，第 153 题，第 154 题，第 162 题，第 852 题

### 12 math

- 2 两数相加, 形式为逆序链表. `中`
  - 定义了基本的 `ListNode` 结构, 并定义 `List2Ints, IntsList` 实现数组和链表的方便转换.
- 7 反转32位整数 `中`
  - 这题主要的限制是在要防止 32位 sign int 溢出, 讨巧的思路可以用更长的整数类型/字符串来保存. 「标准」思路应该是每次 `*10` 之前进行检查 (或者说, 和 `math.MinInt32/10` 进行比较) 防止溢出.
- 9 Palindrome 回文数
  - 同样可以采用 1. 反转数字; 2. 转为数组; 3. 转为字符串等方式.
  - 直接反转可能溢出 (虽然此时必然不是回文数); 思路是「反转整数长度的一半」(即循环条件 `x>rev`), 最后的判断条件: 若 x 为回文数且长度为偶数, 则 `x==rev`; 若为奇数, 则 `x==rev/10`
- 12, 13 罗马数字转阿拉伯数字
  - 就是所使用的基数不用, 累计即可
- 60 Permutation-Sequence 找出以一定的数字作为元素的排列中的第 k 个 `难`
  - 思路一 也即官方的 [缩小问题规模](https://leetcode-cn.com/problems/permutation-sequence/solution/di-kge-pai-lie-by-leetcode-solution/); 其实也可理解为贪婪剪枝的 DFS?
    - 使用 go 来实现的时候没有 Python 中好用的 `math.perm` 函数, 方便的类型转换等. 解答中用到的一些技巧值得学习. 例如, 1. 构造了 factorial 来实现 Python 中的 math.perm; 2. 用 valid 数组标记还没有用过的数字
    - 重点还是要明确公式: `a_i=(k-1)mod(n-1)!+1`
  - 反过来的问题: 对于给定的排列确定其为顺序第几个?
    - 公式 `k=sum(order_i*(n-1)!)+1`, 其中的 order_i 是在 序列 `a_i+1...a_n` 中小于 a_i 的元素数量
- 29 整除 `中`
  - 思路一 类似二分查找, 每次将除数 `*2` 找到小于等于被除数的最大的那一个, 迭代终止条件是 `dividend<divisor`, 即不断减去除数的倍数之后, 剩余的部分小于除数
  - 思路二 `倍增法` 实际上在除数递增的过程中即可将被除数相减, 当增大到接近被除数之后再不断 `/2`, 终止条件是因子 `cnt==0`, 也即 `dividend<divisor`

## 周赛笔记

### 268

- 2078. 两栋颜色不同且距离最远的房子
- 2079. 给植物浇水
  - 模拟法
- 2080. 区间内查询数字的频率 `中`
  - 需求是查询子数组 arr[left...right] 中 value 的 频率; 考虑到查询数量可能较大, 因此设计一个数据结构存储数据分布信息
  - 解法: 用 map 保存数字所出现的位置列表, 从而查询时候可以用**二分查找**.
    - Python 可以直接用 `bisect.bisect` 好方便!
- 2081. k 镜像数字的和 `难`
  - 找到前 n 个, 在 10进制 和k进制下均为回文数的数字, 返回其最大值
  - 注意题目要求, 2 <= k <= 9, 1 <= n <= 30 当k和n均取较大值时会超时(约10**10量级); 因此重点是如何所见搜索空间.
    - 由于是回文数, 因此只需遍历前半部分即可, 注意可生成奇数或偶数长度的, 例如 1234 -> 1234321 或 12344321;
    - 另外, 每次遍历 [1,9], [10,99]... 的数字, 对于j位十进制数, 可分别生成 2j-1, 2j 位十进制数

### 269

- 2089. 找出数组排序后的目标下标
- 2090. 半径为 k 的子数组平均值
- 2091. 从数组中移除最大值和最小值
  - 滑动平均
- 2092. 找出知晓秘密的所有专家 `难`
  - 包括 (x, y, time) 的三元组, 若 x 和 y 中某一个知道了「秘密」, 则会进行传播; 要求最后知道「秘密」的所有人
  - 解法一: **构建图**, 传播
    - 按照时间排序, 难点在于判断同一时间的多人传播关系 —— 简单的方案是构建图
    - 解法的具体实现: 利用 edges 字典记录连接关系, 建立图后, 利用 一个 `deque` 记录所有激活节点, 迭代直至队列空
  - 解法二: **并查集**

### 270

- 2094. 找出 3 位偶数
  - 给你一个整数数组, 找出所有的三位偶数(也即要求首位不为 0), 顺序输出(直接排序即可)
  - 简单题 (也可根据提示的范围知道不复杂) 别想太多, 直接暴力遍历即可; 为了避免重复可以用 set()
- 2095. 删除链表的中间节点 `中`
  - 长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始）
  - 解法一: 快慢指针即可, 可以在最开始加上一个「哨兵」
- 2096. 从二叉树一个节点到另一个节点每一步的方向 `中`
  - 找到二叉树两个节点之间的路径
  - 解法一: 直接 DFS 找到两个点从 root 出发的路径, 除去公共路径即可
- 2097. 合法重新排列数对 `难`
  - 给定 pairs(表示区间), 重新排列要求排列后每个区间首尾数字相同; 核心在于理解「[欧拉通路](https://oi-wiki.org/graph/euler/)」, 将问题转换
  - `Hierholzer 算法`: 首先很容易想到, 若仅为「**半欧拉图**」(即存在两个奇数度数节点), 可以确定开始和结束的数字, 否则为「欧拉图」随便选择初始数字/节点即可.
    - 若随便选择一条边, 则可能走到「死路」, 注意此时剩下的图构成了一个「欧拉图」 —— 可以用DFS探索
    - 因此, 1. 每次选择一条边, 在图上删去这条边; 2. 递归; 3. 记录这条边. 注意这里的边是在遍历之后加入记录的 (也即是逆序的, 最后要再逆序输出), 这样可以保证可能漏过的「欧拉图」在此之前被遍历.
  - 参见 「332. 重新安排行程」「753. 破解保险箱」
  - 332 重新安排行程, `难`
    - 区别在于, 需要返回所有的通路中, 字母排序最小的那一个 —— 也即, 每次应该选择较小的那一个节点
    - [solution](https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/) 非常清楚
  - 753. 破解保险箱, `难`
    - 密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。要求返回一个最短字符串, 其子字符串包括所有可能的密码.
    - 关键在于将其转化为一个规范的欧拉通路问题: see [here](https://leetcode-cn.com/problems/cracking-the-safe/solution/po-jie-bao-xian-xiang-by-leetcode-solution/) 官方解答有点fancy
    - 解法: 转换为**欧拉通路问题**
      - 简言之, 要求的是 n 长序列, 都可将其看成 n-1长序列加上 0~k-1 的数字. 因此, 可以构建一个图, 节点为所有的 n-1长序列, 其第i个出边就是在最后加上数字i并去除第一位数字, 跳到相应的节点上.
      - 例如, 节点u的第v的出边就跳转到数值为 u*k % (k**(n-1)) + v 的节点上.
      - 可知, 这样构造的图, 每个节点都有 k条出边和入边, 共可代表 $k^{n-1} * k$ 个不同的数字, 正好对应了所有可能的密码.
      - 显然, 这张图是欧拉图, 并且可基于一个欧拉回路对应一个题目所要求的字符串.

### 271

- 2105. 给植物浇水 II
  - 模拟法即可
- 2106. 摘水果 `难`
  - 在一个无限的 x 坐标轴上, 分布一定的水果, 给定 startPos 和可以移动的步数 k, 计算可以拿到的最大数量
  - 题型: 其实就是给定一个累加和, 探索所有可能的范围内的最大值; 问题在于如何在离散存储的数组中找到对应的元素
    - 存储方式: 例如对 `[[2,8],[6,3],[8,6]]` 水果分布而言, 记录位置 `pos=[-Inf, 2,6,8]` 和 累计和 `[0,8,11,17]`
    - **二分查找**. 要注意 **边界情况**, 左边应该是 `bisect.bisect_left`, 而右边是 `bisect.bisect_right`, 注意函数返回的是待插入的 index, 因此最终能采集的水果数量为 `cumsum[rindex-1] - cumsum[lindex-1]`
    - 错误记录: 注意, 先往左边走和先往右边走所能达到的范围是不一样的! 因此两侧的情况都应该考虑到.

### 272

- 2110. 股票平滑下跌阶段的数目
  - 一次遍历即可
- 2111. 使数组 K 递增的最少操作次数 `难`
  - 如果对于每个满足 `k <= i <= n-1` 的下标 i ，都有 `arr[i-k] <= arr[i]` ，那么我们称 arr 是 K 递增 的。
  - 给定一个数组和 k,要求找到使得这个数组 k递增的最小修改次数.
  - 问题可转化为: 寻找一个数组中的最长递增序列, 参见 300 题 [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/)
    - 思路 1: DP, 定义 `dp[i]` 为 第 i 个数字结尾的最长上升子序列的长度, 注意 第 i 个元素必须被选中; 递推公式 `dp[i] = max(dp[j]) + 1`, 其中的 j 要求 `nums[j]<=nums[i]`
      - 时间复杂度 $O(n^2)$
    - 方法二：贪心 + 二分查找
      - 维护一个数组 `d[i]` ，表示**长度为 i 的最长上升子序列的末尾元素的最小值**, 用 len 记录目前最长上升子序列的长度. 注意到数组 d 是单调递增的
      - 我们依次遍历数组 nums 中的每个元素，并更新数组 d 和 len 的值。如果 `nums[i]>d[len]` 则更新 `len = len + 1`，否则在 `d[1…len]`中找满足 `d[i−1]<nums[j]<d[i]` 的下标 i，并更新 `d[i]=nums[j]`。
      - 由于是递增数列, 可以用二分搜索
      - 时间复杂度 $O(n log(n))$

### 273

- 2120. 执行所有后缀指令
  - 模拟机器人动作即可
- 2121. 相同元素的间隔之和 `中`
  - 给定一个数组, 计算其中相同元素所在的 index 之差, 返回所有这些距离的和
  - 用一个 defaultdict(list) 记录各个元素出现的位置.
  - 问题转化为对于一个数字出现的位置, 计算各个位置的 dist 和.
    - 注意数据量, 直接暴力遍历复杂度为 $O(n^2)$ 会超时
    - 思路1: 观察相邻两个元素相差的(子距离数量), 可得递推公式 `dp[i+1] = dp[i] -(n-2i-2) * (arr[i-1]-arr[i])`
    - 思路2: 计算 cumsum, 则 i 处的距离和为 `(cumsum[-1]-cumsum[i] - arr[i]*(n-1-i)) + (cumsum[i]-cumsum[0] - arr[0]*i)`
- 2122. 还原原数组 `难`
  - 就是对于一个数组 arr, 用一个正整数 k, 分别生成两个数组, `lower[i] = arr[i] - k, higher[i] = arr[i] + k`. 要求给定这两个数组的混合, 还原 arr
  - 注意看约束条件, 数组大小最多为 `1000` 所以暴力搜索即可, 题目只是比较繁琐
    - sort, 得到可能的 k
    - 用 `indexRecord` 记录每个数字对应的位置
    - 关键在判断一个 k 是否满足条件. 这里用了一个 `used` 记录每个所对应的元素所在位置, 遍历 nums 后, 若 `sum(used) == n` 则说明 k 满足条件
  - see [here](https://leetcode-cn.com/problems/recover-the-original-array/solution/huan-yuan-yuan-shu-zu-by-leetcode-soluti-nizi/)

### 274

- 5970. 参加会议的最多员工数 `难`
  - 每个人只有一个喜欢的人, 要求安排坐圆桌, 每个人左右要有他喜欢的人, 最大的可安排人数
  - 比较容易想到, 问题主要转化为求这样的有向图上的最大环,
    - 特殊情况是两个互相喜欢的人, 他们相互满足了要求, 因此左右可以有一条「喜欢人的链」, 并且左右的人都是满足的; 因此, 这种大小为 2 的环一个桌上可以安排多个
    - 参见 [这个题解](https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/solution/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/), 这种图叫做 **内向基环树 (pseudotree)**
  - 所以核心问题在于如何在 pseudotree 中找环, 比赛中的尝试没有想到如何「**剪枝**」超时了; 实际上, 可以通过一次 **拓扑排序** 剪掉所有的分支 (最后留在图上的点的度数最大为 1)
    - 具体实现上, 维护一个入度为 0 的队列, 对其喜欢的人的入度 -1, 如果减到了 0 则继续加入队列;
    - 这样, **拓扑排序后最终剩下的点都是成环的**(入度为 1).

### 275

- 5976. 检查是否每一行每一列都包含全部整数
- 5977. 最少交换次数来组合所有的 1 II
  - 滑动平均
- 5978. 统计追加字母可以获得的单词数
  - 注意审题
- 5979. 全部开花的最早一天
  - 两个数组, 分别是 播种 和 开花 所需的时间, 要求使得所有花都开放的最小时间
  - 题目给了干扰: 将一种花分成两次播种没有意义, 因为两者总的播种时间是一样的, 因此在过程中两种花都不会提早开花.
  - 于是可以化简为, 给依次播种的花进行排序
  - 可知, 总的播种时间是一定的, 目标在于减少开花所需时间. 因此每次根据开花所需时间排序, 选择需要最长时间的那种即可.

### 276

- 5980. 将字符串拆分为若干长度为 k 的组
- 5194. 得到目标值的最少行动次数
  - 给定一个目标数, 从 1 开始 +1, *2 两种操作, 限定了倍乘的次数 maxDoubles
  - 贪心, 从 target 往下 /2
- 5982. 解决智力问题
  - 给定一系列的题目, questions[i] = [pointsi, brainpoweri], 你选择做某一题的代价是只能跳过后面 brainpower 题
  - DP, 从后往前, 记录从该位置往后的最大解, 递推公式 `dp[i] = max([dp[i+1], point+dp[i+skip+1]])`
- 5983. 同时运行 N 台电脑的最长时间
  - 给定一组电池 batteries, 每个电池可以给一台电脑运行一定的时间. 可以把一个电池替换给不同的电脑, 要求让所有电脑同时运行的最长时间
  - 这里的限制条件为电量最大的 n 个电池, 小的电池看作对它们的补充.
  - 注意到: 一个电池的电量可以以**任意的比例**分到若干块电池上.
  - 因此, 可以将最大的 n 个电池看成一个「阶梯」, 其余的小电池理解为在这个池子里注水, 求高度

### D68

- 2114. 句子中的最多单词数
- 2115. 从给定原材料中找到所有可以做出的菜
  - 给定一个菜单, 每道菜的成分可能包括食材或其他的菜品, 要求在一定的初始食材下能够得到的所有菜品
  - 思路一: 本题数据量比较小, 可以暴力遍历. 用一个 flag 记录一次遍历是否有新的菜品(食材) 生成, 当没有时即结束
  - 思路二: 依赖关系构成图, 显然可以用 `拓扑排序` 解决, see [here](https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/solution/cong-gei-ding-yuan-cai-liao-zhong-zhao-d-d02i/)
- 2116. 判断一个括号字符串是否有效 `中`
  - 给定一个在某些位上固定的字符串 (例如 `s = "))()))", locked = "010100"`), 判断能够通过修改其他自由位使其成为合法的括号序列
  - 思路一: 关注 lock 部分 (剩下偶数个自由位一定可以匹配)
    - 先尝试匹配 lock 部分的字符串, 记录未成功匹配的位置 (三种情况, 最后剩下 `((`, `))` or `))((`; 和 空白符号的位置;
    - 利用 space 字符串来匹配剩下的左右括号 leftStack, rightStack
    - 原本分了上面三种情况讨论, 实际上可以合并: 用 space 最前面的部分匹配右括号, 最后面的部分匹配左括号, `len(spaces)>=len(leftStack)+len(rightStack) and all([i>j for i,j in zip(spaces[-len(leftStack):], leftStack)]) and all([i<j for i,j in zip(spaces[:len(rightStack)], rightStack)])`
  - 方法一：数学, see [here](https://leetcode-cn.com/problems/check-if-a-parentheses-string-can-be-valid/solution/pan-duan-yi-ge-gua-hao-zi-fu-chuan-shi-f-0s47/)
    - 定义了有效字符串「分数」的概念, 然后通过: 维护 1. 前缀 s[0..i] 可以达到的最大分数；2. 前缀 s[0..i] 「可以达到的最小分数」及「作为有效前缀所需的最小分数」两者的较大值. 这两个数组来进行判断.
- 2117. 一个区间内所有数乘积的缩写 `难`
  - 放弃了
  - 参见 [思路详解+详细讨论一下精度问题](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/fen-bie-ji-suan-qian-5wei-he-hou-5wei-si-dc9x/), Python 超时了. 另外 [here](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/yi-ge-shu-ju-tuan-mie-jue-da-bu-fen-dai-234yd/) 做了更多的分析

## 每日一题

- 2029. 石子游戏 IX `中` 但实际上可以说很难!
  - 分别取石子, A优先, 两条规则
    - 当某个人取出后总和为 3的倍数时, 其失败;
    - 当取完所有的石子, 条件1不成立, 则 A 失败(不管最后一个是谁取的).
  - 博弈, 参见 [官方解答](https://leetcode-cn.com/problems/stone-game-ix/solution/shi-zi-you-xi-ix-by-leetcode-solution-kk5f/).
  - 首先的失败条件是取出的石子总和为 3, 因此可将石子除以3的余数为 0,1,2 分成三类
  - 先不考虑 0, 假设只有 1,2. 由于每个人都是最佳决策, 因此只会出现
    - `1,1,2,1,2,1,...` 或者 `2,2,1,2,1,2,...` 的序列. 也即除了第一颗, 两个都回去相同的石子.
    - 条件 1 的失败条件为对方没有可取的石子, 因此 A 的策略是取数量少的那一类.
      - 以 `1,1,2,1,2,1,...` 序列为例, A 获胜条件为: 有类型 1 的石子并且数量少于类型 2, `0 < cn1 <= cn2`
    - 综合两种情况, A 获胜条件为 `cnt1 >= 1 and cnt2 >= 1`
  - 还要考虑 1, 当 0 的数量为偶数时, 条件不改变. 考虑 0 有奇数个
    - A 的策略仍然是选择较少的类, 然而此时 B 可以有一次选类型 0 石子的机会, 因此条件变为
      - `cnt1 - cnt2 > 2 or cnt2 - cnt1 > 2`
- 1345. 跳跃游戏 IV `难`
  - 给一个数组, 只能前后一格, 或者跳到相同数字的格子上, 求到达终点的最小跳数
  - 显然可以建模为最短路径问题;
  - 然而直接建图 BFS 超时了. 问题在于, 当存在大量点的数字相同, 变为稠密图, BFS 复杂度为 `O(n^2)`
  - 方法一：广度优先搜索 see [here](https://leetcode-cn.com/problems/jump-game-iv/solution/tiao-yue-you-xi-iv-by-leetcode-solution-zsix/)
    - 考虑这一问题的特殊性: 所有相同元素构成稠密图, 因此没有必要遍历改子图上所有的边 —— 递归一遍这些节点后, 没有必要在这一稠密图上搜索了
    - 因此, 直接不构建这一部分的图
    - 具体而言, 不构建显式的图, 直接记录每个数值包括的位置集合 val2index. 当从一个点 index 出发遍历了所有 val2index[arr[index]] 中的节点后, 直接 `del val2index[arr[index]]` 从而避免构建这一稠密图
