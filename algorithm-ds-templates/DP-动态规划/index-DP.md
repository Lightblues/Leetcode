
[DP问题分类汇总](https://chengzhaoxi.xyz/42296.html)
见 [leetcode动态规划题目总结](https://leetcode.cn/circle/article/2Xxlw3/)



LIS: Longest increasing subsequence (最长递增子序列) 
最经典双串 LCS 系列：

见 [灵神](https://space.bilibili.com/206214/channel/collectiondetail?sid=842776)

- DP入门
- 01背包
- 最长公共子序列, 编辑距离
- 最长递增子序列
- 股票
- 区间DP: 最长回文子序列, 最优三角形剖分




# Interview 面试题

## 线性DP
### 单串问题, 状态为 dp[i]

- 最长上升子序列LIS
    - 0300. 最长上升子序列
    - 0673. 最长递增子序列的个数
        - 假设最长递增序列长度为x, 要统计这种序列的数量. 在 f[i] 表示以i结尾的LIS的基础上, 加一个 cnt数组记录以i结尾的LIS的数量
- 最大子串和系列问题
- 打家劫舍系列: 不相邻子序列的最大和问题
    - 0198. 打家劫舍
    - 0213. 打家劫舍 II 环形数组的处理

### 双串问题, 状态为 dp[i][j]

- 最长公共子序列LCS
    - 1143. 最长公共子序列 求两个字符串的最长公共子序列长度
        - `f[i][j]` 表示两个前缀字符串的最长子序列 (不要求包含i,j)
        - 若两个字符不同, 有 f[i][j] = max{ f[i-1,j], f[i,j-1], f[i-1,j-1] }; 否则直接 f[i-1,j-1] + 1
    - 1092. 最短公共超序列
    - 0392. 判断子序列
    - 0718. 最长重复子数组 最长公共子串，有字符串哈希等更有效的算法，注意与最长公共子序列的区别
- 字符串模糊匹配
    - 0072. 编辑距离
        - `f[i,j]` 表示 arr1[:i]和arr2[:j] 的编辑距离
    - 0583. 两个字符串的删除操作
- 其它
    - 0097. 交错字符串 检查 s3 是否是由 s1 和 s2 交错 组成
        - `f[i,j]` 表示 s1[0:i] 和 s2[0:j] 是否能交错组成 s3[0:i+j]
    - 0115. 不同的子序列 #hard 计算在s中的子序列为t的数量
        - `f[i,j]` 表示 s[0:i] 中 t[0:j] 出现的次数
    - 0727. 最小窗口子序列 #hard 给定字符串 S 和 T，找出 S 中最短的（连续）子串 W，使得 T 是 W 的子序列
        - 有些难, 可以pass
    - 1458. 两个子序列的最大点积 #hard 
        - f[i,j] 表示子问题, 则有转移 max{ f(i-1,j), f(i,j-1), max{f(i-1,j-1),0} + nums1[i]*nums2[j] } 注意这里可以不用 (i-1,j-1) 转移

### 矩阵问题 dp[i][j] (i, j) 共同表示位置

- 0120. 三角形最小路径和 #medium 基本
- 0064. 最小路径和 #medium 基本
- 1301. 最大得分的路径数目 #hard 在求最大路径的基础上进行计数
- 1594. 矩阵的最大非负积 #medium 注意负数的问题, 因此需要在mx的基础上记录mn
- 0174. 地下城游戏 #hard 从矩阵左上走到右下, 求最小初始血量
    - `f[i,j]` 表示从 (i,j) 到达目标的最小初始血量
    - 注意到! 本题不能直定义 `f[i,j]` 为到达 (i,j) 的最小血量, 因为此时剩余的血量也会影响! 也即不满足官答中说的「无后效性」
- 0931. 下降路径最小和 #medium 基本
- 0221. 最大正方形 #medium 0/1矩阵中最大的全1正方形面积
    - f[i,j] 表示以 (i,j) 为右下角的最大正方形边长
    - 递推: min(f(i-1,j),f(i,j-1),f(i-1,j-1))+1

### 线性 DP，状态在阶段的基础上附加维度

- 单串问题, 状态为 dp[i][k]
- 单串问题, 状态为 dp[i][k1][k2]
- 双串问题, 状态为 dp[i][j][k]
- 矩阵问题, 状态为 dp[i][j][k]


## 区间DP

减治型

- 0005. 最长回文子串 #medium `f[i,j]` 表示是否回文
- 0647. 回文子串 #medium 统计数量, 同 0005
- 0486. 预测赢家 #medium `f[i,j]` 表示在区间 [i,j] 中先手与后手的分数差
- 0516. 最长回文子序列 #medium `f[i,j]` 表示在区间 [i,j] 中的最长回文子序列长度

分治型

- 0312. 戳气球 #hard 倒过来看变成放气球 `f[i,j]` 表示填充开区间 (i,j) 可以获得的最大分数
- 0471. 编码最短长度的字符串 #hard `f[i,j]` 表示最小编码. 递推 f[i,j] = min{ f[i,k]+f[k+1,j] } 如果 g[i,j] 可以的话加一项 g[i,j]

## 背包DP

参见 [labuladong](https://labuladong.gitee.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/)

0-1 背包

- 0322. 零钱兑换 (完全背包) #medium 有一些金额硬币, 求最少需要多少个硬币凑出金额
    - f[i,c] 表示用前i种硬币是否可以构成总额c
- 0474. 一和零 (二维费用背包)
- 1049. 最后一块石头的重量 II 转换为01背包问题，使得背包剩余容量最小
- 0416. 分割等和子集 (01背包-要求恰好取到背包容量)
    - 判断这个数组是否可以被分割成两个子集，使得两个子集的元素和相等
    - `dp[i][x]` 表示前i个物品是否恰好可以构成和为x



## 树形 DP



## 状态压缩 DP


