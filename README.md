
- LeetCode Cookbook <https://books.halfrost.com/leetcode/>
- 代码随想录 <https://github.com/youngyangyang04/leetcode-master>
- Labulalong <https://labuladong.github.io/algo/>; Github <https://github.com/labuladong/fucking-algorithm>
- 宫水三叶 <https://github.com/SharingSource/LogicStack-LeetCode> Index 中对于题型进行了总结

- 编程语言
  - JAVA 廖雪峰课程 <https://www.liaoxuefeng.com/wiki/1252599548343744>
  - Python 库 LearnKu <https://learnku.com/docs/pymotw>

## 代码语法总结

### Stducture 数据结构

- 208. 实现 Trie (前缀树)

### 类型转换

```go
directions := [][]int{
  {-1,0},
  {1,0},
  {0,-1},
  {0,1},
}
[][]byte{
  {'A','B','C','E'},
  {'S','F','C','S'},
  {'A','D','E','E'},
}
```

### 传递 值拷贝 vs 指针

典型的问题是遍历二叉树, 例如 113题(找到二叉树路径和为目标值的所有路径), 需要维护一个历史的path.

- go中将slice作为参数传递/赋值(Python中将list作为参数传递也类似), 传递的还是类似指针的类型; 因此相较于值拷贝, 内存开销会小一点.
- 因此, 在对于这个类型进行修改的时候, 需要注意对于外层变量的影响

#### go语言中的slice 传递 & 复制

- go中的slice本质上还是包括了len, cap 属性的一个指针, 可表示为 `[3/5]0xc42003df10`, 传递给函数是浅复制(**仍然指向源slice的底层数组**), 若在函数内进行了修改
  - 若函数内部对slice进行扩容，扩容时生成了一个新的底层数组, 两个 slice 的内存指向就不同了, 不会影响外层slice
  - 若没有进行扩容, 修改了底层数组, 则外层同样引用这一底层数组的slice会被改变
- **复制** slice
  - 可以使用 cope 函数, `copy(s2, s1)` 将s1复制到s2, 若s1较长会被截断, 较短则复制s1那部分(s2后面的部分不变, len也不变); 函数返回成功复制的数量
  - 或者是字面量 `append([]int{}, s1...)`

### 全局变量 vs 传参

参见 113 题(找到二叉树路径和为目标值的所有路径).

- 对于 `pathSum(root *TreeNode, targetSum int) [][]int` 这样的问题
  - **传参**, 递归函数 `pathSumRec(node *TreeNode, sum int, paths *[][]int, tmp []int)`; 这里用了指针 `paths [][]int{}`, 因为初始化的 `[][]int{}` 类型长度为0, 若在函数内部进行 append, 会因为进行了扩容而开辟一个新的内存, 从而无法修改到外层的 slice
  - **全局变量+内部函数**, 在函数内部定义 `var dfs func(root *TreeNode, target int)`, 从而直接修改全局变量, 从而避免了外部定义一个函数, 需要考虑的传参问题

之所以会有这样的困扰, 因为之前没看过 go 的内部函数语法; 从实际应用上来看, 「全局变量+内部函数」的方式无疑更简单和优雅.

## 分类小结

总结一下每道题的思路:

### 07 DP

- 0005 最长回文子字符串, `中`
  - 解法四 `DP`, 时间复杂度 O(n^2), 空间复杂度 O(n^2). 弃之
  - 解法三 `中心扩散` 法, 时间复杂度 O(n^2), 空间复杂度 O(1)
  - 解法二 `滑动窗口`, 时间复杂度 O(n^2), 空间复杂度 O(1)
  - 解法一 Manacher's algorithm, 时间复杂度 O(n), 空间复杂度 O(n) `难`
- 0022 生成所有指定长度的括号对, `中`
  - 解法一 DFS, O(2^n), O(n)
  - `模拟`: 根据记录的数量模拟每一步合法的括号
- 0032 最长合法的括号序列 `难`
  - 注意需要记录的其实是「上一个没有被匹配的右括号的下标」
  - 解法一 `栈`, 这里初始化栈底为 -1 并在扫描过程中保证栈不为空, O(n), O(n)
  - 解法二 `双指针` O(n), O(1), 算是对栈方法提升了空间消耗 —— 注意每次需要记录的实际上只有「上一个没有被匹配的右括号的下标」, 因此只需要再配合两个计数器分别记录左右括号出现的数量, 从而判断当前序列是否合法即可; 注意到会忽略 `(()` 这样的终止条件,因此还要从右往左扫描一遍.
- 0042 接雨水 `难`
  - 本题是想求针对每个 i，找到它左边最大值 leftMax，右边的最大值 rightMax，然后 `min(leftMax，rightMax)` 为能够接到水的高度
  - 解法一 `扫描`, O(n), O(n), 两次遍历分别记录每个 index 的左右最大值;
  - 解法二 `双指针`, O(n), O(1), 若用双指针一次遍历, 这里维护「全局」的左右最大值 `maxLeft, maxRight`, 需要对于每个 index(遍历的左右指针) 都是合理的, 这里通过控制左右指针的移动 (每次移动较高的那一个) 来更新左右最大值.
- 0045 跳跃游戏 `中`
  - 解法一: `贪心/模拟`, O(n), O(1). 注意到, 由于可选择当前位置条约的步数, 因此**可达的最远位置之前的所有格子一定也可达**, 因此可考虑贪心. 扫描步数数组, 维护当前能够到达最大下标的位置, 记为能到达的最远边界, 如果扫描过程中到达了最远边界, 更新边界并将跳跃次数 + 1.
- 0053 最大子数组和 `易`, 但个人觉得算 `中`
  - 解法一 `DP`, O(n), O(n), 设计 `dp[i]` 是所有以 i 结尾的区间和的最大值, 状态转移方程是 `dp[i] = nums[i] + dp[i-1] (dp[i-1] > 0), dp[i] = nums[i] (dp[i-1] ≤ 0)`.
  - 解法二 `模拟`, O(n), O(1), 注意到这里实际用到的只是 dp[i-1] —— 事实上可以改写转移方程 `dp[i] = max{dp[i-1], 0} + nums[i]`, 迭代过程中维护这个数字即可
- 0055 跳跃游戏, 判断是否可达 `易`
  - 关联 45, 顺序扫描即可, 记录可达的最远距离, 若扫描位置超过该 maxRight 则说明不可达
- 0062 矩形到达另一个叫的路径数量, 杨辉三角
- 0063 增加 obstacle
- 0064 矩形每个坐标有对应数字, 求最小路径 `易` 以上几题都是基本的 DP; 需要注意的是可能可以用节省内存 (但面试/做题时候应该不用考虑). 另外注意64题可以直接在输入矩阵上计算.
- 0070 爬楼梯, O(n)
  - 每次一步或两步, 问爬n阶楼梯有几种方式, 递推公式 `dp[i]=dp[i-1]+dp[i-2]` —— 正是斐波那契数列
  - 也可以用 `滚动数组` 节省空间; 公式 `f,g = g, f+g`
- 0091 对字母用数字 1-26 编码, 问给定一个数字字符串的解码数量
  - 需要特殊考虑的是0, 要注意 "06" 是不合法的.
  - DP递推公式: `dp[i] += dp[i-1]` (当 1 ≤ s[i-1 : i] ≤ 9)；`dp[i] += dp[i-2]` (当 10 ≤ s[i-2 : i] ≤ 26)
  - 这题和上面的都可以考虑 `哨兵` 的思想, 避免起始的边界情况
- 0095 给定一个数字生成所有的元素为1-n的 BST’s (binary search trees) `中` 但个人觉得挺难的 `structure`
  - 回溯: 遍历 start~end 作为根, 递归生成左右子树
  - 这里函数定义是 `func generateTrees(n int) []*TreeNode`, 只需要返回node指针即可.
  - 思路其实比较简单: 注意到对于**二叉搜索树**, 一个节点左边的数均小于该节点; 此题场景下, 递归 `func generateBSTrees(start, end int) []*TreeNode` 即可;
  - 要注意终止条件, 这里可以设置为 `start>end`
- 0096 求上面二叉树的数量
  - 不同的二叉搜索树 II `中` 返回由 1~n 构成的所有 BST
  - 在上一题思路下就很简单了: 递推公式 `dp[i] = dp[0] * dp[n-1] + dp[1] * dp[n-2] + …… + dp[n-1] * dp[0]`
- 0097 交错字符串 `中`
  - 两个字符串能否在不改变顺序的情况下, 拼接组成第目标字符串; 递推公式 `dp[i][j] = dp[i-1][j]&&s1[i-1]==s3[i+j-1] || dp[i][j-1]&&s2[j-1]==s3[i+j-1]`
  - 注意到第 i 行仅依赖于 第 i-1 行, 因此可以 `滚动数组` 优化空间
- 0115 不同子序列 `难`
  - 给定两个字符串, 计算字符串 s 中的子序列构成 t 的数量
  - 递推公式: 若 s[i]==t[j], 根据是否匹配这两个字符, 加和两种情况 `dp[i,j] = dp[i-1,j-1] + dp[i-1,j]`; 否则只有第二项
- 0118 Pascal 三角
- 0119 Pascal 三角 Ⅱ `易`
  - 返回杨辉三角的第 i 行
  - 一种方式是直接按照构造方式按行生成
  - 方法二：线性递推 根据组合数公式 $C_n^m = \frac{n!}{m!(n-m)!}$ , 可知相邻两个元素关系为 $C_n^m = C_n^{m-1} \times \frac{n-m+1}{m}$, 从而将时间复杂度降到 O(i)
- 0121 买卖股票的最佳时机
  - 只有一次交易机会
  - 维护一个 minNow, 遍历的时候更新当前为止的最小值
- 0122 买卖股票的最佳时机 II
  - 不限买卖次数
- 0152 一个数组中累计乘积最大的连续子序列 `中`
  - 考虑到正负的问题, 主要是可能出现 0
  - DP思路, 需要维护两个状态: 以当前结尾的 maxNow 和 minNow
    - 需要考虑正负的情况, 更新公式 `maxNow = max{maxNow, maxNow*nums[i], minNow*nums[i]}`, minNow 是三者取最小.
- 0174 地下城游戏 `难`
  - 用一个矩阵表示每个房间的 HP 损失(获得), 要求从左上角走到右下角的最小 HP
  - 不同与最短路径和, 要求每一个状态时刻的 HP 都为正数.
  - 方法一：动态规划. 采用 DP, 注意要从终点向前遍历. [因为不知道往后的路径需要消耗多少 HP, 因此不满足「无后效性」]. see [here](https://leetcode-cn.com/problems/dungeon-game/solution/di-xia-cheng-you-xi-by-leetcode-solution/)
    - 「我：公主，你自杀吧，我走不过去。公主：傻屌，起点等着，我去找你！」
    - DP 的含义: 进入该格子前至少需要的血量.
    - 转移方程: `dp[i][j] = max{1, min{dp[i+1][j], dp[i][j+1]}-dungeon[i][j]}`
    - 注意初始化边界情况, 或者像答案中一样采用哨兵.
- 0198 小偷 `中` 不能偷连续的房子, 要求收益最大
- 0213 小偷 Ⅱ 相较于 0198 题, 房子是个「环」, 即增加了不能同时使用收尾的条件
  - 由于首尾是相邻的，所以在取了第一个房子以后就不能取第 n 个房子，那么就在 [0,n - 1] 的区间内找出总价值最多的解，然后再 [1,n] 的区间内找出总价值最多的解，两者取最大值即可。
- 0264 丑数Ⅱ
  - 定义 Ugly 数为质因子均为 2,3,5 的数, 返回第 n 个丑数
  - 方法一: heap. 每次拿出堆中最小元素, 将其 2,3,5 倍数放入堆
    - 注意需要去重
  - 方法二: **三指针**. 第一个数字为 1
    - 用三个指针 `p2,p3,p5` 维护当前列表中待乘以相应数字的元素; 每次选择其中最小的一个加入列表, 向后移动对应指针
    - 和上面去重一样, 这里可能也会有重复情况, 因此指针移动需要考虑该情况 (不是 ifelse 结构而是多个 if)
- 0279 判断一个数最少是多少个完全平方数之和
  - 方法一：动态规划
    - 转移方程为 `dp[i] = min{dp[i-j^2] + 1}`, 这里要求 j 的平方小于等于 i.
  - 方法二: 数学
    - 由拉格朗日的四平方定理可得，每个自然数都可以表示为四个整数平方之和。 其中四个数字是整数。四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。
    - 四平方和定理可以推出三平方和推论：当且仅当 $n \ne 4^k  (8*m+7)$ 时，n 可以被表示为至多三个正整数的平方和。
    - 因此, 可分别讨论是否为 1,4, 枚举判断是否为 2, 若都不是则输出 3. see [here](https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode-solut-t99c/)
- 0300 最长递增数列 `中` ⭐️
  - 方法一: DP.
    - dp[i] 为以第 i 个元素结果为 LIS 长度, 因此注意返回的不是最后一个元素
    - 因此 递推公式为, 找出此前的比当前元素小的位置, 查看其中最大的 LIS 长度 +1
    - Time O(n^2)
    - 方法二：`贪心 + 二分查找`
      - 用一个 `d[i]` 记录长度为 i+1 的IS 的最小结尾元素
      - 遍历数组, 每次的目标: 找到最后一个 `<num` 的元素, 更新该元素后面一个位置 (为新的 LIS 的最小结尾元素); 如果 d 的所有元素都小于 num, 则可以 append 到结尾.
  - 此题是一维的 LIS 问题。二维的 LIS 问题是 `第 354 题`。三维的 LIS 问题是 `第 1691 题` 。
- 0309 带冷冻期的股票收益
  - 这一题是`第 121 题`和`第 122 题`的变种题。每次卖出后的下一天为 Cooldown 无法重新买入
  - see [here](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/). DP, 由于第 i 天结束有三种状态, 因此考虑 记录三种状态的 DP
    - 我们目前持有一支股票，对应的「累计最大收益」记为 `f[i][0]`
    - 我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 `f[i][1]`
    - 我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 `f[i][2]`
  - 相应的转移方程:
    - 买入状态, 分为保持买入或买入新的持有期 `dp[i][0] = max(dp[i-1][0], dp[i-1][2]-prices[i])`
    - 状态1只能从状态0转来 `dp[i][1] = dp[i-1][0]+prices[i]`
    - 状态2只能从状态1,2转来 `dp[i][2] = max(dp[i-1][1], dp[i-1][2])`
  - 注意边界情况, `f[0][0]` 应该初始化为 `-prices[0]`, 其他两个状态初始化为 0
- 0322 零钱兑换 `中`
  - 方法2: DP
    - 一开始考虑到转移公式 `dp[i] = min{dp[j]+1}`, 其中 `j<i` 为满足 `dp[j]` 合法并且 i-j 在 coins 中的位置; 然而复杂度为 O(N^2) 直接超时
    - 反过来想, 要寻找满足要求的 j 只需要遍历 coins 即可找到可能的 j, 复杂度 `O(N * len(coins))`
  - 方法一：记忆化搜索
    - 简单的思路就是 backtracking. 为减小复杂度可以采用「记忆」记录搜索过的状态; 这样就和 DP 是一样的 (不过采用的函数递归的写法).
- 0329 矩阵中的最长递增路径 `难`
  - 给定一个整数矩阵，找出最长递增路径的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。
  - 建模: 有向图, 在数字增大的两个节点之间有边, 即变为在图中寻找**最长路径**
  - 方法一：记忆化深度优先搜索
    - 直接 DFS 复杂度过高, 注意到搜索有很多重复的情况, 因此用「记忆化搜索」; 具体而言, 初始化 `memo` 矩阵元素为 0, 对于经历过的节点最大长度必然 >=1, 以此来判断;
    - 注意到这题中矩阵相邻节点必然是「有向」的, 因此不必特意防止出现循环的问题.
    - 更新公式 `memo[x][y] = 1 + max{memo[nx][ny]}` 其中 [nx, ny] 为符合条件的邻节点
    - 时间: DFS 取决于图的大小, `O(V+E)`, 这里的 边和节点数均为 O(m*n), 因此总体为 `O(m*n)`
  - 方法二：拓扑排序
    - 上面将题目转化为了 DAG, 再结合上面的更新公式, 可知一个点的值完全可由其出度邻居决定 (DP), 因此可以用 **拓扑排序**, 拓扑排序时间复杂度为 `O(V+E)` (每个节点出度为 0 时入栈)
- 0337 小偷 3 `中`
  - 关联 `0198, 0213`, 这里的改动在于房子的结构变为一颗二叉树, 同样要求不能偷相连的两家
  - DFS 即可, 判断逻辑: see[here](https://books.halfrost.com/leetcode/ChapterFour/0300~0399/0337.House-Robber-III/) 逻辑比较简单
    - 注意到一件房子有被偷和不偷两种选项, 因此可以递归 `dfsRob(root *TreeNode) (robMax,notRobMax int)` 返回两种情况下的子树最优解, 返回跟节点这两个值的最大即可
    - 更新公式: 注意选择偷当前节点时左右子树只能加上 notRobMax
- 0338 比特位计数 `易`
  - 计算从 0-num 的所有数, 其二进制表示中的非零位数量
  - 方法四：动态规划——最低设置位
    - 利用二进制性质 `X & (X-1)` 可以清零最低位的1, 得到 DP 公式 `bits[x] = bits[x&(x-1)]+1`
  - [官答](https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/) 还给出了两种类似的思路:
    - 方法二：动态规划——最高有效位.
      - 在 0~num 遍历的过程中, 记录当前数字的最大位所对应的数字 (1,2,4,8,...), 更新公式 `bits[i] = bits[i-highBit] + 1`
      - 这里更新 highBit 的方式还是利用了上面的性质: 当遍历的 i&(i-1) == 0 时说明 i 只有一个非零位, 更新 highBit=i
    - 方法三：动态规划——最低有效位.
      - 分别考虑奇数和偶数的情况
      - `bits[i] = bits[i >> 1] + (i & 1)`;

### 08 Backtracking

- 0017 电话号码的字母组合
  - 直接回溯, 写成DFS即可
- 0037 解数独 `难`
  - 注意回溯的思路: 对于每一个为空的格子, 尝试填入所有可能的数字(通过 `checkSudoku(board *[][]byte, pos position, val int) bool` 函数判断是否可行), 最后要把格子还原为空;
  - 终止搜索: 只要找到一个解即可, 因此判断没有剩余的空格时, 直接返回 (最开始阶段, 扫描一遍数独, 将空格子记录到一个数组中).
- 0039 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合 `中`
  - 先对candidates排序避免重复, 回溯, 每次填入所有可能的数字(不超过target), 递归函数 `findcombinationSum(candidates []int, target int, index int, currentList []int, res *[][]int)` 其中的target为剩余的目标值, index是当前填入的数字所在指标
- 0040 相较于39题candidate有重复, 要求每个元素只能使用一次 `中`
  - 难点在于去除重复
  - 解法1: 排序, 然后在从index开始遍历的过程中, 判断 `if i>index && nums[i]==nums[i-1]` 以避免重复放入一个数字
  - 解法2: 直接将数组转为 map 统计各个数字出现的次数(例如 Python 中的 `freq = sorted(collections.Counter(candidates).items())`), 然后在选数字的时候, 尝试放入相同的数字多次, see [here](https://leetcode-cn.com/problems/combination-sum-ii/solution/zu-he-zong-he-ii-by-leetcode-solution/) .
- 0046 不重复数字**全排列**
- 0047 有重复数字的全排列 `中`
  - DFS即可, 注意**去重**逻辑 —— 先排序, **遍历时前一个相同的数字没有用到, 则这一个不考虑**.
- 51 N皇后 `难`
  - 其实也非常简单, DFS, 然后用 col, dia1, dia2 三个列表分别记录列和两个对角线的位置是否被占用, 遍历 rows 即可 (注意 col长度为 n, 而 dia1, dia2 长度为 2*n-1)
- 0077 组合 Combinations 给定两个数字, 找出所有 combinations of k numbers out of 1 … n
  - k 层 DFS 即可
- 0078 子集 Subsets 给定一个不同元素的数组, 找出所有的子集
  - DFS, 分别考虑第 index 位置的元素是否放入即可
  - 关联 `第 90 题，第 491 题`
- 0090 PowerSets 可重复的数组的所有子集 `中`
  - 排序+DFS
  - 去重逻辑: 用一个 lastUsed 标记上一个元素是否被用到. 当 1. 前后元素相同; 2. 上一个元素未被用到的时候, 应该跳过选入该元素. 也即 `index>0 && (*nums)[index-1]==(*nums)[index] && !lastUsed`
- 0079 判断一个字符串是否出现在一个 grid 中 `中`
- 0089 Gray 编码 `中` 参见 [wiki](https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%9B%B7%E7%A0%81)
  - 1. 直接排列. 以二进制为0值的格雷码为第零项，第一项改变最右边的位元，第二项改变右起第一个为1的位元的左边位元，第三、四项方法同第一、二项，如此反复，即可排列出n个位元的格雷码。
  - 2. 镜像排列. n位元的格雷码可以从n-1位元的格雷码以上下镜射后加上新位元的方式快速的得到。
  - 另外, 观察 1-4 位 Gray码, 结合 wiki, 可以看到, 1. n位Gray码的前 2**(n-1) 位正是 n-1 位 Gray码; 2. Gray码最大的数字是 10000; 3. 上面两种方式生成的顺序是一致的
- 0093 找到一个字符串对应的所有可能 IP
  - 注意判断 IP是否合法, DFS
- 0127 单词接龙 `难`
  - 给定两个单词, 要求从 begin 变为 end, 每次只能变动一个字母, 并且中间的单词要在字典中, 求 **最短转换序列** 的长度
  - 参见 [sol](https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode-solution/)
  - 看到 **最短**, 首先想到 BFS. 为此, 首先需要将问题转化为图.
  - 方法0: BFS
    - 所有的单词 (转化为id) 作为节点, 仅相差一个字母的单词之间连边, BFS
    - 注意: BFS 需要**记录哪些节点未被访问过** (这里用一个 dist 映射记录节点深度), 避免死循环
  - 方法一：广度优先搜索 + 优化建图
    - 所有单词之间要算是否连边, 复杂度较高. 优化思路: 创建**虚拟节点**。对于单词 hit，我们创建三个虚拟节点 `*it、h*t、hi*`，并让 hit 向这三个虚拟节点分别连一条边即可。
    - 注意此时, 计算到的最短路径相应地应该 `/2`
  - 方法二：**双向广度优先搜索**
    - 可以可观地减少搜索空间大小
- 0126 单词接龙 II `难`
  - 要求找到 127 **中所有的最短路径**
  - 这里写得比较繁琐, [here](https://books.halfrost.com/leetcode/ChapterFour/0100~0199/0126.Word-Ladder-II/) 更简洁
  - 核心在于 **BFS 找到所有的最短路径** `BFS`
    - 还是利用 queue 结构, 问题在如何判断是否遍历完了一整层? 用 `queueLen` 记录当前层的长度, 当 queueLen==0 时进行更新.
    - 避免重复搜索 (剪枝) 的关键: `!(dist[v]<dist[u]+1)` 这里的 u 是当前搜索的节点, v 是从 u 出发相连的节点. 初始化节点 dist 为 `inf := math.MaxInt32`, 则需要添加 v 的有两种情况: 1. `dist[v]==inf` 即第一次遇到 v; 2. `dist[v]=dist[u]+1` 即当前层到达 v 有多种最短路径. 而若 `dist[v]<dist[u]+1`, 则说明到达 v 有更短的路径, 跳过.
- 0131 分割字符串为回文串序列 `中` 挺难的
  - see [here](https://leetcode-cn.com/problems/palindrome-partitioning/solution/fen-ge-hui-wen-chuan-by-leetcode-solutio-6jkv/)
  - 首先想到的是 遍历 index, 然后分别对左右子串进行 DFS, 这样复杂度爆炸
  - 实际上, 只需要记录在 index 前的字符串的分割可能, 然后遍历从 index出发的所有可能的回文子串即可
    - 用一个 tmp 字符串列表记录当前的分割方式
    - 为了避免重复判断, 可以用一个矩阵 isPalindrome **记录 `s[i:j]` 是否回文**.
      - 注意这里的 DP 递归形式, `dp[i][j] = s[i]==s[j] && dp[i+1][j-1]`. 这就要求 i 从大到小, j 从小到大遍历, 考虑到可能出现 `j=1, j=i+1` 的情况, 定义 dp[i,i-1], dp[i,i-2] 为 true (或者直接定义 j<=i 时 dp[i,j]=true).
- 0212 找到棋盘 board 中所有出现在字典 words 中的单词 `难`
  - 是 `79` 题的加强, 复杂度升高了
  - 解法1: 直接遍历
  - 解法2: Trie+回溯
    - 采用前缀树 Trie 记录所有代搜索的 word, 然后从 board 每个点出发尝试匹配 Trie
    - 为了避免重复, 在 DFS 的过程中, 将搜索过的位置用 `#` 符号进行标记
- 0216 找出所有相加之和为 n 的 k 个数的组合
- 0301 去除重复的括号 `难`
  - 要求返回去除某些字符后合法的所有字符串
  - 思路0: 第一遍循环记录最少应该删除的数量 countRemoveL, countRemoveR; 然后 DFS搜索, 当出现 1. 括号不合法; 2. 删除数量多于上面两个值是结束遍历.
    - 括号合法的条件: 顺序遍历过程中, **左括号的数量应该始终 `>=` 右括号**
  - see [here](https://leetcode-cn.com/problems/remove-invalid-parentheses/solution/shan-chu-wu-xiao-de-gua-hao-by-leetcode-9w8au/)
  - 思路2 BFS: 因为是找最短的所以考虑 BFS, 为了避免重复, 可以对待检查的字符串建立 map 去重
- 0306 累加数 `中` 判断一个字符串是否可构成累加序列
  - 两次遍历开始的两个数字, 然后判断后续是否构成累加即可
- 0357 计算各个位数不同的数字个数
- 0401 二进制手表 `易` 但感觉复杂度有 `中`
  - 思路0: 采用 DFS, 遍历所有的亮灯情况
  - see [here](https://leetcode-cn.com/problems/binary-watch/solution/er-jin-zhi-shou-biao-by-leetcode-solutio-3559/)
  - 方法一：枚举时分, 直接遍历 0-11 和 0-59
    - 注意计算亮灯数可以用函数 `bits.OnesCount8(h)` 或 Python 中的 `bin(h).count("1")`
    - 另外, 字符串输出可以用 `fmt.Sprintf("%d:%02d", hour, min)`
  - 方法二：二进制枚举
    - 直接枚举 0-1023 所有的十位二进制数, 前四位和后六位分别表示时刻和分钟, 则判断条件为 `h < 12 && m < 60 && bits.OnesCount(uint(i)) == turnedOn`
- 0473 数组构成正方形 `中`
  - 方法0: 利用一个 used 标记使用的元素, 然后依次生成四条边
  - see [here](https://leetcode-cn.com/problems/matchsticks-to-square/solution/huo-chai-pin-zheng-fang-xing-by-leetcode/)
  - 方法一: 也是DFS, 不过直接用一个数组记录四条边的长度, 一次遍历数组, 尝试放在四条边, 复杂度 $4^N$
  - 方法二：动态规划 + 状态压缩. 所谓「DP」其实就是我之前的思路, 因为可以依次生成每一条边. 不过标答的解法更简洁.
- 0491 找出所有递增子序列 `中`
  - 关联 `第 78 题，第 90 题`
  - see [here](https://leetcode-cn.com/problems/increasing-subsequences/solution/di-zeng-zi-xu-lie-by-leetcode-solution/)
  - 方法二：递归枚举 + 减枝
    - 注意这里的重复逻辑: 即使是在乱序数组中, 为了防止重复, 当这时遍历的数字和之前选入的数字一样时, 不遍历即可. 也即, 这里的代码逻辑和 0090 题完全一致.
  - 方法一：二进制枚举 + 哈希
    - 遍历所有可能的子序列, 然后去重, 串哈希算法 (即 Rabin-Karp 编码, 见 1392)
- 0494 用加减号连接数组, 构成目标值的数量 `中`
  - 方法一, DFS
  - 方法二, DP, see [here](https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode-solution-o0cp/)
    - `dp[i][j]` 为前 i 个数字中选取部分, 其和为 j 的组合数量
    - 可知, 更新公式为 `dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]`, 当 `j<nums[i]` 不合法, 第二项取0.
    - 优化空间, 可以用 **滚动数组**. 则更新公式为 `dp[j] += dp[j-nums[j]]`. 注意因为用了滚动数组, 内层循环需采用倒序遍历的方式.
  - 评论区中整理了相关的「**背包问题**」
    - 01背包：`416. 分割等和子集 474. 一和零 494. 目标和 879. 盈利计划 1049. 最后一块石头的重量 II 1230. 抛掷硬币`
    - 完全背包：`1449. 数位成本和为目标值的最大数字 322. 零钱兑换 518. 零钱兑换 II 279. 完全平方数, 377. 组合总和 Ⅳ`
    - 分组背包: `1155. 掷骰子的N种方法` 每一组是一个骰子，每个骰子只能拿一个体积为1到6的物品
- 0526 组合数, 要求每个位置的数字能被 index 整除或整除 index `中`
  - 方法1: DFS 即可
  - 方法二：`状态压缩 + 动态规划`. 参见 [here](https://leetcode-cn.com/problems/beautiful-arrangement/solution/you-mei-de-pai-lie-by-leetcode-solution-vea2/)
    - 核心在于 DP, 递推公式 `dp[mask] = sum{dp[mask-2^i]}` 这里的 i 要求满足其在mask所对应的数字中并且可整除; 这里的 mask 表示仅使用部分数字时所对应的二进制数 (状态压缩)
- 0638 有一些礼包可以打折, 要求给定购买物品数量的情况下, 找到最优解 `中`
  - DFS, 数据量不大
  - 方法一: [here](https://leetcode-cn.com/problems/shopping-offers/solution/da-li-bao-by-leetcode-solution-p1ww/) **记忆化搜索**. DP 更新公式分两种情况:
    - 一是购买礼包 `dp[needs] = min{price_i + dp[needs-needs_i]}`, 其中 price_i 和 needs_i 分别是礼包的价格和成分.
    - 二是不购买, 直接通过所有物品的单价算出来; 转移公式为两者较小值
  - 因为大礼包中可能包含多个物品，所以并不是所有状态都可以得到。因此，我们使用记忆化搜索而不是完全遍历的方法，来计算出满足每个购物清单 needs 所需花费的最低价格。
- 0784 字符串 S 中的每个字母转变大小写, 所有可能 `中`
  - 方法一: DFS
  - 方法二: 先将第一个字母变大写，然后依次把后面的字母变大写。最终的解数组中答案是翻倍增长的
    - 每一步为 `ans = [""]`，依次更新 `ans = ["a", "A"]`， ans = `["ab", "Ab", "aB", "AB"]`， `ans = ["abc", "Abc", "aBc", "ABc", "abC", "AbC", "aBC", "ABC"]`。
  - [sol](https://leetcode-cn.com/problems/letter-case-permutation/solution/zi-mu-da-xiao-xie-quan-pai-lie-by-leetcode/) 中还用到了 位表达, 或 itertools, 单复杂度是一样的
- 0816 将一个去除了小数点和逗号的二维左边还原 `中`
  - 注意判断一个字符串是否可构成数字 (小数)
    - 长度为 1, 只能构成整数
    - 以0结尾, 无法构成小数
      - 若同时还以0开头(长度>1 则无法构成数字
    - 长度>1 且不已0结尾
      - 若以0开头, 只能构成 `0.xxx` 形式的小数
      - 否则可以构成小数点任意位置的小数
- 0842 划分 Fibonacci 字符串 `中`
  - 关联 0306, 也即累加数组
  - 注意这里要求数列中的元素为有符号正整数, 即 `0 <= F[i] <= 2^31 - 1`

### 09 DFS

- 0094 中序遍历一棵二叉树 `易`
- 0098 判断二叉搜索树是否合法 `中`
  - 注意需要一个节点合法, 需要满足「大于左子树上的所有节点, 小于右子树上的所有节点」
  - 递归函数形式 `isValidbst(root *TreeNode, min, max float64) bool`
  - 检查条件 `return v>min && v<max && isValidbst(root.Left, min, v) && isValidbst(root.Right, v, max)`
  - 边界(root): `isValidbst(root, math.Inf(-1), math.Inf(1))`
- 0099 **二叉搜索树**中的两个节点被错误地交换。恢复这棵树。`中`, 偏 `难`
  - see [here](https://leetcode-cn.com/problems/recover-binary-search-tree/solution/hui-fu-er-cha-sou-suo-shu-by-leetcode-solution/)
  - 解法一 中序遍历转为列表. 核心思路是, 二叉搜索树中序遍历等价于一个递增列表, 直接转化为列表后处理
    - 对于交换两个元素, 可能出现一个或两个位置不满足 `a[i]<a[i+1]`, 我们在中序遍历得到的列表中找到要交换的节点即可
    - 若交换的是相邻元素, 例如 [1,3,2,4,5,6,7], 保留指针 i, i+1即可, 若不相邻, 例如 [1,6,3,4,5,2,7], 则会有 i,j 两个元素不满足递增条件, 保留 i+1, j; 综上, 可以通过一次遍历得到要交换的两个节点
  - 解法二 上面是「显式中序遍历」, 将中序遍历的值序列保存在一个数组中, 我们也可以隐式地在中序遍历的过程就找到被错误交换的节点.
    - 思路其实是一样的, 我们只关心中序遍历的值序列中**每个相邻的位置的大小关系是否满足条件**(且错误交换后最多两个位置不满足条件). 因此在中序遍历的过程我们只需要维护**当前中序遍历到的最后一个节点**, 然后在遍历到下一个节点的时候，看两个节点的值是否满足前者小于后者即可，如果不满足说明找到了一个交换的节点，且在找到两次以后就可以终止遍历。
    - 具体实现上, 又可分为递归和用 stack 来记录两种方案. 1. 官答用了栈来记录当前节点的「右父亲列表」(注意, 对一个节点, 其中序遍历的下一个点是其右子树中最小的节点, 即不断尝试访问左儿子); 2. [halforest](https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0099.Recover-Binary-Search-Tree/) 的解答用的是递归, 更为直观
      - 注意这里的递归函数形式 `inOrderTraverse(root, prev, target1, target2 *TreeNode) (*TreeNode, *TreeNode, *TreeNode)` root 为当前节点, prev 为中序遍历的上一个节点, target1, target2 为要找的两个节点; 返回 prev, target1, target2.
  - 解法三 取消栈空间, 略
- 0100 判断两个二叉树是否完全相同
  - 深度优先即可
- 0101 判断二叉树是否对称
- 0104 二叉树的深度
  - DFS 递归
    - 当递归到 nil 时返回 0
    - 节点部位空时返回 `return max(maxDepth(root.Left), maxDepth(root.Right)) + 1`
  - BFS 用stack保存每一层的节点
- 0110 判断一棵树是不是平衡二叉树。平衡二叉树的定义是：树中每个节点都满足左右两个子树的高度差 <= 1 的这个条件 `易`
  - DFS 递归 `isBalancedHight(root *TreeNode) (bool, int)` 返回这棵子树是否平衡, 以及树高
- 0111 给定一个二叉树，找出其最小深度。最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量
  - 叶子节点是指没有子节点的节点
  - 和 104 的区别在于, 若左右孩子只有一个为空, 则应该根据另一个子树的深度计算; 只有当左右均不为空时才返回 `min(minDepth(root.Left), minDepth(root.Right)) + 1`
- 0112 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。说明: 叶子节点是指没有子节点的节点。
  - 还是注意叶子节点的判断
- 0113 找出上题中的所有路径 `中`
  - 难度倒是不大, 利用一个变量记录目前的路径, 倒是在 go 和 python 的指针传递上尝试了好久; 详见代码语法总结部分「全局变量 vs 传参」「传递 值拷贝 vs 指针」
- 0114 将二叉树展开为链表, 先序遍历
  - 解法一 递归: 对于递归函数 `flatten2(root *TreeNode)`, 分别将左右孩子完成flat, 由于是先序遍历, 所以 `root->root.left->...->root.right` 即可, 注意是左子树转化的链表最末尾连接右子树
  - 解法二 非递归 每次找到左子树的最右(也即链表最后一个元素), 然后将右子树连接上去, 参见 [here](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/)
- 0116 填充每个节点的下一个右侧节点指针 `中`
  - 给二叉树同层之间的节点建立 Next 指针
  - 解法一 迭代。其实也是比较直观的想法：利用上一层已经有的 Next 构成的链表来传递；减少了下面的递归栈。
  - 解法二，递归。递归函数 `connectTwoNodes(n1, n2 *Node)` 是同层的相邻两个节点，在函数中要求连接 1. node1, node2 其左右孩子；2. `node1.Left.Next=node2.Right`
- 0124 二叉树中任意一条路径的最大和 `难`
  - 乍一看有点复杂，分析：
    - 首先需要记录从当前节点出发向下的最大路径和 `currMax := max(root.Val+left, root.Val+right, root.Val)`
    - 然后是经过盖点的最大路径和 `max(currMax, left+right+root.Val)`
  - 具体的实现上，自己用了两次DFS，其中第一次更新 `map[*TreeNode]int{}` 记录 currMax
    - 而 [here](https://books.halfrost.com/leetcode/ChapterFour/0100~0199/0124.Binary-Tree-Maximum-Path-Sum/) 中，直接将 currMax 作为递归函数返回值来传递，更为简洁。

### 11 binary search 二分查找

- 0004 寻找两个有序数组的中位数 `难`
  - 简单起见, 合并更方便
  - 二分搜索, 参见 [here](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)
  - 这里go的实现, 通过维护数组的分界点来找, 思路也很清晰
- 0033 搜索旋转排序数组 `中`, 没有重复, 返回索引值
  - 可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 `[l, mid]` 和 `[mid + 1, r]` 哪个部分是有序的
  - 如果 `[l, mid - 1]` 是有序数组 (即 `nums[mid]>=nums[0]`)，且 target 的大小满足 `[nums[l],nums[mid])`，则我们应该将搜索范围缩小至 `[l, mid - 1]`，否则在 `[mid + 1, r]` 中寻找。
  - 反之, 若 `nums[mid]<=nums[-1]`, 则可直接根据 target 是否在 `(nums[mid], nums[r]]` 判断是否在右半部分, 否则在另一边搜索
- 0034 找出给定目标值在排序数组中的开始位置和结束位置
  - 基本变体: 找第一个/最后一个等于 target 的元素
- 0035 查找有序数组插入位置 `中`
  - 经典变体, 即「在有序数组中找到最后一个比 target 小的元素」
- 0069 实现 sqrt
  - 解法二 `牛顿法`, 即求 `f(x)=x^2-n` 的零点
  - 更 fancy 的还可以更快
- 0074 搜索二维有序数组 `中`
  - 基本的二分搜索
- 0081 搜索旋转排序数组Ⅱ, 和33题相比多个可重复
  - 其实仅仅多了一种情况: 当 `nums[mid] == nums[l] && nums[mid]==nums[r]` 时无法判断哪一部分是有序的, 因此只能 `l++; r--`
- 0153 搜索旋转排序数组 中的最小值(旋转点) `中`
  - 由于旋转数组也可以是正常升序数组, 因此判断条件应该是和 high 比较而不能只和 low 比较
  - 解法一 其实也可以用基本的二分范式 `l<=r`, 判断条件复杂一点
  - 解法二 这类题目也可以用 `low < high` 作为终止条件, 相较于基本范式, 这里 high 和 low 的是不对等的. high 只是用来缩减搜索范围, 而 low为输出结果的指针
- 0154 相较于 153 增加了可重复条件 `难`
  - 如果还是用基本范式, 判断条件会更复杂一点; 但用双指针逼近的思路会更清楚
- 0162 找到数组中的「**山峰**」 `中`
  - 算是二分的经典变体, 和 153 一样用 high low 进行判断会比较简单; 基于 `nums[mid+1] >= nums[mid]` 进行更新
- 0167 找到两数之和为目标值的index
  - 和第 1 题一样, 不过时排好序的, 可以用双指针逼近, 从而免去了map空间
- 0209 长度最小的子数组 `中`
  - 正数数组, 找到 >=target 的连续子数组的最小长度.
  - 解法一 先计算 cumsum, 然而对于每一个子数组开始位置, 可以用二分搜索找到最小长度, 时间 O(nlogn), O(n)
  - 解法二 「**滑动窗口**」在滑动窗口 [i,j]之间不断往后移动，如果总和小于 s，就扩大右边界 j，不断加入右边的值，直到 sum > s，之和再缩小 i 的左边界，不断缩小直到 sum < s，这时候右边界又可以往右移动。以此类推。 O(n), O(1)

总结了二分查找的注意点:

- 循环退出条件，注意是 low <= high，而不是 low < high。
- mid 的取值，mid := low + (high-low)»1
- low 和 high 的更新。low = mid + 1，high = mid - 1。

四个基本的变种

- 二分查找第一个与 target 相等的元素，时间复杂度 O(logn)
- 二分查找最后一个与 target 相等的元素，时间复杂度 O(logn)
- 二分查找第一个大于等于 target 的元素，时间复杂度 O(logn)
- 二分查找最后一个小于等于 target 的元素，时间复杂度 O(logn)

另外一类常见的: 基本有序数组. 在山峰数组中找山峰，在旋转有序数组中找分界点。第 33 题，第 81 题，第 153 题，第 154 题，第 162 题，第 852 题

### 12 math

- 0002 两数相加, 形式为逆序链表. `中`
  - 定义了基本的 `ListNode` 结构, 并定义 `List2Ints, IntsList` 实现数组和链表的方便转换.
- 0007 反转32位整数 `中`
  - 这题主要的限制是在要防止 32位 sign int 溢出, 讨巧的思路可以用更长的整数类型/字符串来保存. 「标准」思路应该是每次 `*10` 之前进行检查 (或者说, 和 `math.MinInt32/10` 进行比较) 防止溢出.
- 0009 Palindrome 回文数
  - 同样可以采用 1. 反转数字; 2. 转为数组; 3. 转为字符串等方式.
  - 直接反转可能溢出 (虽然此时必然不是回文数); 思路是「反转整数长度的一半」(即循环条件 `x>rev`), 最后的判断条件: 若 x 为回文数且长度为偶数, 则 `x==rev`; 若为奇数, 则 `x==rev/10`
- 0012, 0013 罗马数字转阿拉伯数字
  - 就是所使用的基数不用, 累计即可
- 0060 Permutation-Sequence 找出以一定的数字作为元素的排列中的第 k 个 `难`
  - 思路一 也即官方的 [缩小问题规模](https://leetcode-cn.com/problems/permutation-sequence/solution/di-kge-pai-lie-by-leetcode-solution/); 其实也可理解为贪婪剪枝的 DFS?
    - 使用 go 来实现的时候没有 Python 中好用的 `math.perm` 函数, 方便的类型转换等. 解答中用到的一些技巧值得学习. 例如, 1. 构造了 factorial 来实现 Python 中的 math.perm; 2. 用 valid 数组标记还没有用过的数字
    - 重点还是要明确公式: `a_i=(k-1)mod(n-1)!+1`
  - 反过来的问题: 对于给定的排列确定其为顺序第几个?
    - 公式 `k=sum(order_i*(n-1)!)+1`, 其中的 order_i 是在 序列 `a_i+1...a_n` 中小于 a_i 的元素数量
- 0029 整除 `中`
  - 思路一 类似二分查找, 每次将除数 `*2` 找到小于等于被除数的最大的那一个, 迭代终止条件是 `dividend<divisor`, 即不断减去除数的倍数之后, 剩余的部分小于除数
  - 思路二 `倍增法` 实际上在除数递增的过程中即可将被除数相减, 当增大到接近被除数之后再不断 `/2`, 终止条件是因子 `cnt==0`, 也即 `dividend<divisor`

## 周赛笔记

### 268

- 2078. 两栋颜色不同且距离最远的房子
- 2079. 给植物浇水
  - 模拟法
- 2080. 区间内查询数字的频率 `中`
  - 需求是查询子数组 arr[left...right] 中 value 的 频率; 考虑到查询数量可能较大, 因此设计一个数据结构存储数据分布信息
  - 解法: 用 map 保存数字所出现的位置列表, 从而查询时候可以用**二分查找**.
    - Python 可以直接用 `bisect.bisect` 好方便!
- 2081. k 镜像数字的和 `难`
  - 找到前 n 个, 在 10进制 和k进制下均为回文数的数字, 返回其最大值
  - 注意题目要求, 2 <= k <= 9, 1 <= n <= 30 当k和n均取较大值时会超时(约10**10量级); 因此重点是如何所见搜索空间.
    - 由于是回文数, 因此只需遍历前半部分即可, 注意可生成奇数或偶数长度的, 例如 1234 -> 1234321 或 12344321;
    - 另外, 每次遍历 [1,9], [10,99]... 的数字, 对于j位十进制数, 可分别生成 2j-1, 2j 位十进制数

### 269

- 2089. 找出数组排序后的目标下标
- 2090. 半径为 k 的子数组平均值
- 2091. 从数组中移除最大值和最小值
  - 滑动平均
- 2092. 找出知晓秘密的所有专家 `难`
  - 包括 (x, y, time) 的三元组, 若 x 和 y 中某一个知道了「秘密」, 则会进行传播; 要求最后知道「秘密」的所有人
  - 解法一: **构建图**, 传播
    - 按照时间排序, 难点在于判断同一时间的多人传播关系 —— 简单的方案是构建图
    - 解法的具体实现: 利用 edges 字典记录连接关系, 建立图后, 利用 一个 `deque` 记录所有激活节点, 迭代直至队列空
  - 解法二: **并查集**

### 270

- 2094. 找出 3 位偶数
  - 给你一个整数数组, 找出所有的三位偶数(也即要求首位不为 0), 顺序输出(直接排序即可)
  - 简单题 (也可根据提示的范围知道不复杂) 别想太多, 直接暴力遍历即可; 为了避免重复可以用 set()
- 2095. 删除链表的中间节点 `中`
  - 长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始）
  - 解法一: 快慢指针即可, 可以在最开始加上一个「哨兵」
- 2096. 从二叉树一个节点到另一个节点每一步的方向 `中`
  - 找到二叉树两个节点之间的路径
  - 解法一: 直接 DFS 找到两个点从 root 出发的路径, 除去公共路径即可
- 2097. 合法重新排列数对 `难`
  - 给定 pairs(表示区间), 重新排列要求排列后每个区间首尾数字相同; 核心在于理解「[欧拉通路](https://oi-wiki.org/graph/euler/)」, 将问题转换
  - `Hierholzer 算法`: 首先很容易想到, 若仅为「**半欧拉图**」(即存在两个奇数度数节点), 可以确定开始和结束的数字, 否则为「欧拉图」随便选择初始数字/节点即可.
    - 若随便选择一条边, 则可能走到「死路」, 注意此时剩下的图构成了一个「欧拉图」 —— 可以用DFS探索
    - 因此, 1. 每次选择一条边, 在图上删去这条边; 2. 递归; 3. 记录这条边. 注意这里的边是在遍历之后加入记录的 (也即是逆序的, 最后要再逆序输出), 这样可以保证可能漏过的「欧拉图」在此之前被遍历.
  - 参见 「332. 重新安排行程」「753. 破解保险箱」
  - 332 重新安排行程, `难`
    - 区别在于, 需要返回所有的通路中, 字母排序最小的那一个 —— 也即, 每次应该选择较小的那一个节点
    - [solution](https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/) 非常清楚
  - 753. 破解保险箱, `难`
    - 密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。要求返回一个最短字符串, 其子字符串包括所有可能的密码.
    - 关键在于将其转化为一个规范的欧拉通路问题: see [here](https://leetcode-cn.com/problems/cracking-the-safe/solution/po-jie-bao-xian-xiang-by-leetcode-solution/) 官方解答有点fancy
    - 解法: 转换为**欧拉通路问题**
      - 简言之, 要求的是 n 长序列, 都可将其看成 n-1长序列加上 0~k-1 的数字. 因此, 可以构建一个图, 节点为所有的 n-1长序列, 其第i个出边就是在最后加上数字i并去除第一位数字, 跳到相应的节点上.
      - 例如, 节点u的第v的出边就跳转到数值为 u*k % (k**(n-1)) + v 的节点上.
      - 可知, 这样构造的图, 每个节点都有 k条出边和入边, 共可代表 $k^{n-1} * k$ 个不同的数字, 正好对应了所有可能的密码.
      - 显然, 这张图是欧拉图, 并且可基于一个欧拉回路对应一个题目所要求的字符串.

### 271

- 2105. 给植物浇水 II
  - 模拟法即可
- 2106. 摘水果 `难`
  - 在一个无限的 x 坐标轴上, 分布一定的水果, 给定 startPos 和可以移动的步数 k, 计算可以拿到的最大数量
  - 题型: 其实就是给定一个累加和, 探索所有可能的范围内的最大值; 问题在于如何在离散存储的数组中找到对应的元素
    - 存储方式: 例如对 `[[2,8],[6,3],[8,6]]` 水果分布而言, 记录位置 `pos=[-Inf, 2,6,8]` 和 累计和 `[0,8,11,17]`
    - **二分查找**. 要注意 **边界情况**, 左边应该是 `bisect.bisect_left`, 而右边是 `bisect.bisect_right`, 注意函数返回的是待插入的 index, 因此最终能采集的水果数量为 `cumsum[rindex-1] - cumsum[lindex-1]`
    - 错误记录: 注意, 先往左边走和先往右边走所能达到的范围是不一样的! 因此两侧的情况都应该考虑到.

### 272

- 2110. 股票平滑下跌阶段的数目
  - 一次遍历即可
- 2111. 使数组 K 递增的最少操作次数 `难`
  - 如果对于每个满足 `k <= i <= n-1` 的下标 i ，都有 `arr[i-k] <= arr[i]` ，那么我们称 arr 是 K 递增 的。
  - 给定一个数组和 k,要求找到使得这个数组 k递增的最小修改次数.
  - 问题可转化为: 寻找一个数组中的最长递增序列, 参见 300 题 [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/)
    - 思路 1: DP, 定义 `dp[i]` 为 第 i 个数字结尾的最长上升子序列的长度, 注意 第 i 个元素必须被选中; 递推公式 `dp[i] = max(dp[j]) + 1`, 其中的 j 要求 `nums[j]<=nums[i]`
      - 时间复杂度 $O(n^2)$
    - 方法二：贪心 + 二分查找
      - 维护一个数组 `d[i]` ，表示**长度为 i 的最长上升子序列的末尾元素的最小值**, 用 len 记录目前最长上升子序列的长度. 注意到数组 d 是单调递增的
      - 我们依次遍历数组 nums 中的每个元素，并更新数组 d 和 len 的值。如果 `nums[i]>d[len]` 则更新 `len = len + 1`，否则在 `d[1…len]`中找满足 `d[i−1]<nums[j]<d[i]` 的下标 i，并更新 `d[i]=nums[j]`。
      - 由于是递增数列, 可以用二分搜索
      - 时间复杂度 $O(n log(n))$

### 273

- 2120. 执行所有后缀指令
  - 模拟机器人动作即可
- 2121. 相同元素的间隔之和 `中`
  - 给定一个数组, 计算其中相同元素所在的 index 之差, 返回所有这些距离的和
  - 用一个 defaultdict(list) 记录各个元素出现的位置.
  - 问题转化为对于一个数字出现的位置, 计算各个位置的 dist 和.
    - 注意数据量, 直接暴力遍历复杂度为 $O(n^2)$ 会超时
    - 思路1: 观察相邻两个元素相差的(子距离数量), 可得递推公式 `dp[i+1] = dp[i] -(n-2i-2) * (arr[i-1]-arr[i])`
    - 思路2: 计算 cumsum, 则 i 处的距离和为 `(cumsum[-1]-cumsum[i] - arr[i]*(n-1-i)) + (cumsum[i]-cumsum[0] - arr[0]*i)`
- 2122. 还原原数组 `难`
  - 就是对于一个数组 arr, 用一个正整数 k, 分别生成两个数组, `lower[i] = arr[i] - k, higher[i] = arr[i] + k`. 要求给定这两个数组的混合, 还原 arr
  - 注意看约束条件, 数组大小最多为 `1000` 所以暴力搜索即可, 题目只是比较繁琐
    - sort, 得到可能的 k
    - 用 `indexRecord` 记录每个数字对应的位置
    - 关键在判断一个 k 是否满足条件. 这里用了一个 `used` 记录每个所对应的元素所在位置, 遍历 nums 后, 若 `sum(used) == n` 则说明 k 满足条件
  - see [here](https://leetcode-cn.com/problems/recover-the-original-array/solution/huan-yuan-yuan-shu-zu-by-leetcode-soluti-nizi/)

### 274

- 5970. 参加会议的最多员工数 `难`
  - 每个人只有一个喜欢的人, 要求安排坐圆桌, 每个人左右要有他喜欢的人, 最大的可安排人数
  - 比较容易想到, 问题主要转化为求这样的有向图上的最大环,
    - 特殊情况是两个互相喜欢的人, 他们相互满足了要求, 因此左右可以有一条「喜欢人的链」, 并且左右的人都是满足的; 因此, 这种大小为 2 的环一个桌上可以安排多个
    - 参见 [这个题解](https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/solution/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/), 这种图叫做 **内向基环树 (pseudotree)**
  - 所以核心问题在于如何在 pseudotree 中找环, 比赛中的尝试没有想到如何「**剪枝**」超时了; 实际上, 可以通过一次 **拓扑排序** 剪掉所有的分支 (最后留在图上的点的度数最大为 1)
    - 具体实现上, 维护一个入度为 0 的队列, 对其喜欢的人的入度 -1, 如果减到了 0 则继续加入队列;
    - 这样, **拓扑排序后最终剩下的点都是成环的**(入度为 1).

### 275

- 5976. 检查是否每一行每一列都包含全部整数
- 5977. 最少交换次数来组合所有的 1 II
  - 滑动平均
- 5978. 统计追加字母可以获得的单词数
  - 注意审题
- 5979. 全部开花的最早一天
  - 两个数组, 分别是 播种 和 开花 所需的时间, 要求使得所有花都开放的最小时间
  - 题目给了干扰: 将一种花分成两次播种没有意义, 因为两者总的播种时间是一样的, 因此在过程中两种花都不会提早开花.
  - 于是可以化简为, 给依次播种的花进行排序
  - 可知, 总的播种时间是一定的, 目标在于减少开花所需时间. 因此每次根据开花所需时间排序, 选择需要最长时间的那种即可.

### 276

- 5980. 将字符串拆分为若干长度为 k 的组
- 5194. 得到目标值的最少行动次数
  - 给定一个目标数, 从 1 开始 +1, *2 两种操作, 限定了倍乘的次数 maxDoubles
  - 贪心, 从 target 往下 /2
- 5982. 解决智力问题
  - 给定一系列的题目, questions[i] = [pointsi, brainpoweri], 你选择做某一题的代价是只能跳过后面 brainpower 题
  - DP, 从后往前, 记录从该位置往后的最大解, 递推公式 `dp[i] = max([dp[i+1], point+dp[i+skip+1]])`
- 5983. 同时运行 N 台电脑的最长时间
  - 给定一组电池 batteries, 每个电池可以给一台电脑运行一定的时间. 可以把一个电池替换给不同的电脑, 要求让所有电脑同时运行的最长时间
  - 这里的限制条件为电量最大的 n 个电池, 小的电池看作对它们的补充.
  - 注意到: 一个电池的电量可以以**任意的比例**分到若干块电池上.
  - 因此, 可以将最大的 n 个电池看成一个「阶梯」, 其余的小电池理解为在这个池子里注水, 求高度

### D68

- 2114. 句子中的最多单词数
- 2115. 从给定原材料中找到所有可以做出的菜
  - 给定一个菜单, 每道菜的成分可能包括食材或其他的菜品, 要求在一定的初始食材下能够得到的所有菜品
  - 思路一: 本题数据量比较小, 可以暴力遍历. 用一个 flag 记录一次遍历是否有新的菜品(食材) 生成, 当没有时即结束
  - 思路二: 依赖关系构成图, 显然可以用 `拓扑排序` 解决, see [here](https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/solution/cong-gei-ding-yuan-cai-liao-zhong-zhao-d-d02i/)
- 2116. 判断一个括号字符串是否有效 `中`
  - 给定一个在某些位上固定的字符串 (例如 `s = "))()))", locked = "010100"`), 判断能够通过修改其他自由位使其成为合法的括号序列
  - 思路一: 关注 lock 部分 (剩下偶数个自由位一定可以匹配)
    - 先尝试匹配 lock 部分的字符串, 记录未成功匹配的位置 (三种情况, 最后剩下 `((`, `))` or `))((`; 和 空白符号的位置;
    - 利用 space 字符串来匹配剩下的左右括号 leftStack, rightStack
    - 原本分了上面三种情况讨论, 实际上可以合并: 用 space 最前面的部分匹配右括号, 最后面的部分匹配左括号, `len(spaces)>=len(leftStack)+len(rightStack) and all([i>j for i,j in zip(spaces[-len(leftStack):], leftStack)]) and all([i<j for i,j in zip(spaces[:len(rightStack)], rightStack)])`
  - 方法一：数学, see [here](https://leetcode-cn.com/problems/check-if-a-parentheses-string-can-be-valid/solution/pan-duan-yi-ge-gua-hao-zi-fu-chuan-shi-f-0s47/)
    - 定义了有效字符串「分数」的概念, 然后通过: 维护 1. 前缀 s[0..i] 可以达到的最大分数；2. 前缀 s[0..i] 「可以达到的最小分数」及「作为有效前缀所需的最小分数」两者的较大值. 这两个数组来进行判断.
- 2117. 一个区间内所有数乘积的缩写 `难`
  - 放弃了
  - 参见 [思路详解+详细讨论一下精度问题](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/fen-bie-ji-suan-qian-5wei-he-hou-5wei-si-dc9x/), Python 超时了. 另外 [here](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/yi-ge-shu-ju-tuan-mie-jue-da-bu-fen-dai-234yd/) 做了更多的分析

## 每日一题

- 0219 存在重复元素 II
  - 一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k
- 2029. 石子游戏 IX `中` 但实际上可以说很难!
  - 分别取石子, A优先, 两条规则
    - 当某个人取出后总和为 3的倍数时, 其失败;
    - 当取完所有的石子, 条件1不成立, 则 A 失败(不管最后一个是谁取的).
  - 博弈, 参见 [官方解答](https://leetcode-cn.com/problems/stone-game-ix/solution/shi-zi-you-xi-ix-by-leetcode-solution-kk5f/).
  - 首先的失败条件是取出的石子总和为 3, 因此可将石子除以3的余数为 0,1,2 分成三类
  - 先不考虑 0, 假设只有 1,2. 由于每个人都是最佳决策, 因此只会出现
    - `1,1,2,1,2,1,...` 或者 `2,2,1,2,1,2,...` 的序列. 也即除了第一颗, 两个都回去相同的石子.
    - 条件 1 的失败条件为对方没有可取的石子, 因此 A 的策略是取数量少的那一类.
      - 以 `1,1,2,1,2,1,...` 序列为例, A 获胜条件为: 有类型 1 的石子并且数量少于类型 2, `0 < cn1 <= cn2`
    - 综合两种情况, A 获胜条件为 `cnt1 >= 1 and cnt2 >= 1`
  - 还要考虑 1, 当 0 的数量为偶数时, 条件不改变. 考虑 0 有奇数个
    - A 的策略仍然是选择较少的类, 然而此时 B 可以有一次选类型 0 石子的机会, 因此条件变为
      - `cnt1 - cnt2 > 2 or cnt2 - cnt1 > 2`
- 1345. 跳跃游戏 IV `难`
  - 给一个数组, 只能前后一格, 或者跳到相同数字的格子上, 求到达终点的最小跳数
  - 显然可以建模为最短路径问题;
  - 然而直接建图 BFS 超时了. 问题在于, 当存在大量点的数字相同, 变为稠密图, BFS 复杂度为 `O(n^2)`
  - 方法一：广度优先搜索 see [here](https://leetcode-cn.com/problems/jump-game-iv/solution/tiao-yue-you-xi-iv-by-leetcode-solution-zsix/)
    - 考虑这一问题的特殊性: 所有相同元素构成稠密图, 因此没有必要遍历改子图上所有的边 —— 递归一遍这些节点后, 没有必要在这一稠密图上搜索了
    - 因此, 直接不构建这一部分的图
    - 具体而言, 不构建显式的图, 直接记录每个数值包括的位置集合 val2index. 当从一个点 index 出发遍历了所有 val2index[arr[index]] 中的节点后, 直接 `del val2index[arr[index]]` 从而避免构建这一稠密图
- 1332. 删除回文子序列 `易`
  - 给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。求删除次数
  - 注意审题，只包含两个字母，并且删除的 **回文子序列**，因此最多是两次
- 2034. 股票价格波动 `中`
  - 股票数据可能会更新，以后到的为准，要求实现：1. 更新；2. 返回最近时间的价格；3. 找到最高/最低价格
  - 核心在于：之前记录的价格可能是错的，**如何在这种状态下维护最大值**
  - 方法一：哈希表 + **有序集合**
    - 用 map 存储每个时间对应的价格；有序列表存储所有的价格（要求最大最小直接返回列表的首尾元素即可） `from sortedcontainers import SortedList`
  - 方法二：哈希表 + 两个 **优先队列**
    - 用两个优先队列分别存储最大和最小值， (price,timestamp)；在返回时，将存储的 price 和 map 中对应时刻的价格比较，若不一致则说明过期了
- 2045. 到达目的地的第二短时间 `难`
  - 给定一张图，求从 1 到 n 的第二短路径；在这些节点上定义了红绿灯，每条边的开销是一样的，当到达节点时，次节点是红灯状态下无法离开，需要等待到下一次绿灯；所有节点的红绿灯变化是一样的，求第二短时间。
  - 方法一：广度优先搜索
    - see [here](https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/solution/dao-da-mu-de-di-de-di-er-duan-shi-jian-b-05i0/)
    - 第一步，计算次短路径。直接暴力 BFS 会超时，注意到 **仅需要记录一个节点的最短和次短路径**，因此可以剪枝
    - 第二步，计算时间。迭代的方式求解，当 `time_j % (change*2) >= change` (红灯状态) 时需要等待 `change*2 - time_j % (change*2)`
- 2013. 检测正方形 `中`
  - 实现一个类，实现 count：输入一个坐标，返回这个点和已有的点能够组成正方形（平行坐标轴的）的数量
  - 注意审题，因为是正方形所以遍历的复杂度不是很高，所以逻辑实现在 count 函数中即可
  - 用一个 `map{x:[ys]}` 记录每一行出现过的列（或者 [官答](https://leetcode-cn.com/problems/detect-squares/solution/jian-ce-zheng-fang-xing-by-leetcode-solu-vwzs/) 中直接 `map{[x][y]:count}` 记录每一个点出现的次数，数据结构 `defaultdict(Counter)`）遍历所有可能的正方形即可
- 2047. 句子中的有效单词数 `易`
  - 根据空格分隔单词，一个正确的词要求：1. 不包含数字；至多一个连字符，其前后必须是字母；2. 至多一个标点符号（'!'、'.' 和 ','），必须在结尾
  - 作为一道简单题还是挺烦的 [here](https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/solution/ju-zi-zhong-de-you-xiao-dan-ci-shu-by-le-hvow/) 用了一次遍历；自己实现的时候调用了 count 相对会慢一点？测下来差不多
- 1996. 游戏中弱角色的数量 `中` 大概是比较经典的双排序场景
  - 定义“弱角色”：包括攻击和防御两个属性，两个指标都严格小于另一个角色的角色，返回一组人物中弱角色的数量。参见 [here](https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/solution/you-xi-zhong-ruo-jiao-se-de-shu-liang-by-3d2g/)
  - 方法一：排序
    - 可以按照攻击从大到小排序；题目中要求两个属性严格小于才成立，如何保证当 maxY>y 时，所对应的 maxX 是严格大于当前的 x？一种方式当然可以对 x 分组记录之前分组的 maxX，另一种方法是设定第二排序指标为 防御值Y 从小到大排序，这样遍历的时候仅需记录 maxY 即可。
    - 也即 `properties.sort(key=lambda x: (-x[0], x[1]))`
  - 方法二：单调栈
    - 思路其实差不多，而且也要双指标排序；不过用了递增栈逻辑上清楚一点。
