
- LeetCode Cookbook <https://books.halfrost.com/leetcode/>
- 代码随想录 <https://github.com/youngyangyang04/leetcode-master>
- Labuladong <https://labuladong.github.io/algo/>; Github <https://github.com/labuladong/fucking-algorithm>
- 宫水三叶 <https://github.com/SharingSource/LogicStack-LeetCode> Index 中对于题型进行了总结

- 编程语言
  - JAVA 廖雪峰课程 <https://www.liaoxuefeng.com/wiki/1252599548343744>
  - Python 库 LearnKu <https://learnku.com/docs/pymotw>

## 代码语法总结

### Stducture 数据结构

- 208. 实现 Trie (前缀树)

### 类型转换

```go
directions := [][]int{
  {-1,0},
  {1,0},
  {0,-1},
  {0,1},
}
[][]byte{
  {'A','B','C','E'},
  {'S','F','C','S'},
  {'A','D','E','E'},
}
```

### 传递 值拷贝 vs 指针

典型的问题是遍历二叉树, 例如 113题(找到二叉树路径和为目标值的所有路径), 需要维护一个历史的path.

- go中将slice作为参数传递/赋值(Python中将list作为参数传递也类似), 传递的还是类似指针的类型; 因此相较于值拷贝, 内存开销会小一点.
- 因此, 在对于这个类型进行修改的时候, 需要注意对于外层变量的影响

#### go语言中的slice 传递 & 复制

- go中的slice本质上还是包括了len, cap 属性的一个指针, 可表示为 `[3/5]0xc42003df10`, 传递给函数是浅复制(**仍然指向源slice的底层数组**), 若在函数内进行了修改
  - 若函数内部对slice进行扩容，扩容时生成了一个新的底层数组, 两个 slice 的内存指向就不同了, 不会影响外层slice
  - 若没有进行扩容, 修改了底层数组, 则外层同样引用这一底层数组的slice会被改变
- **复制** slice
  - 可以使用 cope 函数, `copy(s2, s1)` 将s1复制到s2, 若s1较长会被截断, 较短则复制s1那部分(s2后面的部分不变, len也不变); 函数返回成功复制的数量
  - 或者是字面量 `append([]int{}, s1...)`

### 全局变量 vs 传参

参见 113 题(找到二叉树路径和为目标值的所有路径).

- 对于 `pathSum(root *TreeNode, targetSum int) [][]int` 这样的问题
  - **传参**, 递归函数 `pathSumRec(node *TreeNode, sum int, paths *[][]int, tmp []int)`; 这里用了指针 `paths [][]int{}`, 因为初始化的 `[][]int{}` 类型长度为0, 若在函数内部进行 append, 会因为进行了扩容而开辟一个新的内存, 从而无法修改到外层的 slice
  - **全局变量+内部函数**, 在函数内部定义 `var dfs func(root *TreeNode, target int)`, 从而直接修改全局变量, 从而避免了外部定义一个函数, 需要考虑的传参问题

之所以会有这样的困扰, 因为之前没看过 go 的内部函数语法; 从实际应用上来看, 「全局变量+内部函数」的方式无疑更简单和优雅.

## 分类小结

总结一下每道题的思路:

### 07 DP

- 0005 最长回文子字符串, `中`
  - 解法四 `DP`, 时间复杂度 O(n^2), 空间复杂度 O(n^2). 弃之
  - 解法三 `中心扩散` 法, 时间复杂度 O(n^2), 空间复杂度 O(1)
  - 解法二 `滑动窗口`, 时间复杂度 O(n^2), 空间复杂度 O(1)
  - 解法一 Manacher's algorithm, 时间复杂度 O(n), 空间复杂度 O(n) `难`
- 0022 生成所有指定长度的括号对, `中`
  - 解法一 DFS, O(2^n), O(n)
  - `模拟`: 根据记录的数量模拟每一步合法的括号
- 0032 最长合法的括号序列 `难`
  - 注意需要记录的其实是「上一个没有被匹配的右括号的下标」
  - 解法一 `栈`, 这里初始化栈底为 -1 并在扫描过程中保证栈不为空, O(n), O(n)
  - 解法二 `双指针` O(n), O(1), 算是对栈方法提升了空间消耗 —— 注意每次需要记录的实际上只有「上一个没有被匹配的右括号的下标」, 因此只需要再配合两个计数器分别记录左右括号出现的数量, 从而判断当前序列是否合法即可; 注意到会忽略 `(()` 这样的终止条件,因此还要从右往左扫描一遍.
- 0042 接雨水 `难`
  - 本题是想求针对每个 i，找到它左边最大值 leftMax，右边的最大值 rightMax，然后 `min(leftMax，rightMax)` 为能够接到水的高度
  - 解法一 `扫描`, O(n), O(n), 两次遍历分别记录每个 index 的左右最大值;
  - 解法二 `双指针`, O(n), O(1), 若用双指针一次遍历, 这里维护「全局」的左右最大值 `maxLeft, maxRight`, 需要对于每个 index(遍历的左右指针) 都是合理的, 这里通过控制左右指针的移动 (每次移动较高的那一个) 来更新左右最大值.
- 0045 跳跃游戏 `中`
  - 解法一: `贪心/模拟`, O(n), O(1). 注意到, 由于可选择当前位置条约的步数, 因此**可达的最远位置之前的所有格子一定也可达**, 因此可考虑贪心. 扫描步数数组, 维护当前能够到达最大下标的位置, 记为能到达的最远边界, 如果扫描过程中到达了最远边界, 更新边界并将跳跃次数 + 1.
- 0053 最大子数组和 `易`, 但个人觉得算 `中`
  - 解法一 `DP`, O(n), O(n), 设计 `dp[i]` 是所有以 i 结尾的区间和的最大值, 状态转移方程是 `dp[i] = nums[i] + dp[i-1] (dp[i-1] > 0), dp[i] = nums[i] (dp[i-1] ≤ 0)`.
  - 解法二 `模拟`, O(n), O(1), 注意到这里实际用到的只是 dp[i-1] —— 事实上可以改写转移方程 `dp[i] = max{dp[i-1], 0} + nums[i]`, 迭代过程中维护这个数字即可
- 0055 跳跃游戏, 判断是否可达 `易`
  - 关联 45, 顺序扫描即可, 记录可达的最远距离, 若扫描位置超过该 maxRight 则说明不可达
- 0062 矩形到达另一个叫的路径数量, 杨辉三角
- 0063 增加 obstacle
- 0064 矩形每个坐标有对应数字, 求最小路径 `易` 以上几题都是基本的 DP; 需要注意的是可能可以用节省内存 (但面试/做题时候应该不用考虑). 另外注意64题可以直接在输入矩阵上计算.
- 0070 爬楼梯, O(n)
  - 每次一步或两步, 问爬n阶楼梯有几种方式, 递推公式 `dp[i]=dp[i-1]+dp[i-2]` —— 正是斐波那契数列
  - 也可以用 `滚动数组` 节省空间; 公式 `f,g = g, f+g`
- 0091 对字母用数字 1-26 编码, 问给定一个数字字符串的解码数量
  - 需要特殊考虑的是0, 要注意 "06" 是不合法的.
  - DP递推公式: `dp[i] += dp[i-1]` (当 1 ≤ s[i-1 : i] ≤ 9)；`dp[i] += dp[i-2]` (当 10 ≤ s[i-2 : i] ≤ 26)
  - 这题和上面的都可以考虑 `哨兵` 的思想, 避免起始的边界情况
- 0095 给定一个数字生成所有的元素为1-n的 BST’s (binary search trees) `中` 但个人觉得挺难的 `structure`
  - 回溯: 遍历 start~end 作为根, 递归生成左右子树
  - 这里函数定义是 `func generateTrees(n int) []*TreeNode`, 只需要返回node指针即可.
  - 思路其实比较简单: 注意到对于**二叉搜索树**, 一个节点左边的数均小于该节点; 此题场景下, 递归 `func generateBSTrees(start, end int) []*TreeNode` 即可;
  - 要注意终止条件, 这里可以设置为 `start>end`
- 0096 求上面二叉树的数量
  - 不同的二叉搜索树 II `中` 返回由 1~n 构成的所有 BST
  - 在上一题思路下就很简单了: 递推公式 `dp[i] = dp[0] * dp[n-1] + dp[1] * dp[n-2] + …… + dp[n-1] * dp[0]`
- 0097 交错字符串 `中`
  - 两个字符串能否在不改变顺序的情况下, 拼接组成第目标字符串; 递推公式 `dp[i][j] = dp[i-1][j]&&s1[i-1]==s3[i+j-1] || dp[i][j-1]&&s2[j-1]==s3[i+j-1]`
  - 注意到第 i 行仅依赖于 第 i-1 行, 因此可以 `滚动数组` 优化空间
- 0115 不同子序列 `难`
  - 给定两个字符串, 计算字符串 s 中的子序列构成 t 的数量
  - 递推公式: 若 s[i]==t[j], 根据是否匹配这两个字符, 加和两种情况 `dp[i,j] = dp[i-1,j-1] + dp[i-1,j]`; 否则只有第二项
- 0118 Pascal 三角
- 0119 Pascal 三角 Ⅱ `易`
  - 返回杨辉三角的第 i 行
  - 一种方式是直接按照构造方式按行生成
  - 方法二：线性递推 根据组合数公式 $C_n^m = \frac{n!}{m!(n-m)!}$ , 可知相邻两个元素关系为 $C_n^m = C_n^{m-1} \times \frac{n-m+1}{m}$, 从而将时间复杂度降到 O(i)
- 0121 买卖股票的最佳时机
  - 只有一次交易机会
  - 维护一个 minNow, 遍历的时候更新当前为止的最小值
- 0122 买卖股票的最佳时机 II
  - 不限买卖次数
- 0152 一个数组中累计乘积最大的连续子序列 `中`
  - 考虑到正负的问题, 主要是可能出现 0
  - DP思路, 需要维护两个状态: 以当前结尾的 maxNow 和 minNow
    - 需要考虑正负的情况, 更新公式 `maxNow = max{maxNow, maxNow*nums[i], minNow*nums[i]}`, minNow 是三者取最小.
- 0174 地下城游戏 `难`
  - 用一个矩阵表示每个房间的 HP 损失(获得), 要求从左上角走到右下角的最小 HP
  - 不同与最短路径和, 要求每一个状态时刻的 HP 都为正数.
  - 方法一：动态规划. 采用 DP, 注意要从终点向前遍历. [因为不知道往后的路径需要消耗多少 HP, 因此不满足「无后效性」]. see [here](https://leetcode-cn.com/problems/dungeon-game/solution/di-xia-cheng-you-xi-by-leetcode-solution/)
    - 「我：公主，你自杀吧，我走不过去。公主：傻屌，起点等着，我去找你！」
    - DP 的含义: 进入该格子前至少需要的血量.
    - 转移方程: `dp[i][j] = max{1, min{dp[i+1][j], dp[i][j+1]}-dungeon[i][j]}`
    - 注意初始化边界情况, 或者像答案中一样采用哨兵.
- 0198 小偷 `中` 不能偷连续的房子, 要求收益最大
- 0213 小偷 Ⅱ 相较于 0198 题, 房子是个「环」, 即增加了不能同时使用收尾的条件
  - 由于首尾是相邻的，所以在取了第一个房子以后就不能取第 n 个房子，那么就在 [0,n - 1] 的区间内找出总价值最多的解，然后再 [1,n] 的区间内找出总价值最多的解，两者取最大值即可。
- 0264 丑数Ⅱ
  - 定义 Ugly 数为质因子均为 2,3,5 的数, 返回第 n 个丑数
  - 方法一: heap. 每次拿出堆中最小元素, 将其 2,3,5 倍数放入堆
    - 注意需要去重
  - 方法二: **三指针**. 第一个数字为 1
    - 用三个指针 `p2,p3,p5` 维护当前列表中待乘以相应数字的元素; 每次选择其中最小的一个加入列表, 向后移动对应指针
    - 和上面去重一样, 这里可能也会有重复情况, 因此指针移动需要考虑该情况 (不是 ifelse 结构而是多个 if)
- 0279 判断一个数最少是多少个完全平方数之和
  - 方法一：动态规划
    - 转移方程为 `dp[i] = min{dp[i-j^2] + 1}`, 这里要求 j 的平方小于等于 i.
  - 方法二: 数学
    - 由拉格朗日的四平方定理可得，每个自然数都可以表示为四个整数平方之和。 其中四个数字是整数。四平方和定理证明了任意一个正整数都可以被表示为至多四个正整数的平方和。这给出了本题的答案的上界。
    - 四平方和定理可以推出三平方和推论：当且仅当 $n \ne 4^k  (8*m+7)$ 时，n 可以被表示为至多三个正整数的平方和。
    - 因此, 可分别讨论是否为 1,4, 枚举判断是否为 2, 若都不是则输出 3. see [here](https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode-solut-t99c/)
- 0300 最长递增数列 `中` ⭐️
  - 方法一: DP.
    - dp[i] 为以第 i 个元素结果为 LIS 长度, 因此注意返回的不是最后一个元素
    - 因此 递推公式为, 找出此前的比当前元素小的位置, 查看其中最大的 LIS 长度 +1
    - Time O(n^2)
    - 方法二：`贪心 + 二分查找`
      - 用一个 `d[i]` 记录长度为 i+1 的IS 的最小结尾元素
      - 遍历数组, 每次的目标: 找到最后一个 `<num` 的元素, 更新该元素后面一个位置 (为新的 LIS 的最小结尾元素); 如果 d 的所有元素都小于 num, 则可以 append 到结尾.
  - 此题是一维的 LIS 问题。二维的 LIS 问题是 `第 354 题`。三维的 LIS 问题是 `第 1691 题` 。
- 0309 带冷冻期的股票收益
  - 这一题是`第 121 题`和`第 122 题`的变种题。每次卖出后的下一天为 Cooldown 无法重新买入
  - see [here](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/). DP, 由于第 i 天结束有三种状态, 因此考虑 记录三种状态的 DP
    - 我们目前持有一支股票，对应的「累计最大收益」记为 `f[i][0]`
    - 我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 `f[i][1]`
    - 我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 `f[i][2]`
  - 相应的转移方程:
    - 买入状态, 分为保持买入或买入新的持有期 `dp[i][0] = max(dp[i-1][0], dp[i-1][2]-prices[i])`
    - 状态1只能从状态0转来 `dp[i][1] = dp[i-1][0]+prices[i]`
    - 状态2只能从状态1,2转来 `dp[i][2] = max(dp[i-1][1], dp[i-1][2])`
  - 注意边界情况, `f[0][0]` 应该初始化为 `-prices[0]`, 其他两个状态初始化为 0
- 0322 零钱兑换 `中`
  - 方法2: DP
    - 一开始考虑到转移公式 `dp[i] = min{dp[j]+1}`, 其中 `j<i` 为满足 `dp[j]` 合法并且 i-j 在 coins 中的位置; 然而复杂度为 O(N^2) 直接超时
    - 反过来想, 要寻找满足要求的 j 只需要遍历 coins 即可找到可能的 j, 复杂度 `O(N * len(coins))`
  - 方法一：记忆化搜索
    - 简单的思路就是 backtracking. 为减小复杂度可以采用「记忆」记录搜索过的状态; 这样就和 DP 是一样的 (不过采用的函数递归的写法).
- 0329 矩阵中的最长递增路径 `难`
  - 给定一个整数矩阵，找出最长递增路径的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。
  - 建模: 有向图, 在数字增大的两个节点之间有边, 即变为在图中寻找**最长路径**
  - 方法一：记忆化深度优先搜索
    - 直接 DFS 复杂度过高, 注意到搜索有很多重复的情况, 因此用「记忆化搜索」; 具体而言, 初始化 `memo` 矩阵元素为 0, 对于经历过的节点最大长度必然 >=1, 以此来判断;
    - 注意到这题中矩阵相邻节点必然是「有向」的, 因此不必特意防止出现循环的问题.
    - 更新公式 `memo[x][y] = 1 + max{memo[nx][ny]}` 其中 [nx, ny] 为符合条件的邻节点
    - 时间: DFS 取决于图的大小, `O(V+E)`, 这里的 边和节点数均为 O(m*n), 因此总体为 `O(m*n)`
  - 方法二：拓扑排序
    - 上面将题目转化为了 DAG, 再结合上面的更新公式, 可知一个点的值完全可由其出度邻居决定 (DP), 因此可以用 **拓扑排序**, 拓扑排序时间复杂度为 `O(V+E)` (每个节点出度为 0 时入栈)
- 0337 小偷 3 `中`
  - 关联 `0198, 0213`, 这里的改动在于房子的结构变为一颗二叉树, 同样要求不能偷相连的两家
  - DFS 即可, 判断逻辑: see[here](https://books.halfrost.com/leetcode/ChapterFour/0300~0399/0337.House-Robber-III/) 逻辑比较简单
    - 注意到一件房子有被偷和不偷两种选项, 因此可以递归 `dfsRob(root *TreeNode) (robMax,notRobMax int)` 返回两种情况下的子树最优解, 返回跟节点这两个值的最大即可
    - 更新公式: 注意选择偷当前节点时左右子树只能加上 notRobMax
- 0338 比特位计数 `易`
  - 计算从 0-num 的所有数, 其二进制表示中的非零位数量
  - 方法四：动态规划——最低设置位
    - 利用二进制性质 `X & (X-1)` 可以清零最低位的1, 得到 DP 公式 `bits[x] = bits[x&(x-1)]+1`
  - [官答](https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/) 还给出了两种类似的思路:
    - 方法二：动态规划——最高有效位.
      - 在 0~num 遍历的过程中, 记录当前数字的最大位所对应的数字 (1,2,4,8,...), 更新公式 `bits[i] = bits[i-highBit] + 1`
      - 这里更新 highBit 的方式还是利用了上面的性质: 当遍历的 i&(i-1) == 0 时说明 i 只有一个非零位, 更新 highBit=i
    - 方法三：动态规划——最低有效位.
      - 分别考虑奇数和偶数的情况
      - `bits[i] = bits[i >> 1] + (i & 1)`;

### 08 Backtracking

- 0017 电话号码的字母组合
  - 直接回溯, 写成DFS即可
- 0037 解数独 `难`
  - 注意回溯的思路: 对于每一个为空的格子, 尝试填入所有可能的数字(通过 `checkSudoku(board *[][]byte, pos position, val int) bool` 函数判断是否可行), 最后要把格子还原为空;
  - 终止搜索: 只要找到一个解即可, 因此判断没有剩余的空格时, 直接返回 (最开始阶段, 扫描一遍数独, 将空格子记录到一个数组中).
- 0039 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合 `中`
  - 先对candidates排序避免重复, 回溯, 每次填入所有可能的数字(不超过target), 递归函数 `findcombinationSum(candidates []int, target int, index int, currentList []int, res *[][]int)` 其中的target为剩余的目标值, index是当前填入的数字所在指标
- 0040 相较于39题candidate有重复, 要求每个元素只能使用一次 `中`
  - 难点在于去除重复
  - 解法1: 排序, 然后在从index开始遍历的过程中, 判断 `if i>index && nums[i]==nums[i-1]` 以避免重复放入一个数字
  - 解法2: 直接将数组转为 map 统计各个数字出现的次数(例如 Python 中的 `freq = sorted(collections.Counter(candidates).items())`), 然后在选数字的时候, 尝试放入相同的数字多次, see [here](https://leetcode-cn.com/problems/combination-sum-ii/solution/zu-he-zong-he-ii-by-leetcode-solution/) .
- 0046 不重复数字**全排列**
- 0047 有重复数字的全排列 `中`
  - DFS即可, 注意**去重**逻辑 —— 先排序, **遍历时前一个相同的数字没有用到, 则这一个不考虑**.
- 51 N皇后 `难`
  - 其实也非常简单, DFS, 然后用 col, dia1, dia2 三个列表分别记录列和两个对角线的位置是否被占用, 遍历 rows 即可 (注意 col长度为 n, 而 dia1, dia2 长度为 2*n-1)
- 0077 组合 Combinations 给定两个数字, 找出所有 combinations of k numbers out of 1 … n
  - k 层 DFS 即可
- 0078 子集 Subsets 给定一个不同元素的数组, 找出所有的子集
  - DFS, 分别考虑第 index 位置的元素是否放入即可
  - 关联 `第 90 题，第 491 题`
- 0090 PowerSets 可重复的数组的所有子集 `中`
  - 排序+DFS
  - 去重逻辑: 用一个 lastUsed 标记上一个元素是否被用到. 当 1. 前后元素相同; 2. 上一个元素未被用到的时候, 应该跳过选入该元素. 也即 `index>0 && (*nums)[index-1]==(*nums)[index] && !lastUsed`
- 0079 判断一个字符串是否出现在一个 grid 中 `中`
- 0089 Gray 编码 `中` 参见 [wiki](https://zh.wikipedia.org/wiki/%E6%A0%BC%E9%9B%B7%E7%A0%81)
  - 1. 直接排列. 以二进制为0值的格雷码为第零项，第一项改变最右边的位元，第二项改变右起第一个为1的位元的左边位元，第三、四项方法同第一、二项，如此反复，即可排列出n个位元的格雷码。
  - 2. 镜像排列. n位元的格雷码可以从n-1位元的格雷码以上下镜射后加上新位元的方式快速的得到。
  - 另外, 观察 1-4 位 Gray码, 结合 wiki, 可以看到, 1. n位Gray码的前 2**(n-1) 位正是 n-1 位 Gray码; 2. Gray码最大的数字是 10000; 3. 上面两种方式生成的顺序是一致的
- 0093 找到一个字符串对应的所有可能 IP
  - 注意判断 IP是否合法, DFS
- 0127 单词接龙 `难`
  - 给定两个单词, 要求从 begin 变为 end, 每次只能变动一个字母, 并且中间的单词要在字典中, 求 **最短转换序列** 的长度
  - 参见 [sol](https://leetcode-cn.com/problems/word-ladder/solution/dan-ci-jie-long-by-leetcode-solution/)
  - 看到 **最短**, 首先想到 BFS. 为此, 首先需要将问题转化为图.
  - 方法0: BFS
    - 所有的单词 (转化为id) 作为节点, 仅相差一个字母的单词之间连边, BFS
    - 注意: BFS 需要**记录哪些节点未被访问过** (这里用一个 dist 映射记录节点深度), 避免死循环
  - 方法一：广度优先搜索 + 优化建图
    - 所有单词之间要算是否连边, 复杂度较高. 优化思路: 创建**虚拟节点**。对于单词 hit，我们创建三个虚拟节点 `*it、h*t、hi*`，并让 hit 向这三个虚拟节点分别连一条边即可。
    - 注意此时, 计算到的最短路径相应地应该 `/2`
  - 方法二：**双向广度优先搜索**
    - 可以可观地减少搜索空间大小
- 0126 单词接龙 II `难`
  - 要求找到 127 **中所有的最短路径**
  - 这里写得比较繁琐, [here](https://books.halfrost.com/leetcode/ChapterFour/0100~0199/0126.Word-Ladder-II/) 更简洁
  - 核心在于 **BFS 找到所有的最短路径** `BFS`
    - 还是利用 queue 结构, 问题在如何判断是否遍历完了一整层? 用 `queueLen` 记录当前层的长度, 当 queueLen==0 时进行更新.
    - 避免重复搜索 (剪枝) 的关键: `!(dist[v]<dist[u]+1)` 这里的 u 是当前搜索的节点, v 是从 u 出发相连的节点. 初始化节点 dist 为 `inf := math.MaxInt32`, 则需要添加 v 的有两种情况: 1. `dist[v]==inf` 即第一次遇到 v; 2. `dist[v]=dist[u]+1` 即当前层到达 v 有多种最短路径. 而若 `dist[v]<dist[u]+1`, 则说明到达 v 有更短的路径, 跳过.
- 0131 分割字符串为回文串序列 `中` 挺难的
  - see [here](https://leetcode-cn.com/problems/palindrome-partitioning/solution/fen-ge-hui-wen-chuan-by-leetcode-solutio-6jkv/)
  - 首先想到的是 遍历 index, 然后分别对左右子串进行 DFS, 这样复杂度爆炸
  - 实际上, 只需要记录在 index 前的字符串的分割可能, 然后遍历从 index出发的所有可能的回文子串即可
    - 用一个 tmp 字符串列表记录当前的分割方式
    - 为了避免重复判断, 可以用一个矩阵 isPalindrome **记录 `s[i:j]` 是否回文**.
      - 注意这里的 DP 递归形式, `dp[i][j] = s[i]==s[j] && dp[i+1][j-1]`. 这就要求 i 从大到小, j 从小到大遍历, 考虑到可能出现 `j=1, j=i+1` 的情况, 定义 dp[i,i-1], dp[i,i-2] 为 true (或者直接定义 j<=i 时 dp[i,j]=true).
- 0212 找到棋盘 board 中所有出现在字典 words 中的单词 `难`
  - 是 `79` 题的加强, 复杂度升高了
  - 解法1: 直接遍历
  - 解法2: Trie+回溯
    - 采用前缀树 Trie 记录所有代搜索的 word, 然后从 board 每个点出发尝试匹配 Trie
    - 为了避免重复, 在 DFS 的过程中, 将搜索过的位置用 `#` 符号进行标记
- 0216 找出所有相加之和为 n 的 k 个数的组合
- 0301 去除重复的括号 `难`
  - 要求返回去除某些字符后合法的所有字符串
  - 思路0: 第一遍循环记录最少应该删除的数量 countRemoveL, countRemoveR; 然后 DFS搜索, 当出现 1. 括号不合法; 2. 删除数量多于上面两个值是结束遍历.
    - 括号合法的条件: 顺序遍历过程中, **左括号的数量应该始终 `>=` 右括号**
  - see [here](https://leetcode-cn.com/problems/remove-invalid-parentheses/solution/shan-chu-wu-xiao-de-gua-hao-by-leetcode-9w8au/)
  - 思路2 BFS: 因为是找最短的所以考虑 BFS, 为了避免重复, 可以对待检查的字符串建立 map 去重
- 0306 累加数 `中` 判断一个字符串是否可构成累加序列
  - 两次遍历开始的两个数字, 然后判断后续是否构成累加即可
- 0357 计算各个位数不同的数字个数
- 0401 二进制手表 `易` 但感觉复杂度有 `中`
  - 思路0: 采用 DFS, 遍历所有的亮灯情况
  - see [here](https://leetcode-cn.com/problems/binary-watch/solution/er-jin-zhi-shou-biao-by-leetcode-solutio-3559/)
  - 方法一：枚举时分, 直接遍历 0-11 和 0-59
    - 注意计算亮灯数可以用函数 `bits.OnesCount8(h)` 或 Python 中的 `bin(h).count("1")`
    - 另外, 字符串输出可以用 `fmt.Sprintf("%d:%02d", hour, min)`
  - 方法二：二进制枚举
    - 直接枚举 0-1023 所有的十位二进制数, 前四位和后六位分别表示时刻和分钟, 则判断条件为 `h < 12 && m < 60 && bits.OnesCount(uint(i)) == turnedOn`
- 0473 数组构成正方形 `中`
  - 方法0: 利用一个 used 标记使用的元素, 然后依次生成四条边
  - see [here](https://leetcode-cn.com/problems/matchsticks-to-square/solution/huo-chai-pin-zheng-fang-xing-by-leetcode/)
  - 方法一: 也是DFS, 不过直接用一个数组记录四条边的长度, 一次遍历数组, 尝试放在四条边, 复杂度 $4^N$
  - 方法二：动态规划 + 状态压缩. 所谓「DP」其实就是我之前的思路, 因为可以依次生成每一条边. 不过标答的解法更简洁.
- 0491 找出所有递增子序列 `中`
  - 关联 `第 78 题，第 90 题`
  - see [here](https://leetcode-cn.com/problems/increasing-subsequences/solution/di-zeng-zi-xu-lie-by-leetcode-solution/)
  - 方法二：递归枚举 + 减枝
    - 注意这里的重复逻辑: 即使是在乱序数组中, 为了防止重复, 当这时遍历的数字和之前选入的数字一样时, 不遍历即可. 也即, 这里的代码逻辑和 0090 题完全一致.
  - 方法一：二进制枚举 + 哈希
    - 遍历所有可能的子序列, 然后去重, 串哈希算法 (即 Rabin-Karp 编码, 见 1392)
- 0494 用加减号连接数组, 构成目标值的数量 `中`
  - 方法一, DFS
  - 方法二, DP, see [here](https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode-solution-o0cp/)
    - `dp[i][j]` 为前 i 个数字中选取部分, 其和为 j 的组合数量
    - 可知, 更新公式为 `dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]`, 当 `j<nums[i]` 不合法, 第二项取0.
    - 优化空间, 可以用 **滚动数组**. 则更新公式为 `dp[j] += dp[j-nums[j]]`. 注意因为用了滚动数组, 内层循环需采用倒序遍历的方式.
  - 评论区中整理了相关的「**背包问题**」
    - 01背包：`416. 分割等和子集 474. 一和零 494. 目标和 879. 盈利计划 1049. 最后一块石头的重量 II 1230. 抛掷硬币`
    - 完全背包：`1449. 数位成本和为目标值的最大数字 322. 零钱兑换 518. 零钱兑换 II 279. 完全平方数, 377. 组合总和 Ⅳ`
    - 分组背包: `1155. 掷骰子的N种方法` 每一组是一个骰子，每个骰子只能拿一个体积为1到6的物品
- 0526 组合数, 要求每个位置的数字能被 index 整除或整除 index `中`
  - 方法1: DFS 即可
  - 方法二：`状态压缩 + 动态规划`. 参见 [here](https://leetcode-cn.com/problems/beautiful-arrangement/solution/you-mei-de-pai-lie-by-leetcode-solution-vea2/)
    - 核心在于 DP, 递推公式 `dp[mask] = sum{dp[mask-2^i]}` 这里的 i 要求满足其在mask所对应的数字中并且可整除; 这里的 mask 表示仅使用部分数字时所对应的二进制数 (状态压缩)
- 0638 有一些礼包可以打折, 要求给定购买物品数量的情况下, 找到最优解 `中`
  - DFS, 数据量不大
  - 方法一: [here](https://leetcode-cn.com/problems/shopping-offers/solution/da-li-bao-by-leetcode-solution-p1ww/) **记忆化搜索**. DP 更新公式分两种情况:
    - 一是购买礼包 `dp[needs] = min{price_i + dp[needs-needs_i]}`, 其中 price_i 和 needs_i 分别是礼包的价格和成分.
    - 二是不购买, 直接通过所有物品的单价算出来; 转移公式为两者较小值
  - 因为大礼包中可能包含多个物品，所以并不是所有状态都可以得到。因此，我们使用记忆化搜索而不是完全遍历的方法，来计算出满足每个购物清单 needs 所需花费的最低价格。
- 0784 字符串 S 中的每个字母转变大小写, 所有可能 `中`
  - 方法一: DFS
  - 方法二: 先将第一个字母变大写，然后依次把后面的字母变大写。最终的解数组中答案是翻倍增长的
    - 每一步为 `ans = [""]`，依次更新 `ans = ["a", "A"]`， ans = `["ab", "Ab", "aB", "AB"]`， `ans = ["abc", "Abc", "aBc", "ABc", "abC", "AbC", "aBC", "ABC"]`。
  - [sol](https://leetcode-cn.com/problems/letter-case-permutation/solution/zi-mu-da-xiao-xie-quan-pai-lie-by-leetcode/) 中还用到了 位表达, 或 itertools, 单复杂度是一样的
- 0816 将一个去除了小数点和逗号的二维左边还原 `中`
  - 注意判断一个字符串是否可构成数字 (小数)
    - 长度为 1, 只能构成整数
    - 以0结尾, 无法构成小数
      - 若同时还以0开头(长度>1 则无法构成数字
    - 长度>1 且不已0结尾
      - 若以0开头, 只能构成 `0.xxx` 形式的小数
      - 否则可以构成小数点任意位置的小数
- 0842 划分 Fibonacci 字符串 `中`
  - 关联 0306, 也即累加数组
  - 注意这里要求数列中的元素为有符号正整数, 即 `0 <= F[i] <= 2^31 - 1`

### 09 DFS

- 0094 中序遍历一棵二叉树 `易`
- 0098 判断二叉搜索树是否合法 `中`
  - 注意需要一个节点合法, 需要满足「大于左子树上的所有节点, 小于右子树上的所有节点」
  - 递归函数形式 `isValidbst(root *TreeNode, min, max float64) bool`
  - 检查条件 `return v>min && v<max && isValidbst(root.Left, min, v) && isValidbst(root.Right, v, max)`
  - 边界(root): `isValidbst(root, math.Inf(-1), math.Inf(1))`
- 0099 **二叉搜索树**中的两个节点被错误地交换。恢复这棵树。`中`, 偏 `难`
  - see [here](https://leetcode-cn.com/problems/recover-binary-search-tree/solution/hui-fu-er-cha-sou-suo-shu-by-leetcode-solution/)
  - 解法一 中序遍历转为列表. 核心思路是, 二叉搜索树中序遍历等价于一个递增列表, 直接转化为列表后处理
    - 对于交换两个元素, 可能出现一个或两个位置不满足 `a[i]<a[i+1]`, 我们在中序遍历得到的列表中找到要交换的节点即可
    - 若交换的是相邻元素, 例如 [1,3,2,4,5,6,7], 保留指针 i, i+1即可, 若不相邻, 例如 [1,6,3,4,5,2,7], 则会有 i,j 两个元素不满足递增条件, 保留 i+1, j; 综上, 可以通过一次遍历得到要交换的两个节点
  - 解法二 上面是「显式中序遍历」, 将中序遍历的值序列保存在一个数组中, 我们也可以隐式地在中序遍历的过程就找到被错误交换的节点.
    - 思路其实是一样的, 我们只关心中序遍历的值序列中**每个相邻的位置的大小关系是否满足条件**(且错误交换后最多两个位置不满足条件). 因此在中序遍历的过程我们只需要维护**当前中序遍历到的最后一个节点**, 然后在遍历到下一个节点的时候，看两个节点的值是否满足前者小于后者即可，如果不满足说明找到了一个交换的节点，且在找到两次以后就可以终止遍历。
    - 具体实现上, 又可分为递归和用 stack 来记录两种方案. 1. 官答用了栈来记录当前节点的「右父亲列表」(注意, 对一个节点, 其中序遍历的下一个点是其右子树中最小的节点, 即不断尝试访问左儿子); 2. [halforest](https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0099.Recover-Binary-Search-Tree/) 的解答用的是递归, 更为直观
      - 注意这里的递归函数形式 `inOrderTraverse(root, prev, target1, target2 *TreeNode) (*TreeNode, *TreeNode, *TreeNode)` root 为当前节点, prev 为中序遍历的上一个节点, target1, target2 为要找的两个节点; 返回 prev, target1, target2.
  - 解法三 取消栈空间, 略
- 0100 判断两个二叉树是否完全相同
  - 深度优先即可
- 0101 判断二叉树是否对称
- 0104 二叉树的深度
  - DFS 递归
    - 当递归到 nil 时返回 0
    - 节点部位空时返回 `return max(maxDepth(root.Left), maxDepth(root.Right)) + 1`
  - BFS 用stack保存每一层的节点
- 0110 判断一棵树是不是平衡二叉树。平衡二叉树的定义是：树中每个节点都满足左右两个子树的高度差 <= 1 的这个条件 `易`
  - DFS 递归 `isBalancedHight(root *TreeNode) (bool, int)` 返回这棵子树是否平衡, 以及树高
- 0111 给定一个二叉树，找出其最小深度。最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量
  - 叶子节点是指没有子节点的节点
  - 和 104 的区别在于, 若左右孩子只有一个为空, 则应该根据另一个子树的深度计算; 只有当左右均不为空时才返回 `min(minDepth(root.Left), minDepth(root.Right)) + 1`
- 0112 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。说明: 叶子节点是指没有子节点的节点。
  - 还是注意叶子节点的判断
- 0113 找出上题中的所有路径 `中`
  - 难度倒是不大, 利用一个变量记录目前的路径, 倒是在 go 和 python 的指针传递上尝试了好久; 详见代码语法总结部分「全局变量 vs 传参」「传递 值拷贝 vs 指针」
- 0114 将二叉树展开为链表, 先序遍历
  - 解法一 递归: 对于递归函数 `flatten2(root *TreeNode)`, 分别将左右孩子完成flat, 由于是先序遍历, 所以 `root->root.left->...->root.right` 即可, 注意是左子树转化的链表最末尾连接右子树
  - 解法二 非递归 每次找到左子树的最右(也即链表最后一个元素), 然后将右子树连接上去, 参见 [here](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/)
- 0116 填充每个节点的下一个右侧节点指针 `中`
  - 给二叉树同层之间的节点建立 Next 指针
  - 解法一 迭代。其实也是比较直观的想法：利用上一层已经有的 Next 构成的链表来传递；减少了下面的递归栈。
  - 解法二，递归。递归函数 `connectTwoNodes(n1, n2 *Node)` 是同层的相邻两个节点，在函数中要求连接 1. node1, node2 其左右孩子；2. `node1.Left.Next=node2.Right`
- 0124 二叉树中任意一条路径的最大和 `难`
  - 乍一看有点复杂，分析：
    - 首先需要记录从当前节点出发向下的最大路径和 `currMax := max(root.Val+left, root.Val+right, root.Val)`
    - 然后是经过盖点的最大路径和 `max(currMax, left+right+root.Val)`
  - 具体的实现上，自己用了两次DFS，其中第一次更新 `map[*TreeNode]int{}` 记录 currMax
    - 而 [here](https://books.halfrost.com/leetcode/ChapterFour/0100~0199/0124.Binary-Tree-Maximum-Path-Sum/) 中，直接将 currMax 作为递归函数返回值来传递，更为简洁。

### 11 binary search 二分查找

- 0004 寻找两个有序数组的中位数 `难`
  - 简单起见, 合并更方便
  - 二分搜索, 参见 [here](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)
  - 这里go的实现, 通过维护数组的分界点来找, 思路也很清晰
- 0033 搜索旋转排序数组 `中`, 没有重复, 返回索引值
  - 可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 `[l, mid]` 和 `[mid + 1, r]` 哪个部分是有序的
  - 如果 `[l, mid - 1]` 是有序数组 (即 `nums[mid]>=nums[0]`)，且 target 的大小满足 `[nums[l],nums[mid])`，则我们应该将搜索范围缩小至 `[l, mid - 1]`，否则在 `[mid + 1, r]` 中寻找。
  - 反之, 若 `nums[mid]<=nums[-1]`, 则可直接根据 target 是否在 `(nums[mid], nums[r]]` 判断是否在右半部分, 否则在另一边搜索
- 0034 找出给定目标值在排序数组中的开始位置和结束位置
  - 基本变体: 找第一个/最后一个等于 target 的元素
- 0035 查找有序数组插入位置 `中`
  - 经典变体, 即「在有序数组中找到最后一个比 target 小的元素」
- 0069 实现 sqrt
  - 解法二 `牛顿法`, 即求 `f(x)=x^2-n` 的零点
  - 更 fancy 的还可以更快
- 0074 搜索二维有序数组 `中`
  - 基本的二分搜索
- 0081 搜索旋转排序数组Ⅱ, 和33题相比多个可重复
  - 其实仅仅多了一种情况: 当 `nums[mid] == nums[l] && nums[mid]==nums[r]` 时无法判断哪一部分是有序的, 因此只能 `l++; r--`
- 0153 搜索旋转排序数组 中的最小值(旋转点) `中`
  - 由于旋转数组也可以是正常升序数组, 因此判断条件应该是和 high 比较而不能只和 low 比较
  - 解法一 其实也可以用基本的二分范式 `l<=r`, 判断条件复杂一点
  - 解法二 这类题目也可以用 `low < high` 作为终止条件, 相较于基本范式, 这里 high 和 low 的是不对等的. high 只是用来缩减搜索范围, 而 low为输出结果的指针
- 0154 相较于 153 增加了可重复条件 `难`
  - 如果还是用基本范式, 判断条件会更复杂一点; 但用双指针逼近的思路会更清楚
- 0162 找到数组中的「**山峰**」 `中`
  - 算是二分的经典变体, 和 153 一样用 high low 进行判断会比较简单; 基于 `nums[mid+1] >= nums[mid]` 进行更新
- 0167 找到两数之和为目标值的index
  - 和第 1 题一样, 不过时排好序的, 可以用双指针逼近, 从而免去了map空间
- 0209 长度最小的子数组 `中`
  - 正数数组, 找到 >=target 的连续子数组的最小长度.
  - 解法一 先计算 cumsum, 然而对于每一个子数组开始位置, 可以用二分搜索找到最小长度, 时间 O(nlogn), O(n)
  - 解法二 「**滑动窗口**」在滑动窗口 [i,j]之间不断往后移动，如果总和小于 s，就扩大右边界 j，不断加入右边的值，直到 sum > s，之和再缩小 i 的左边界，不断缩小直到 sum < s，这时候右边界又可以往右移动。以此类推。 O(n), O(1)

总结了二分查找的注意点:

- 循环退出条件，注意是 low <= high，而不是 low < high。
- mid 的取值，mid := low + (high-low)»1
- low 和 high 的更新。low = mid + 1，high = mid - 1。

四个基本的变种

- 二分查找第一个与 target 相等的元素，时间复杂度 O(logn)
- 二分查找最后一个与 target 相等的元素，时间复杂度 O(logn)
- 二分查找第一个大于等于 target 的元素，时间复杂度 O(logn)
- 二分查找最后一个小于等于 target 的元素，时间复杂度 O(logn)

另外一类常见的: 基本有序数组. 在山峰数组中找山峰，在旋转有序数组中找分界点。第 33 题，第 81 题，第 153 题，第 154 题，第 162 题，第 852 题

### 12 math

- 0002 两数相加, 形式为逆序链表. `中`
  - 定义了基本的 `ListNode` 结构, 并定义 `List2Ints, IntsList` 实现数组和链表的方便转换.
- 0007 反转32位整数 `中`
  - 这题主要的限制是在要防止 32位 sign int 溢出, 讨巧的思路可以用更长的整数类型/字符串来保存. 「标准」思路应该是每次 `*10` 之前进行检查 (或者说, 和 `math.MinInt32/10` 进行比较) 防止溢出.
- 0009 Palindrome 回文数
  - 同样可以采用 1. 反转数字; 2. 转为数组; 3. 转为字符串等方式.
  - 直接反转可能溢出 (虽然此时必然不是回文数); 思路是「反转整数长度的一半」(即循环条件 `x>rev`), 最后的判断条件: 若 x 为回文数且长度为偶数, 则 `x==rev`; 若为奇数, 则 `x==rev/10`
- 0012, 0013 罗马数字转阿拉伯数字
  - 就是所使用的基数不用, 累计即可
- 0060 Permutation-Sequence 找出以一定的数字作为元素的排列中的第 k 个 `难`
  - 思路一 也即官方的 [缩小问题规模](https://leetcode-cn.com/problems/permutation-sequence/solution/di-kge-pai-lie-by-leetcode-solution/); 其实也可理解为贪婪剪枝的 DFS?
    - 使用 go 来实现的时候没有 Python 中好用的 `math.perm` 函数, 方便的类型转换等. 解答中用到的一些技巧值得学习. 例如, 1. 构造了 factorial 来实现 Python 中的 math.perm; 2. 用 valid 数组标记还没有用过的数字
    - 重点还是要明确公式: `a_i=(k-1)mod(n-1)!+1`
  - 反过来的问题: 对于给定的排列确定其为顺序第几个?
    - 公式 `k=sum(order_i*(n-1)!)+1`, 其中的 order_i 是在 序列 `a_i+1...a_n` 中小于 a_i 的元素数量
- 0029 整除 `中`
  - 思路一 类似二分查找, 每次将除数 `*2` 找到小于等于被除数的最大的那一个, 迭代终止条件是 `dividend<divisor`, 即不断减去除数的倍数之后, 剩余的部分小于除数
  - 思路二 `倍增法` 实际上在除数递增的过程中即可将被除数相减, 当增大到接近被除数之后再不断 `/2`, 终止条件是因子 `cnt==0`, 也即 `dividend<divisor`

## 其他

- [周赛记录](./notes/contests.md)
- [每日一题](./notes/daily.md)