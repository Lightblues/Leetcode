
## 每日一题

- 0219 存在重复元素 II
    - 一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k
- 2029. 石子游戏 IX `中` 但实际上可以说很难!
    - 分别取石子, A优先, 两条规则
        - 当某个人取出后总和为 3的倍数时, 其失败;
        - 当取完所有的石子, 条件1不成立, 则 A 失败(不管最后一个是谁取的).
    - 博弈, 参见 [官方解答](https://leetcode-cn.com/problems/stone-game-ix/solution/shi-zi-you-xi-ix-by-leetcode-solution-kk5f/).
    - 首先的失败条件是取出的石子总和为 3, 因此可将石子除以3的余数为 0,1,2 分成三类
    - 先不考虑 0, 假设只有 1,2. 由于每个人都是最佳决策, 因此只会出现
        - `1,1,2,1,2,1,...` 或者 `2,2,1,2,1,2,...` 的序列. 也即除了第一颗, 两个都回去相同的石子.
        - 条件 1 的失败条件为对方没有可取的石子, 因此 A 的策略是取数量少的那一类.
            - 以 `1,1,2,1,2,1,...` 序列为例, A 获胜条件为: 有类型 1 的石子并且数量少于类型 2, `0 < cn1 <= cn2`
        - 综合两种情况, A 获胜条件为 `cnt1 >= 1 and cnt2 >= 1`
    - 还要考虑 1, 当 0 的数量为偶数时, 条件不改变. 考虑 0 有奇数个
        - A 的策略仍然是选择较少的类, 然而此时 B 可以有一次选类型 0 石子的机会, 因此条件变为
            - `cnt1 - cnt2 > 2 or cnt2 - cnt1 > 2`
- 1345. 跳跃游戏 IV `难`
    - 给一个数组, 只能前后一格, 或者跳到相同数字的格子上, 求到达终点的最小跳数
    - 显然可以建模为最短路径问题;
    - 然而直接建图 BFS 超时了. 问题在于, 当存在大量点的数字相同, 变为稠密图, BFS 复杂度为 `O(n^2)`
    - 方法一：广度优先搜索 see [here](https://leetcode-cn.com/problems/jump-game-iv/solution/tiao-yue-you-xi-iv-by-leetcode-solution-zsix/)
        - 考虑这一问题的特殊性: 所有相同元素构成稠密图, 因此没有必要遍历改子图上所有的边 —— 递归一遍这些节点后, 没有必要在这一稠密图上搜索了
        - 因此, 直接不构建这一部分的图
        - 具体而言, 不构建显式的图, 直接记录每个数值包括的位置集合 val2index. 当从一个点 index 出发遍历了所有 val2index[arr[index]] 中的节点后, 直接 `del val2index[arr[index]]` 从而避免构建这一稠密图
- 1332. 删除回文子序列 `易`
    - 给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。求删除次数
    - 注意审题，只包含两个字母，并且删除的 **回文子序列**，因此最多是两次
- 2034. 股票价格波动 `中`
    - 股票数据可能会更新，以后到的为准，要求实现：1. 更新；2. 返回最近时间的价格；3. 找到最高/最低价格
    - 核心在于：之前记录的价格可能是错的，**如何在这种状态下维护最大值**
    - 方法一：哈希表 + **有序集合**
        - 用 map 存储每个时间对应的价格；有序列表存储所有的价格（要求最大最小直接返回列表的首尾元素即可） `from sortedcontainers import SortedList`
    - 方法二：哈希表 + 两个 **优先队列**
        - 用两个优先队列分别存储最大和最小值， (price,timestamp)；在返回时，将存储的 price 和 map 中对应时刻的价格比较，若不一致则说明过期了
- 2045. 到达目的地的第二短时间 `难`
    - 给定一张图，求从 1 到 n 的第二短路径；在这些节点上定义了红绿灯，每条边的开销是一样的，当到达节点时，次节点是红灯状态下无法离开，需要等待到下一次绿灯；所有节点的红绿灯变化是一样的，求第二短时间。
    - 方法一：广度优先搜索
        - see [here](https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/solution/dao-da-mu-de-di-de-di-er-duan-shi-jian-b-05i0/)
        - 第一步，计算次短路径。直接暴力 BFS 会超时，注意到 **仅需要记录一个节点的最短和次短路径**，因此可以剪枝
        - 第二步，计算时间。迭代的方式求解，当 `time_j % (change*2) >= change` (红灯状态) 时需要等待 `change*2 - time_j % (change*2)`
- 2047. 句子中的有效单词数 `易`
    - 根据空格分隔单词，一个正确的词要求：1. 不包含数字；至多一个连字符，其前后必须是字母；2. 至多一个标点符号（'!'、'.' 和 ','），必须在结尾
    - 作为一道简单题还是挺烦的 [here](https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/solution/ju-zi-zhong-de-you-xiao-dan-ci-shu-by-le-hvow/) 用了一次遍历；自己实现的时候调用了 count 相对会慢一点？测下来差不多
- 1765. 地图中的最高点 `中`
    - 给定一个矩阵表示水域和陆地. 约束为相邻的两个点高度差至多为1, 要求最高点.
    - 从所有的水域 (高度为 0) 出发, BFS即可. 注意这里的起始状态是一组点, 这样一层层拓展出去是不会违反约束的.
- 0884. 两句话中的不常见单词 `易`
    - 给定两句话, 输出「不常见」的词. 定义不常见: 如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。
    - 尝试过用 set 解决, 不太方便; 实际上该题词数最多 200, 暴力遍历更方便
- 1342. 将数字变成 0 的操作次数 `易`
- 1763. 最长的美好子字符串 `易`
    - 定义「美好字符串」: 当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中
    - 暴力遍历
- 2000. 反转单词前缀 `易`
- 1414. 和为 K 的最少斐波那契数字数目 `中`
    - 给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。
    - 贪心, 每次取最大可能的斐波那契数字即可
- 1725. 可以形成最大正方形的矩形数目 `易`
- 1763. 最长的美好子字符串 `easy`
- 2000. 反转单词前缀 `easy`
- 1725. 可以形成最大正方形的矩形数目 `easy`
- 1219. 黄金矿工 `medium`
    - DFS
- 1405. 最长快乐字符串 `medium`
    - 给定三个数字 a,b,c 分别是字符 abc 的数量, 构造最长字符串, 满足其中不包含三个连续的相同子字符串, 例如 aaa
    - 思路一: 分解+讨论
        - 先考虑两种字符的情况(假设按照数量多少记为 xy): 优先利用数量较多的字符 (每次取两个y, 一个x); 可知 1. 当 `len(x)<len(y)<=2len(x)+2` 时, 某一时刻 y 剩余数量会等于 x, 然后交错排列即可, 得到的字符串长度为 len(x)+len(y); 2. `len(y)>2len(x)+2` 时, y 不会用完, 得到的字符串长度为 len(x)+2len(x)+2
        - 然后考虑三种字符的情况(假设按照数量多少记为 xyz, 数量分别为 n1,n2,n3): 记上述构造方式为函数 construct
            - 当 `n1+n2<n3` 时, 把前两种字符当作一种即可, `construct(x*n1+y*n2, z*n3)`;
            - 当 `n1+n2>n3` 时, 注意此时必然可构造全长 (n1+n2+n3) 字符串, 先尽量基于前两种字符构造, 然后插入数量最多的那种字符.
                - `szy = construct(x*n1, y*n2)`
                - 注意到, 当 `n2 > 2*n1` 时, 利用前两种字符构造时次多字符会有剩余, 因此将剩余的次多字符放在前面 `construct(z*n3, y*(n2-countb)+sxy)`
    - 方法一：贪心
        - 上面典型想复杂了, 而且不可拓展. 此题直接贪心即可: 每次选择数量最多的字符.
- 1001. 网格照明 `hard`
    - 大小为 n x n 的网格 grid, lamps 给定了一组灯, lamps[i] = [rowi, coli] 可以照亮 行、列、两条对角线
    - 再给一组查询坐标 queries[j] = [rowj, colj], 每次查询返回该点是否被照亮, 并且查询后关闭该点为中心的 3*3 九个坐标上的灯
    - 思路: 用四个字典 defaultdict(set) 记录 行、列、两条对角线 上的亮灯情况
- 1447. 最简分数 `medium`
    - 给一个整数 n, 返回所有 0-1 之间的, 满足分母小于等于  n 的 **最简分数**
    - 暴力遍历, 核心在实现 `gcd(a,b)`, 实际上可以直接调用 `math.gcd`
- 1020. 飞地的数量 `medium`
    - 0 表示海洋 1 表示陆地, 定义无法通过陆地走到矩形的边界的陆地为「飞地」
    - 方法一：深度优先搜索. 用一个 visited 避免重复
    - 方法三：并查集, [here](https://leetcode-cn.com/problems/number-of-enclaves/solution/fei-di-de-shu-liang-by-leetcode-solution-nzs3/)
        - 根据题意定义、初始化一个并查集, 然后扫描矩形, 进行合并
            - 扫描过程中, 由于是规则的, 因此对两个方向进行判断(合并)即可! 而不是 DFS 中四个方向
        - 此题中, 维护一个 `onEdge` 数组判断每个节点是为飞地. 注意每次总是更新父节点 (因为查询的时候, 总是先 find 跟节点, 然后判断是否相连)
        - 并查集的核心:
            - 维护一个 father 数组, 其中每个元素的值为其父节点的索引
            - 实现 1. find 查找根; 2. union 合并两个节点; 3. same 判断两个节点是否同根 (并集)
            - 在合并过程中, 利用 rank 来将较小的集合合并到较大的集合中, 并且更新 rank, 简化
- 1189. “气球” 的最大数量
- 0540. 有序数组中的单一元素 `medium`
    - 有序数组中仅有一个元素为单一, 其他都有两个, 找出单一元素
    - 二分搜索
- 1380. 矩阵中的幸运数 `easy`
- 1719. 重构一棵树的方案数 `hard`
    - 定义一颗树的祖先展开: 结果是一组 (x_i, y_i) 包括了一颗有根树中所有的祖先关系
        - 例如, 对于 [[1,2],[2,3]] 重构是唯一的
        - 而对于 [[1,2],[2,3],[1,3]], 可知对应的树有很多, 例如 1->2->3 就是一颗
    - 现在给定一个数组 (祖先方向不定), 要求判断是否是一颗树的展开, 如果不是返回0, 结果是否唯一返回 1/2
    - 方法一：直接模拟. from [here](https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/solution/zhong-gou-yi-ke-shu-de-fang-an-shu-by-le-36e1/)
    - 分析节点度数: 假定给定的数组满足条件, 可知: 1. root 的读书为 n-1; 2. 若 (x,y) 为祖先关系, 则子节点 y 满足 degree[x]>=degree[y], 且 adj[x] \superset adj[y]; 3. 若 degree[x]=degree[y], 则两个节点一定是单链关系, 此时两个节点是可以互换的 (不唯一)
    - 因此总结
        1. 若 degree[x]>degree[y], 则 x 为祖先
        2. 若`degree[x]<degree[y]`, 则 y 为祖先
        3. 若 degree[x]=degree[y], 则结果不唯一
    - 如何解题? 遍历节点, 构造度. 1. 首先检测是否存在根节点; 2. 然后对于每一个节点 x, 寻找其「父节点」 (从度数大于它的集合中找, 选其中度数最小的); 若找到的节点度数 =degree[x], 当所有节点都满足时说明结果不唯一.
    - 这里关键在于, 祖先节点的邻居必然包含其子节点的邻居集合. 一个节点的父节点度数必然大于它, 这样就可以寻找节点的父节点.
- 1791. 找出星型图的中心节点 `easy`
- 0969. 煎饼排序 `medium`
    - 给数组arr排序, 支持的操作是翻煎饼, 即反转 arr[0:i]; 要求返回一个操作序列
    - 冒泡排序, 每次选择剩余序列中最大的那一个, 通过两次翻转放到最后
- 0717. 1比特与2比特字符 `easy`
- 0838. 推多米诺 `medium`
    - 给定一系列骨牌的初始状态: L,R,. 标志向左向右倒, 或者不动, 判断结束状态. 当一个牌分别受到左右两边的力时, 保持竖直.
    - 自己用了极其繁琐的方式: 记录所有 L,R 牌的位置; 对于每个竖直的牌, 维护四个index分别记录其左右两边最靠近的起始向左向右的牌的index.
    - 当 `lright>lleft` 时, 牌可能向右倒, 当 `rleft<lright` 时, 牌可能向左; 若上面两个条件都成立, 则根据距离判断. 繁琐的是要判断这些 index 是否存在.
    - 为此, 写了 `findIndexBigger, findIndexSmaller(arr, startIndex, index)` 分别从 startIndex 出发, 在序列arr中找到大于index的最小值(小于index的最大值)
    - 方法二：模拟
        - from [here](https://leetcode-cn.com/problems/push-dominoes/solution/tui-duo-mi-nuo-by-leetcode-solution-dwgm/)
        - 考虑一段连续的竖直骨牌, 根据其左右两边的牌的方向来确定;
        - **trick**: 在左右边界分别加上 L,R 作为「哨兵」
    - 方法一：广度优先搜索
        - 利用一个队列记录当前时刻受力的位置(前一时刻边上的骨牌倒下)
- 1994. 好子集的数目 `hard`
    - 给定一组数字, 都不大于30. 求满足条件的所有子集的数量, 条件为: 子集中所有数字的乘积可以 = 不同的质数的乘积.
    - 方法一：状态压缩动态规划
        - [here](https://leetcode-cn.com/problems/the-number-of-good-subsets/solution/hao-zi-ji-de-shu-mu-by-leetcode-solution-ky65/)
        - 由于数字都比较小, 可以罗列所有的质数 `primes=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]`
        - 对于一组数字, 它们所用到的质数可以通过状态压缩来表示, 即 0/1 表示以上10个质数用到了哪几个, 记为 mask
        - 考虑 DP: 用 d`p[i][mask]` 表示只使用数字 `2~i`, 并且所用的数字的质数组合为 mask, 这样的子集的数量.
            - 状态转移方程: 若 数字i本身包含平方因子, 例如 4, 12 等, 则该数字无法采用, `dp[i][mask] = dp[i-1][mask]`;
            - 否则, 假设i包含的质数组合为 subset, 则 `dp[i][mask] = dp[i-1][mask] + dp[i-1][mask\subset] * freq[i]`, 其中的 subset 必然是 mask 的子集, mask\subset 可以异或得到
        - 因此, 从 i=2开始遍历到 30, 最后的结果 `sum(dp[30][mask])` 表示所用的质数组合为 mask 的方案数量. 注意 `dp[][0]` 没有意义: 因为 mask=0 表示没有取到任意质数.
        - 需要注意的是数字 1, 其作为因子不影响乘积, 因此可以取任意数量; 然而, 单纯用数字1不满足条件. 两种方案:
            - 取 `dp[1][0] = 1`, 从而避免 `dp[i-1][mask\subset] * freq[i]` 式子中的判断; 最后取 `sum(dp[30][1:]) * 2**freq[1]`
            - 也可以初始化 `dp[1][0] = 2**freq[1]`, 表示单纯用 1 的组合数量; 最后取 `sum(dp[30][1:])` (因为单纯用数字1不满足条件)
- 0917. 仅仅反转字母 `easy`
- 1706. 球会落何处 `medium`
    - 用一个grid表示该位置挡板的方向, 从最上边的每一个位置放小球, 返回小球最后落在的位置, 若无法掉出来 (挡板呈现V字形) 则返回 -1.
    - 注意球无法掉下来的条件: 出现V字形或者到达边界无法再往边界方向.
- 2016. 增量元素之间的最大差值
- 0553. 最优除法 `medium`
    - 给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如， `[2,3,4] -> 2 / 3 / 4` 。
    - 添加括号, 要求最后的结果最小, 要求括号时最简的.
    - 思路: 除法添加括号, 理解成把数组中各个数字放在分子还是分母上. 显然, 前两个数字, 第一个一定在分子, 第二个一定在分母上. 通过 `2/(3/4/5/...)` 将第三位之后的数字放在分子上.
    - 注意边界: 数组长度为 1 或 2.
- 1601. 最多可达成的换楼请求数目 `hard`
    - 有 n 栋楼, 给定一组请求 `requests[i] = [fromi, toi]` ，表示一个员工请求从编号为 `fromi` 的楼搬到编号为 `toi` 的楼。要求返回出入数量均衡的方案中最大.
    - 注意本题的条件: 楼的数量 `1 <= n <= 20`, 请求的数量 `1 <= requests.length <= 16`.
    - 方法一：回溯 + 枚举
        - 我们可以通过回溯的方式枚举每一个请求是否被选择。用一个 `delta` 列表记录每栋楼进出人数, 党遍历到叶子结点时, 通过检查是否 delta==[0] 来判断是否满足条件.
        - 时间: O(2**m), 其中m为请求数组长度, 空间 O(m+n)。递归需要 O(m) 的栈空间，数组delta需要 O(n) 的空间
    - 方法二：二进制枚举
        - 利用二进制转化为选择方案进行枚举, 每次需要判断选择的方案是否满足条件.
        - 因此时间 O(2**m * n), 其中n为房间数量. 空间复杂度 O(n) 为delta数组.


## 2205

- 0913. 猫和老鼠 #hard
    - 给定一张图, 老鼠和猫分别从节点 1和2 出发, 老鼠到的目标 0 则获胜 (猫不能到达0). 给定初始状态, 求在双方都是最优解的情况下, 哪一方获胜.
        - 注意, 可能出现平局的情况! 分别用 1/2/0 表示老鼠/猫获胜/平均.
        - 复杂度: 图的节点数最大 50.
    - [here](https://leetcode.cn/problems/cat-and-mouse/solution/mao-he-lao-shu-by-leetcode-solution-444x/)
    - 思路0: 自顶向下 DP
        - 状态: `dp[mouse][cat][turns]` 表示猫和老鼠所在的节点以及当前轮次.
        - 终止条件: 1) 老鼠到达终点或被抓到; 2) 关键是如何判断平局? 注意到有时必须遍历所有的相邻节点才能得到答案, 那么两个相邻节点之间就可能发生死锁!
        - 注意到, 这里的所有节点状态为 2n(n-1), 猫和老鼠可以到达的点乘积 * 该轮轮到老鼠/猫移动. 在每个 agent 都是理性的情况下, 若出现重复访问节点则说明平局.
        - 然而, 复杂度相当高! DP数组的复杂度为 $n^4$, 而对每一个状态计算状态值 `getNextResult` 的复杂度为 n, 因此总体复杂度为 $n^5$, 即使 $n=50$ 也是超时.
    - 思路1: #拓扑排序
        - 上一种思路中, 判断平局需要迭代到 $n^2$ 复杂度. 为了避免重复访问节点, 相较于「自顶向下」我们可以「自底向上」进行遍历 (实际上就是拓扑排序!).
        - 具体而言, 这里一共只有 n^2 个节点, 我们通过枚举所有的终止状态, 然后从该状态反推. 对于上一个节点:
            - 可以判断胜利的条件: 对于当前行动体 a 的获胜条件: 当前为a的回合并且可以走到一个a的必胜节点
            - 否则: 无法判断, 继续往下查找. 为了避免重复访问, 我们记录每一个节点的度数, 每遇到这种情况就 -1.
                - 若一直到度数=0还不行, 则说明, a无论选择所有行动都无法获胜, a必败 (注意不是平局);
                - 对于最后剩余无法判断的节点, 平局 (因此初始化所有节点为平局).
        - 在主函数中, 我们维护一个 **queue**, 存放所有确定结局的节点. 遍历过程中, 1) 对于一个确定结局的节点, 将其加入 queue; 2) 否则, 度数 -1.
        - 分析上述流程, 其实就是 #拓扑排序.
        - 总有 n^2 个节点, 每个节点最多访问 n 次, 因此是 O(n^3)
- 1728. 猫和老鼠 II #hard
    - 和 0913 类似的设定. 不过图换成了更为现实的带有墙的grid, 以及猫和老鼠每一次都可以选择走 1~limit 步.
        - 另外给出限制: 如果老鼠不能在 1000 次操作以内到达食物，那么猫获胜. (实际上不用也没问题, 因为状态空间比较小不会出现 (平局情况下) 经过这么多步不还没到达稳态的情况.)
        - 因此, 这题的返回就是 T/F 表示是否为老鼠获胜.
        - 复杂度: 网格长宽 8*8, 1 <= catJump, mouseJump <= 8.
    - 思路: 还是按照之前的思路, 反向搜索, #拓扑排序
        - 这里定义了状态结构 `namedtuple('State', ['mouse', 'cat', 'turn'])` 前两个 (x,y) 表示两类agent的位置, 0/1 的turn 表示当前是谁的行动回合.
        - 相较于 0913 这里需要构造节点之间的转移关系 (图).
        - 另外, 反向拓扑排序的时候需要注意, 记录的节点度数为出度; 对应了在反向搜索的过程中, 如果不满足条件则 degree额-1.
    - 技巧: 监视某些值, 在 debug状态打断点观察. 例如, 关心一个字典中某一个 key 的值变化, 可以把这个数值存到一个变量中, 打一个断点. 如, `if prevNode in x` 行判断是否需要监视, 下一行 `print(x[prevNode])` 上加断点.
- 0715. Range 模块 #hard #题型
    - 要求实现对于 [) 形式的区间的 增删查操作.
    - 思路1: 关联 6066, 用两个数组分别记录左右边界. 在添加记录的时候, 注意进行区间的合并.
    - 思路2: [官方](https://leetcode.cn/problems/range-module/solution/range-mo-kuai-by-leetcode/) 答案中 #区间求交 #二分
        - 将区间直接存储为 (left, right)
        - 实现了一个通用的函数, 计算查询区间 [l,r) 与所存储的区间有交集, 实现更为方便的 add, remove.
    - #技巧: 通过 (100, 10, 1) 这种形式的步长衰减来替代bisect
- 0316. 去除重复字母 #medium #题型 #单调栈 #stack
    - 要求得到一个字符串的子串, 1) 由原本字符串中的所有元素组成; 2) 所有字符不重复; 3) 字典序最小.
    - 思路: 单调栈
        - 去除限制条件, 我们如何得到一个尽可能小的字符串? 基本思路是 **维护一个单调栈**, 当遇到一个新的字符时, 如果栈顶元素小于当前字符, 则递归弹出栈顶元素, 然后再把这个字符入栈; 否则直接把当前字符压入栈 (注意当前字符总会入栈).
        - 这里要求 1) 保留原字符串中的所有元素, 因此用一个 counter 记录剩余的数量, 当剩余数量为0时, 我们不能将该元素弹出栈; 3) 字符不重复, 因此在入栈的时候判断该字符是否已经在栈内.
    - [here](https://leetcode.cn/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/)
- 1755. 最接近目标值的子序列和 #hard #折半枚举
    - 给定一个数组, 要求找到一个子序列, 它的和最接近目标值. 返回这个最小 abs
    - 复杂度: 长度为 len<=40. 直接暴力枚举的复杂度为 O(2^n) 会超时.
    - 思路: 折半枚举. 先枚举前一半数组的子序列可能组成的和, 排好序 sums. 然后再枚举右侧一半的和, 然后和 sums 匹配, 二分找到最接近目标的

