还没过的: 1016...
直接看洛谷的列表即可.

- 洛谷综合题单: <https://github.com/SFOI-Team/luogu-problem-list>


## 入门

- P1014 [NOIP1999 普及组] Cantor 表 #入门
    - Georg Cantor 证明了有理数是可枚举的. 构造如下的表, 按照回形的方式进行排列: 1/1; 2/1, 1/2; 1/3, 2/2, 3/1;... 问其中的第N个分数是什么
    - 思路1: 枚举, 区分奇偶
        - 显然, 每一斜列中的分数的分子分母之和相同, 分别是 2,3,4..., 包含的个数为 1,2,3...
        - 因此, 前n组的数量为 n(n+1)/2
        - 要求这一序列中的第N个数字, 只需要找到这一数字在第i组中, 也即满足 (i-1)i/2 < N <= i(i+1)/2 的组数i, 这个数字是其中的第 N - (i-1)i/2 个元素
        - 而根据排列方式, 可知偶数组按照右上到左下的顺序排列, 第i组的第x个分数为/坐标为 (x, i+1-x); 奇数组则相反.
- P1035 [NOIP2002 普及组] 级数求和 #入门
    - 对于调和级数 S(n) = 1 + 1/2 + 1/3 + ... + 1/n. 现给定一个整数k, 问 S(n) > k 的最小n.
    - 限制: k<=15
    - 思路1: #暴力 模拟
        - 复杂度:
            - 若按照naive的缩放, 对于因子 1/2, 不考虑首位的1, 可以通过 1,2,4,8.. 个元素之和得到, 这样的话时间复杂度约为 O(2^(2k)) 似乎不够
            - 但实际上在 k=15 的时候答案在 1e7 级别
            - 实际上, 按照欧拉推导过程, 调和级数之和的增长率为 e, 这样是符合要求的. 见 [here](https://www.luogu.com.cn/blog/Loner-Knowledge/Solutions-P1035)
- P1046 [NOIP2005 普及组] 陶陶摘苹果 #入门
- P1304 哥德巴赫猜想
    - 哥德巴赫猜想：任一大于 2 的偶数都可写成两个质数之和. 现在给定一个整数n, 写出 4,6,...n 的第一个因子最小的分解式 (例如10=3+7 而非 5+5).


## 普及-

- P1002 [NOIP2002 普及组] 过河卒 #普及-
    - 过河卒要从 (0,0), 走到 (m,n), 只能向右向下. 有一个马在位置 (x,y), 注意走的时候不能经过马以及马一个可跳到的位置. 问有多少条路径
    - 思路1: #DP
        - 递推公式: 当 (i,j) 可以走时, 有`dp[i][j] = dp[i-1][j] + dp[i][j-1]`, 否则为 0.
- P1003 [NOIP2011 提高组] 铺地毯 #普及-

## 普及/提高-

- P1017 [NOIP2000 提高组] 进制转换 #进制 #math
    - 相较于一般情况下的正数base进制, 这里给定一个数字n, 要求转为 -R 进制
    - 限制: -R的范围 [-20, -2], 所给数字绝对值范围 37336
    - see: [Negative base](https://en.wikipedia.org/wiki/Negative_base#Calculation)
    - 观察: 例如以 -2 为base, 则不同因子的大小分别为 1, -2, 4, -8,...
        - 注意到, 只用第一项可以构成1, 用前两项可以新构成-1...-2, 用前三项可以新构成2...5, 前四项可以新构成-3...-10
            - 可以表示的范围为 [0,1]长2, [-2,1]长4, [-2,5]长8, [-10,5]长16, ...
        - 每多用一个因子, 可以在正数/负数上多一些表示空间. 并且正好长度n的数字可以表示 `base^n` 个数字
        - 比较正数base, 可表示的范围长度是一样的, 不过只能在正数范围内增长.
    - 思路1: 有标准的流程
        - 对于待转换的数字n, 我们每次找到满足 `n/base = n'...r`, 其中保证余数r为最小正数. 重复直到商n'为0. 这样, 所得的余数反向排列就是需要的-R进制表示.
        - 为什么要求余数为正? 因为我们最近的数字表示都是用的正数.
        - 算法的正确性: 直观理解, 每次除base的过程中, 商的正负号每次都发生变化; 并且每间隔两次的绝对值都在减小, 正好落在上述观察的区间之内.
    - 总结: 从直观上理解了负base的基本操作, 对于转换算法没有进行证明.
- P1019 [NOIP2000 提高组] 单词接龙 #暴力 DFS
    - 给定一组单词, 每个词最多用两次, 接龙要求前后缀匹配但不能包含 (例如 at 后不能接 attention, 事实上这样就没用了, 同样更长的覆盖也是浪费的). 问给定一个起始字符最长的结果.
    - 限制: 单词数量 20, 但长度等限制没说清楚
    - 思路1: #预处理 之后暴力 #DFS
        - 看到题目说「不保证存在靠谱的做法能通过该数据范围下的所有数据」, 也就不分析复杂度直接暴力DFS了
        - 具体而言, 计算所有单词之前的匹配长度, 然后用一个全局数组记录使用情况 (因为最多可以用两次)
- P1103 书本整理 #逆向 #题型
    - 基本题型就是, 给定一个长度为n的序列, 从中抽去K个元素, 要求所得结果的「不整齐度」最小, 这里分数的定义为, 相邻元素的差的绝对值之和.
    - 限制: K<n<100
    - 提示: 感觉像是DP的题, 但是「正向」考虑每次抽去一本书, 递推关系比较难得到; 此时, 「逆向」考虑按照顺序放置 n-K 本书, 累加score更为简单.
    - 思路1: #逆向
        - `f[i][j]` 表示从前i本中选取j本, 并且第i本一定被选择时的最小分数, 需要满足 `i>=j` 其中i从1开始计数
        - 递推: `f[i][j] = min{f[k][j-1] + score(k, i)}` 这里枚举的k表示从前k本中取 j-1 本, 并且其中最后的是第k本; score表示 (k,i) 两本书相邻的分数 `abs(weight[k]-weight[i])`
            - 显然需要满足 `k>=j-1`, 这里的k也是从1开始
        - 答案: `min{f[...][N-K]}`
        - 复杂度: 如果不会与上面的min操作进行优化, 则复杂度为 `O((n-K)^2*n)`. 在计算的时候维护一个 (k,minScore) 元组的话, 可以进一步优化到 `O((n-K)*n)` 级别; 不过一开始写的 v0 没有算明白下标错了 后面用了naive的方式直接过.
        - 这题需要注意下标防止越界和出错.
    - 总结: **对于这种递推关系比较复杂的 #DP 题, 可以在纸上画出依赖关系, 推导出递推公式 (注意下标)**; 而不知一上来就写代码, 很容易乱掉!
- P1106 删数问题
    - 给定一个正整数, 删去其中的k位, 要求结果最小.
    - 约束: 位数不超过 250
    - 思路1: #单调栈
        - 从左往右遍历, 维护一个单调递增栈即可.
        - 注意: 本题允许数字有前导零, 例如 20018 2 的答案为 1.

## 普及+/提高

- P1004 [NOIP2000 提高组] 方格取数 #提高
    - 有一个 (N,N) 的grid, 包含一些分数, 可以两次从 (1,1) 走到 (N,N), 方向只能向下向右, 问两条路径最多能够得到分数和为多少.
    - 限制: N<=9
    - 思路1: 四维 #DP
        - 注意: 从左上到右下的路径长度是固定的 2N-2; 考虑两个人「同时从起点出发走向终点」, 某一时刻两人距离起点的曼哈顿距离是固定的,
            - 因此, 不会出现B在时刻t2到达A在时刻t1!=t2的所在点的情况. 根据这一性质, 可以避免重复记分的问题.
        - 因此, 用 `f[a][b][c][d]` 表示A,B分别在 (a,b) 和 (c,d) 的最大分数和.
        - 递推公式: `f[a][b][c][d] = max{f[a-1][b][c-1][d], f[a-1][b][c][d-1], f[a][b-1][c-1][d], f[a][b-1][c][d-1]} + score{(a,b), (c,d)}`,
            - 其中前一项是上一状态的最大分数(两两组合), 第二项是当前时刻的得到分数, 注意避免 (a,b)==(c,d) 重复记分.
    - 思路2: 实际上利用上述性质, 可以优化到三维 #DP, 参见 P1006
- P1006 [NOIP2008 提高组] 传纸条 #提高
    - 给一个 (M,N) 的网格, 从 (1,1) 两次走到 (M,N) 的不相交路径, 使得分数和最大.
    - 约束: M,N <= 50
    - 思路1: 棋盘的四维 #DP
        - 注意复杂度: 本题的数字较为宽松, 复杂度`O(M^2*N^2)` = 50^4 大概在 10^7 级别, 可以过
        - 状态: `f[a][b][c][d]` 表示某一时刻两条路径分别到达 (a,b),(c,d) 的分数和.
        - 递推:  `f[a][b][c][d] = max{f[a-1][b][c-1][d], f[a-1][b][c][d-1], f[a][b-1][c-1][d], f[a][b-1][c][d-1]} + score(a,b)+score(c,d)`, 这里的路径要求满足不相交.
        - 如何满足不相交?
            - 正如 P1004 中所说, 由于我们考虑的是 「同时」移动, 因此满足距离相等, `a+b==c+d`. 为了保证不相交, 事实上只需要 `a!=c` 即可 (此时两条路径相交了).
            - 事实上, 在本题设下, 可知两条路径一个在右上一个在左下, 不妨设第一条路径为上面的那一条, 则时刻都满足 `a<c and b>d`.
        - 注意: 由于上面的约束, 我们不会遍历到 (m,n,m,n) 节点, 因此答案是 (m-1,n, m,m-1) 的值!
    - 思路2: 三维 #DP
        - 相较于四维的, 利用每时刻距离相同的性质, 枚举时刻/距离, 可以将DP化简到三维. 空间复杂度下降了.
        - 状态: `f[t][a][c]` 表示两条路径时刻 `t` 到达 (a,) 和 (c,d) 的分数和.
        - 递推公式: `f[t][a][c] = max{f[t-1][a][c], f[t-1][a][c-1], f[t-1][a-1][c], f[t-1][a-1][c-1]} + score(a,b)+score(c,d)`, 这里的路径要求满足不相交.
            - 例如, max第一项表示A从 (a,t-1-a) 到 (a,t-a), B从(c,t-1-c) 到 (c,t-c); 注意, 在四种情况下, 所加的分数都是 (a,b), (c,d)
        - 约束:
            - 为了满足坐标合法, 需要满足 `0<=a<=m-1 and 0<=t-a<=n-1` (因为要取用 `grid[a][t-a]`), 因此有 `max(t-n+1, 0) <= a,c <= min(t, m-1)`
            - 另外注意max中的部分可能不合法, 通过加哨兵简化判断
            - 同样, 为了不相交, 我们可以假设 `a<c`;
        - 最后返回 `f[m+n-3][m-1][m]` 注意, 这里的路径长度为 (n-1) + (m-2) 因为不会遍历到最右下角的点.
        - 复杂度:`O((M+N)*M*M)`
    - 总结: 对于这类棋盘DP问题, 需要注意DP矩阵的维度和访问范围. 相较于naive的思路1, 思路2复杂度上更胜一筹, 但是对于坐标合法的判断复杂了很多.
