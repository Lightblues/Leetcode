
参见 [tarjan算法 割点割边强联通 算法讲解&模板 自用整理](https://blog.csdn.net/qq_19895789/article/details/89144975)

在具体实现Tarjan算法上，我们需要在DFS（深度优先遍历）中，额外定义三个数组 `dfn[]，low[]，parent[]`

- dnf数组
    - 下标表示顶点的编号，数组中的值表示该顶点在DFS中的遍历顺序(或者说时间戳)，每访问到一个未访问过的顶点，访问顺序的值（时间戳）就增加1。子顶点的dfn值一定比父顶点的dfn值大（但不一定恰好大1，比如父顶点有两个及两个以上分支的情况）。在访问一个顶点后，它的dfn的值就确定下来了，不会再改变。
- low数组
    - 下标表示顶点的编号，数组中的值表示DFS中该顶点 **不通过父顶点能访问到的祖先顶点中最小的顺序值**（或者说时间戳）。
    - 每个顶点初始的low值和dfn值应该一样，在DFS中，我们根据情况不断更新low的值。
    - 假设由顶点U访问到顶点V。当从顶点V回溯到顶点U时，
        - 若 `dfn[v] < low[u]` 则更新 `low[u] = dfn[v]`
        - 如果顶点U还有它分支，每个分支回溯时都进行上述操作，那么顶点low[u]就表示了不通过顶点U的父节点所能访问到的最早祖先节点。
- parent数组
    - 下标表示顶点的编号，数组中的值表示该顶点的父顶点编号，它主要用于更新low值的时候排除父顶点，当然也可以其它的办法实现相同的功能。

## Leetcode

- 1568. 使陆地分离的最少天数 `hard` 找割点
- 1192. 查找集群内的「关键连接」 `hard` 找连通分量之间的边 (桥)
