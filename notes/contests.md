# 周赛笔记

## 周赛 260-300

### 260

- 2016. 增量元素之间的最大差值
- 2017. 网格游戏
    - 给定一个 2 x n 的网格, 每个格子有一些分数; 两人只能向右或向下从左上角走到右下角. 第一个人的目标是让第二个人剩余可以吃到的分数最小, 求最小分数.
    - 遍历. 注意 **分析边界**
        - 首先分别计算上下两行从右往左和从左往右的累计和, 在前后加两个哨兵简化判断. 因此 up,down 的长度为 n+1
        - 然后, 假设第一个人从第i个位置往下走(从1开始), 则第二人可以得到的分数为 上半部分的 i+1,...,n, 或者下半部分的 1,...,i-1
        - 对应到这里的两个累计和, 分别是 up[i+1], down[i]. 因此更新 `res = min(res, max(up[i+1], down[i]))`
        - 显然遍历范围为 `range(0, n)`
- 2018. 判断单词是否能放入填字游戏内
    - 给定一个网格, 三种情况: ' ' 表示为空, '#' 表示无法仿制, 还可能已经填入字母.
    - 要求判断一个单词是否能放入填字游戏内. 条件: 1. 方向 上下左右都可(可以从右往左); 2. 边界上不能为空或其他字母, 也即只能是 '#' 或者网格的边界; 3. 字母匹配.
    - 重点: **条件和边界判断**
        - 自己的实现比较乱, 定义了一系列的函数, 贵在比较清楚;
        - 然后又抄了 [here](https://leetcode-cn.com/problems/check-if-word-can-be-placed-in-crossword/solution/mei-ju-liang-ge-zhi-jian-de-zi-fu-by-end-pjq1/) 的解法, 思维难度上大了些. 需要注意, go和Python 中, **在循环内部对于循环变量修改是不同的**, Python中修改不会影响结果! 而go中则是可以进行赋值的.
- 2019. 解出数学表达式的学生分数
    - 给一个只有 +* 运算和 0~9 数字的表达式, 对于不同的答案赋予分数. 1. 正确为5, 2. 因为运算顺序导致的错误, 分数为2, 3. 其他0分.
    - 因此, 核心问题是 遍历所有运算顺序, 给出所有可能的结果.
    - 思路一: **分治 + 记忆化**
        - 利用递归实现分治. 结合 lru_cache 实现. 由于这里的所有数字和运算符都是一个字符的, 解析起来非常方便 (表达式长度一定为奇数).
        - 复杂度分析
            - 注意到, 这里随意更换运算顺序, 至少是一个指数级别的复杂度!
        - 例如对于表达式 `"4+8*8+8+8*8+4*4+8*4+8*8+8*8+8"`, 其不同答案的数量可以达到 `86301`; 直接排列组合在 LC上会超时.
            - 题目中给出了限制 0 <= answers[i] <= 1000 (正确答案在1000以下), 因此可以对于两侧给出的答案进行过滤, 这样不同答案的数量最多只有 `141`. —— 剪枝

### 268

- 2078. 两栋颜色不同且距离最远的房子
- 2079. 给植物浇水
    - 模拟法
- 2080. 区间内查询数字的频率 `中`
    - 需求是查询子数组 arr[left...right] 中 value 的 频率; 考虑到查询数量可能较大, 因此设计一个数据结构存储数据分布信息
    - 解法: 用 map 保存数字所出现的位置列表, 从而查询时候可以用**二分查找**.
        - Python 可以直接用 `bisect.bisect` 好方便!
- 2081. k 镜像数字的和 `难`
    - 找到前 n 个, 在 10进制 和k进制下均为回文数的数字, 返回其最大值
    - 注意题目要求, 2 <= k <= 9, 1 <= n <= 30 当k和n均取较大值时会超时(约10**10量级); 因此重点是如何所见搜索空间.
        - 由于是回文数, 因此只需遍历前半部分即可, 注意可生成奇数或偶数长度的, 例如 1234 -> 1234321 或 12344321;
        - 另外, 每次遍历 [1,9], [10,99]... 的数字, 对于j位十进制数, 可分别生成 2j-1, 2j 位十进制数

### 269

- 2089. 找出数组排序后的目标下标
- 2090. 半径为 k 的子数组平均值
- 2091. 从数组中移除最大值和最小值
    - 滑动平均
- 2092. 找出知晓秘密的所有专家 `难`
    - 包括 (x, y, time) 的三元组, 若 x 和 y 中某一个知道了「秘密」, 则会进行传播; 要求最后知道「秘密」的所有人
    - 解法一: **构建图**, 传播
        - 按照时间排序, 难点在于判断同一时间的多人传播关系 —— 简单的方案是构建图
        - 解法的具体实现: 利用 edges 字典记录连接关系, 建立图后, 利用 一个 `deque` 记录所有激活节点, 迭代直至队列空
    - 解法二: **并查集**

### 270

- 2094. 找出 3 位偶数
    - 给你一个整数数组, 找出所有的三位偶数(也即要求首位不为 0), 顺序输出(直接排序即可)
    - 简单题 (也可根据提示的范围知道不复杂) 别想太多, 直接暴力遍历即可; 为了避免重复可以用 set()
- 2095. 删除链表的中间节点 `中`
    - 长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始）
    - 解法一: 快慢指针即可, 可以在最开始加上一个「哨兵」
- 2096. 从二叉树一个节点到另一个节点每一步的方向 `中`
    - 找到二叉树两个节点之间的路径
    - 解法一: 直接 DFS 找到两个点从 root 出发的路径, 除去公共路径即可
- 2097. 合法重新排列数对 `难`
    - 给定 pairs(表示区间), 重新排列要求排列后每个区间首尾数字相同; 核心在于理解「[欧拉通路](https://oi-wiki.org/graph/euler/)」, 将问题转换
    - `Hierholzer 算法`: 首先很容易想到, 若仅为「**半欧拉图**」(即存在两个奇数度数节点), 可以确定开始和结束的数字, 否则为「欧拉图」随便选择初始数字/节点即可.
        - 若随便选择一条边, 则可能走到「死路」, 注意此时剩下的图构成了一个「欧拉图」 —— 可以用DFS探索
        - 因此, 1. 每次选择一条边, 在图上删去这条边; 2. 递归; 3. 记录这条边. 注意这里的边是在遍历之后加入记录的 (也即是逆序的, 最后要再逆序输出), 这样可以保证可能漏过的「欧拉图」在此之前被遍历.
    - 参见 「332. 重新安排行程」「753. 破解保险箱」
    - 332 重新安排行程, `难`
        - 区别在于, 需要返回所有的通路中, 字母排序最小的那一个 —— 也即, 每次应该选择较小的那一个节点
        - [solution](https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/) 非常清楚
    - 753. 破解保险箱, `难`
        - 密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。要求返回一个最短字符串, 其子字符串包括所有可能的密码.
        - 关键在于将其转化为一个规范的欧拉通路问题: see [here](https://leetcode-cn.com/problems/cracking-the-safe/solution/po-jie-bao-xian-xiang-by-leetcode-solution/) 官方解答有点fancy
        - 解法: 转换为**欧拉通路问题**
            - 简言之, 要求的是 n 长序列, 都可将其看成 n-1长序列加上 0~k-1 的数字. 因此, 可以构建一个图, 节点为所有的 n-1长序列, 其第i个出边就是在最后加上数字i并去除第一位数字, 跳到相应的节点上.
            - 例如, 节点u的第v的出边就跳转到数值为 u*k % (k**(n-1)) + v 的节点上.
            - 可知, 这样构造的图, 每个节点都有 k条出边和入边, 共可代表 $k^{n-1} * k$ 个不同的数字, 正好对应了所有可能的密码.
            - 显然, 这张图是欧拉图, 并且可基于一个欧拉回路对应一个题目所要求的字符串.

### 271

- 2105. 给植物浇水 II
    - 模拟法即可
- 2106. 摘水果 `难`
    - 在一个无限的 x 坐标轴上, 分布一定的水果, 给定 startPos 和可以移动的步数 k, 计算可以拿到的最大数量
    - 题型: 其实就是给定一个累加和, 探索所有可能的范围内的最大值; 问题在于如何在离散存储的数组中找到对应的元素
        - 存储方式: 例如对 `[[2,8],[6,3],[8,6]]` 水果分布而言, 记录位置 `pos=[-Inf, 2,6,8]` 和 累计和 `[0,8,11,17]`
        - **二分查找**. 要注意 **边界情况**, 左边应该是 `bisect.bisect_left`, 而右边是 `bisect.bisect_right`, 注意函数返回的是待插入的 index, 因此最终能采集的水果数量为 `cumsum[rindex-1] - cumsum[lindex-1]`
        - 错误记录: 注意, 先往左边走和先往右边走所能达到的范围是不一样的! 因此两侧的情况都应该考虑到.

### 272

- 2110. 股票平滑下跌阶段的数目
    - 一次遍历即可
- 2111. 使数组 K 递增的最少操作次数 `难`
    - 如果对于每个满足 `k <= i <= n-1` 的下标 i ，都有 `arr[i-k] <= arr[i]` ，那么我们称 arr 是 K 递增 的。
    - 给定一个数组和 k,要求找到使得这个数组 k递增的最小修改次数.
    - 问题可转化为: 寻找一个数组中的最长递增序列, 参见 300 题 [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/)
        - 思路 1: DP, 定义 `dp[i]` 为 第 i 个数字结尾的最长上升子序列的长度, 注意 第 i 个元素必须被选中; 递推公式 `dp[i] = max(dp[j]) + 1`, 其中的 j 要求 `nums[j]<=nums[i]`
            - 时间复杂度 $O(n^2)$
        - 方法二：贪心 + 二分查找
            - 维护一个数组 `d[i]` ，表示**长度为 i 的最长上升子序列的末尾元素的最小值**, 用 len 记录目前最长上升子序列的长度. 注意到数组 d 是单调递增的
            - 我们依次遍历数组 nums 中的每个元素，并更新数组 d 和 len 的值。如果 `nums[i]>d[len]` 则更新 `len = len + 1`，否则在 `d[1…len]`中找满足 `d[i−1]<nums[j]<d[i]` 的下标 i，并更新 `d[i]=nums[j]`。
            - 由于是递增数列, 可以用二分搜索
            - 时间复杂度 $O(n log(n))$

### 273

- 2120. 执行所有后缀指令
    - 模拟机器人动作即可
- 2121. 相同元素的间隔之和 `中`
    - 给定一个数组, 计算其中相同元素所在的 index 之差, 返回所有这些距离的和
    - 用一个 defaultdict(list) 记录各个元素出现的位置.
    - 问题转化为对于一个数字出现的位置, 计算各个位置的 dist 和.
        - 注意数据量, 直接暴力遍历复杂度为 $O(n^2)$ 会超时
        - 思路1: 观察相邻两个元素相差的(子距离数量), 可得递推公式 `dp[i+1] = dp[i] -(n-2i-2) * (arr[i-1]-arr[i])`
        - 思路2: 计算 cumsum, 则 i 处的距离和为 `(cumsum[-1]-cumsum[i] - arr[i]*(n-1-i)) + (cumsum[i]-cumsum[0] - arr[0]*i)`
- 2122. 还原原数组 `难`
    - 就是对于一个数组 arr, 用一个正整数 k, 分别生成两个数组, `lower[i] = arr[i] - k, higher[i] = arr[i] + k`. 要求给定这两个数组的混合, 还原 arr
    - 注意看约束条件, 数组大小最多为 `1000` 所以暴力搜索即可, 题目只是比较繁琐
        - sort, 得到可能的 k
        - 用 `indexRecord` 记录每个数字对应的位置
        - 关键在判断一个 k 是否满足条件. 这里用了一个 `used` 记录每个所对应的元素所在位置, 遍历 nums 后, 若 `sum(used) == n` 则说明 k 满足条件
    - see [here](https://leetcode-cn.com/problems/recover-the-original-array/solution/huan-yuan-yuan-shu-zu-by-leetcode-soluti-nizi/)

### 274

- 5970. 参加会议的最多员工数 `难`
    - 每个人只有一个喜欢的人, 要求安排坐圆桌, 每个人左右要有他喜欢的人, 最大的可安排人数
    - 比较容易想到, 问题主要转化为求这样的有向图上的最大环,
        - 特殊情况是两个互相喜欢的人, 他们相互满足了要求, 因此左右可以有一条「喜欢人的链」, 并且左右的人都是满足的; 因此, 这种大小为 2 的环一个桌上可以安排多个
        - 参见 [这个题解](https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/solution/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/), 这种图叫做 **内向基环树 (pseudotree)**
    - 所以核心问题在于如何在 pseudotree 中找环, 比赛中的尝试没有想到如何「**剪枝**」超时了; 实际上, 可以通过一次 **拓扑排序** 剪掉所有的分支 (最后留在图上的点的度数最大为 1)
        - 具体实现上, 维护一个入度为 0 的队列, 对其喜欢的人的入度 -1, 如果减到了 0 则继续加入队列;
        - 这样, **拓扑排序后最终剩下的点都是成环的**(入度为 1).

### 275

- 5976. 检查是否每一行每一列都包含全部整数
- 5977. 最少交换次数来组合所有的 1 II
    - 滑动平均
- 5978. 统计追加字母可以获得的单词数
    - 注意审题
- 5979. 全部开花的最早一天
    - 两个数组, 分别是 播种 和 开花 所需的时间, 要求使得所有花都开放的最小时间
    - 题目给了干扰: 将一种花分成两次播种没有意义, 因为两者总的播种时间是一样的, 因此在过程中两种花都不会提早开花.
    - 于是可以化简为, 给依次播种的花进行排序
    - 可知, 总的播种时间是一定的, 目标在于减少开花所需时间. 因此每次根据开花所需时间排序, 选择需要最长时间的那种即可.

### 276

- 5980. 将字符串拆分为若干长度为 k 的组
- 5194. 得到目标值的最少行动次数
    - 给定一个目标数, 从 1 开始 +1, *2 两种操作, 限定了倍乘的次数 maxDoubles
    - 贪心, 从 target 往下 /2
- 5982. 解决智力问题
    - 给定一系列的题目, questions[i] = [pointsi, brainpoweri], 你选择做某一题的代价是只能跳过后面 brainpower 题
    - DP, 从后往前, 记录从该位置往后的最大解, 递推公式 `dp[i] = max([dp[i+1], point+dp[i+skip+1]])`
- 5983. 同时运行 N 台电脑的最长时间
    - 给定一组电池 batteries, 每个电池可以给一台电脑运行一定的时间. 可以把一个电池替换给不同的电脑, 要求让所有电脑同时运行的最长时间
    - 这里的限制条件为电量最大的 n 个电池, 小的电池看作对它们的补充.
    - 注意到: 一个电池的电量可以以**任意的比例**分到若干块电池上.
    - 因此, 可以将最大的 n 个电池看成一个「阶梯」, 其余的小电池理解为在这个池子里注水, 求高度

### 277

- 2148. 元素计数
- 2149. 按符号重排数组
- 2150. 找出数组中的所有孤独数字
- 2151. 基于陈述统计最多好人数 `hard`
    - 两种角色: 好人只说真话, 坏人可能真也可能假
    - 给定一个矩阵表示每个人的陈述 (0,1,2 分别表示 坏人, 好人, 未判断), 要求计算好人最多可能数量
    - 注意到, **此题中坏人的陈述毫无信息量**!
    - 方法一：使用状态压缩枚举所有可能的情况
        - [here](https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/solution/ji-yu-chen-shu-tong-ji-zui-duo-hao-ren-s-lfn9/)
        - 用一个长度为 n 的二进制数 mask 表示好人坏人情况, 针对 mask 所表示的好人坏人分布, 判断是否合法
            - 冲突的情况只会出现在好人 i 的陈述中 (mask[i]=1)
            - 当 `s[i][j]=0 and mask[j]=1`, 或 `s[i][j]=1 and mask[j]=0` 时冲突
        - 实现一个 `check(mask)` 函数判断是否冲突
        - check 复杂度最大为 n^2, 枚举复杂度为 2^n, 因此总体复杂度为 `n^2 2^n`, 这里用位运算所以比较快?
    - 方法二: 回溯
        - 暴力枚举每个人是好人或坏人, 注意剪枝!!

### 278

- 2154. 将找到的值乘以 2
- 2155. 分组得分最高的所有下标
- 5994. 查找给定哈希值的子串
    - 定义一个字符串的哈希值 `hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m`
    - 给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 `k` 的 子串 sub ，满足 `hash(sub, power, modulo) == hashValue` 。
    - 字符串长度为 e4, 如果暴力遍历, 当所要求的 k 数量级接近是复杂度是 e8, 会超时
    - 方法一: **滑动平均**, O(n)
        - 给出的哈希计算函数是一个等比求和数列，两者可以通过减去首元素，除以power再加上新元素的power的k-1次方计算。
        - 但是 **除法不满足取余的恒等性**。因此需要倒序，减去当前的值，乘以power再加上新元素的值。(乘法满足取余恒等)
        - 参见 [here](https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/cha-zhao-gei-ding-ha-xi-zhi-de-zi-chuan-fi8jd/)
- 2157. 字符串分组 `hard`
    - 每个字符串包括了一组不相同的字符 (比如 cde), 定义两个字符串「相连」: 其一可以通过 添加/删除/替换(替换成相同字符也可, 即包括相同字符集合的两字符串相连) 一个字符得到另一个字符串。
    - 定义组: 如果一个字符串与该组中的任一字符串相连，则这个字符串属于该组。
    - 给一组字符串, 计算有多少个不同的组, 以及最大组包括的字符串数量。
    - 方法一：状态压缩 + 广度优先搜索
        - 显然是求连通分量的数量, 问题在于如何构建图? 如果是两两计算复杂度为 O(n^2) 超时;
        - 像这类题, 可以从每一个节点出发, 构造其所有可能相连的边, 例如这里就是按照「相连」的定义, 增删或者替换所有可能的字符, 这样复杂度为 O(nD^2), 其中 D 为字符字典大小
        - 具体而言, 为了进行图遍历, 用一个 used 集合记录所有遍历过的节点, queue 来维护当前进行BFS, 对于所有的节点进行遍历.
        - 状态压缩: 如何表示一个(小写字母)字符集合? 01编码转化为数字以进行压缩. 这样的好处还有方便表示相连边, 参见 `get_adjacent`
        - 参见 [here](https://leetcode-cn.com/problems/groups-of-strings/solution/zi-fu-chuan-fen-zu-by-leetcode-solution-a8dr/)

### 279

- 6000. 对奇偶下标分别排序
- 6001. 重排数字的最小值
    - 给一个数字 (可能为负数), 重拍求最小值
- 6002. 设计位集 `medium`
    - 能够快速实现 fix(设置某一位为1), unfix, flip(翻转每一位), add, one(至少一个非零), count(非零位数量) 操作
    - 尝试直接用列表存储, 超时了, 可能是 flip, add, one, count 复杂度较高
    - 优化为 位存储+一个变量intcount存储非零位数量, 从而优化时间复杂度; 可以重新看看**位运算**使用技巧
- 6003. 移除所有载有违禁货物车厢所需的最少时间
    - 一个 01 序列表示违禁物品, 前后移除一辆火车代价位 1, 移除中间的一辆代价为2, 求移除所有违禁货车最小代价
    - 思路一: 从左边和右边非别累加计算单面的最小代价, 加起来求最小 (其实就是在不同的点分割).
        - 注意 更新公式(DP): 当 `s[i+1]=='1'` 时 `dp[i+1] = min(dp[i]+2, i+1)`, 因为若从左边全部移除的代价是 i+1, 从中间取走的代价是 +2
        - 为了计算的方便在头部加一个 [0]; 注意到在点 i 处分割的总代价为 `dp1[i]+dp2[i+1]`, 正好错位加和. 参见 [here](https://leetcode-cn.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/solution/qian-hou-zhui-fen-jie-dp-by-endlesscheng-6u1b/)

### 280

- 6004. 得到 0 的操作数
- 6005. 使数组变成交替数组的最少操作数
    - `[2,1,2,1,2,1,2]` 的形式, 要求奇数和偶数位置的数字不同
    - 分别对于 nums[0::2] 和 nums[1::2] 计数, 注意边界情况 (`len(collections.Counter(nums[0::2])) == 1`)
- 6006. 拿出最少数目的魔法豆
    - 给定一组袋子, 要么拿空, 要求最后剩下来的非空袋子里的豆子数量相同
    - 排序, 想像成一个阶梯, 最后留下来的就是一个矩形; 转化为遍历求矩形最大面积
- 6007. 数组的最大与和
    - 有编号为 1,2,...,numSlot的篮子, 要求把一个长度为 n 的数组放入篮子中, 每个篮子最多放两个数字!
    - 定义放置的分数为, 数字和篮子编号与 `nums[i] & (assign[i]+1)`, 其中 assign 表示 第 i 个数字放在第 assign[i] 个篮子中
    - 方式一: 暴力回溯
        - 用一个 records 数组保存每个篮子中球的数量
        - 回溯函数 `dfs(idx, curSum, curMax)`, 遍历 idx 放置每一颗球

### 281

- 6012. 统计各位数字之和为偶数的整数个数
- 6013. 合并零之间的节点
- 6014. 构造限制重复的字符串
    - 给定一组字符, 要求构造字典序最大的字符串, 限制每个字符最多连续的次数.
    - 当两个字符串长度不同时, 先序比较前面部分, 仅当 min(a.length, b.length) 时算较长的字符串字典序较大.
    - 思路
        - 根据题意, 应该是按照字典序, 尽量把大字符连续放在前面, 之间插入一个次大字符即可, 即 bbbabbba... 这样的形式(repeatLimit=3)
        - 关键在构造方法:
            - 每次取最大字符, 后面添加一个次大字符即可! 终止条件是没有次大字符了.
            - `bbba` 这种形式为一次循环所构造的, 当 a 没有的时候即终止 (终止条件!)
- 6015. 统计可以被 K 整除的下标对数目
    - 给定一个数组 nums 和一个正整数 k, 返回满足条件的下标对 `(i, j)` 的数目, 要求 `nums[i] * nums[j] % k == 0`, 即两数之积能够被k整除.
    - 思路
        - 考虑 `n1*n2 % k == 0` 的条件: n1和n2 和 k 的最大公约数之积能被k整除, 即 `gcd(n1, k) * gcd(n2, k) % k == 0`
        - 由于 k 的因子是有限的, 就可以对于 nums 中的数字分组. (Counter)
        - 对于一个组, 其中的数字与k的最大公约数都是 n1, 假设组大小为 len1
            - 考虑两种情况: 1. 其他组中能够能够配合n1的数字个数为 len2, 则交互共有 `len1*len2` 个数字; 2. 若 `(n1*n1)%k == 0`, 即自身就满足条件, 组内组合数为 `C(2,len1) = len1*(len1-1)/2`
        - 累计. 为了避免重复, 对于因子从大到小排序, 每组都和后边的因子比较
        - 注意: 特殊情况是 k==1

### 282

- 6008. 统计包含给定前缀的字符串
- 6009. 使两字符串互为字母异位词的最少步骤数
- 6010. 完成旅途的最少时间
    - 给一组公交车运行一轮的用时: `time[i]` 表示第 `i` 辆公交车完成 一趟旅途 所需要花费的时间。要求计算所有公交车运行至少 totalTrips 圈所需的最少时间。
    - 思路: 二分查找
        - 对于运行时间排序, 在一定区间内二分查找最短时间
        - 初始化: 考虑左边界, 假设所有车运行一圈都为最小的那一辆, 则最短时间 T 需要满足 `T//min(time) * n >= totalTrips`, 则最小为`T = min(time) * math.ceil(totalTrips/n)`
        - 这里复习一下二分: 循环 `l < r`, 每次查找的 `mid = (l + r) // 2` 有可能为 l. 因此在检查条件后, 根据是否满足分别设置 `r = mid, l = mid + 1` 从而保证不会死循环.
        - 具体而言, 这里要求最小的满足条件的数字, 则可以: 每次检查成功收缩右边界, 令 `r = mid`; 失败则拓展左边界 `l = mid + 1`, 从下一个点开始搜索.
        - 算一下这里的时间复杂度: 假设搜索长度为 L, 每次检查有效性复杂度为 O(n), 则总体为 `O(n * log(L))`, 其中长度约为 `L=totalTrips/n * timeSpan`. 本题中, 变量数量级为 `time[i]=totalTrips=1e7, n=1e5`, 可以看到主要复杂度在 `O(n)`
- 6011. 完成比赛的最少时间
    - 给定一组轮胎, `tires[i] = [fi, ri]` 表示第 `i` 种轮胎如果连续使用，第 `x` 圈需要耗时 `fi * ri ** (x-1)` 秒。
    - 同时给你一个整数 `changeTime` 和一个整数 `numLaps` , 表示换轮胎的时间和总圈数. 要求最短用时.
    - 思路: DP
        - 对于dp[i], 考虑两种情况: 1. 用一种轮胎, 则用时为 `f * (r**laps -  1) / (r-1)` (等比数列); 2. 递推, 则用时为 `dp[i] + dp[i-j] + changeTime` (j = 1...i-1).
        - 注意对于第一种情况, 次题中 numLaps=1e3, len(tires)=1e5, 直接暴力会超时. 因此需要对每一轮次可能达到最短时间的 tires 进行筛选,
        - 这里用了简单的策略: 计算换一个轮胎跑一圈的最短用时 `min0 = min(i[0] for i in tires) + changeTime`, 如果此时继续用轮胎i `i[0]*(i[1]**(laps-1))>= min0` 则不需要考虑了.

### 283

- 6016. Excel 表中某个范围内的单元格
- 6017. 向数组中追加 K 个整数 `medium`
    - 给一个数组, 请你向 `nums` 中追加 `k` 个 **未** 出现在 `nums` 中的、**互不相同** 的 **正** 整数，并使结果数组的元素和 **最小** 。
    - 思路一: 模拟. 遍历数组 nums, 并从 1开始递增 `inc` 表示下一个可能可以追加的数字, 累计数组中空的元素.
- 6018. 根据描述创建二叉树
- 6019. 替换数组中的非互质数
    - 对于数组定义一个操作: 任意两个相邻的非互质数 (最大公约数gcd != 1), 将它们替换为其最小公倍数 （Least Common Multiple，LCM）. 返回这样操作之后的数组.
    - 思路一: **栈模拟**
        - 一个数字只能和左右两边的数字合并, 并且 x,y,z 如果可以合并的话先后顺序无所谓. 因此可以合并一遍即可.
        - 因此可以用 **栈** 来进行模拟 —— 每次入栈后看它能消去到前面多少数字.
    - 第一时间应该想到 stack 的…… 不过自己写了一个函数, 尽量对于左右两边进行合并, 居然超时了? 复杂度应该是完全一样的...
    - 线性复杂度应该是没问题的, 还尝试了 `@lru_cache` 也过不了, 本地调试完全可以过 LC 不知道为啥不行.

### 284

- 6031. 找出数组中的所有 K 近邻下标
- 5203. 统计可以提取的工件
- 5227. K 次操作后最大化顶端元素
    - 给一个非空栈和可操作数量k, 要求返回执行这些操作后, 能够留在栈顶的最大值. (如果执行完 k 次操作以后，栈一定为空，请你返回 -1)
    - 两种操作: 1. 弹出栈顶元素; 2. 压入弹出的某一个元素.
    - 思路一: 讨论
        - 先考虑边界: 什么情况下最后栈为空? `len(nums)==1 and k%2==1`
        - 而在一般情况下, 对于k次操作, 我们可以在栈顶留下第 1,...,k-1 和 k+1 个元素 (从1开始). 需要对k和数组长度n的关系讨论.
        - 另外, 需要确保 nums[:k-1] 操作中 k-1 非负, 添加到边界条件中.
- 6032. 得到要求路径的最小带权子图
    - 给一张带权图, 给定三个点, 要求返回 **边权和最小** 的子图 (的边权和)，使得在这个子图中从 `src1` 和 `src2` 出发都可到达 `dest` 。如果这样的子图不存在，请返回 `-1` 。
    - 分析
        - 注意到, 双点出发求最短路径的情况, 可能出现共用一条路径的情况. (此时, 最小边权和为 `s1->u, s2->u, u->d` 三条路径之和, 而非 `s1->d, s2->d`). 需要判断这种情况出现的边界:
        - 简单判断, 假设两点的最短路径分别为 d1,d2, 则共用的路径长度不能超过 d1+d2.
        - 因此, 暴力来解, 可以先从 s1,s2 出发BFS, 然后(逆)从d出发进行长度约束为 d1+d2 的BFS.
        - 为了判断所有可能的中间节点, 需要记录正反向BFS过程中所有经过的点的路径长.
    - 思路一: BFS + 节点判断
        - 首先, 从src1和src2出发, 返回距离d和在这一范围内的节点集合(及其路径长); 分别用 dist1, dist2 两个map记录两个范围内所有点的距离.
        - 然后在逆图上进行长度 d1+d2 约束的BFS, 同样记录各个点的路径长 dist
        - 遍历三个字典交集, 取最短距离 `dist[u]+dist1[u]+dist2[u]`.

### 285

- 6027. 统计数组中峰和谷的数量
    - 首尾的不算, 相同数字算一个峰/谷. 例如 [2,4,1,1,6,5] 就有三个
    - 思路: 遍历, 模拟
- 6028. 统计道路上的碰撞次数
    - 给定一个字符串表示车辆方向. L, R, S 分别表示左右和停止 。每辆车移动时速度相同。相向碰撞 2分, 一个静止的1分; 碰撞后都静止; 求最后的分数。
    - 思路: 模拟. 注意一些边界讨论.
- 6029. 射箭比赛中的最大得分
    - 12个区域得分分别为 0...11; 如果 `ak >= bk` ，那么 Alice 得 `k` 分。如果 `ak < bk` ，则 Bob 得 `k` 分; 现在知道Alice的分布, 要求Bob得分最高的一种方式
    - 思路: 复杂度不高, 直接DFS即可
- 6030. 由单个字符重复的最长子字符串 `hard`
    - 给定一个字符串和一组查询, 每次查询会将`queryIndices[i]` 的字符更新为 `queryCharacters[i]`, 要求返回每次查询后, 字符串中保留的最大重复字符长度
        - 例如 `s = "babacc", queryCharacters = "bcb", queryIndices = [1,3,3]`, 将返回 `[3,3,4]`
    - TODO: 线段树

### 286

- 5268. 找出两数组的不同
- 5236. 美化数组的最少删除数
    - 定义美丽数组: (1) 长度为偶数; (2) 2i, 2i+1 位的数字不相同. 空数组也符合
        - 要求: 将一组数组转为美丽数组, 最少删除的数字个数
    - 思路: 贪心. 每遇到 **约束对** 不满足的情况, 这两个数字必然是相同的, 随便删除一个即可.
        - 若出现 [..., 1,1,2,2,3,3, ...] 的情况, 不管是前面删除使得三组相同数字处于不同的约束对, 还是删除最前面的 1, 效果是一样的.
- 5253. 找到指定长度的回文数
    - 要求得到长度为 l 的回文数中的第 k 个; 超出限制则返回 -1
    - 思路: 递归
        - 注意这里回文数数量限制有两种: (1) 内部回文数可以以0开始, (2) 回文数定义, 例如长度为3的最小回文数为 101. 可知, 长度为 1/2 的回文数数量为 9, 长度为 3/4 的回文数数量为 90; 内部回文数数量为 10, 100, 1000...
        - 因此, 实际上是一个「进制」问题, 可以用递归来解.
        - 需要注意: 题目中要求得到第 ith个回文数, 从1开始; 但是 **在进制的计算中, 必须应该从0开始**. 例如, 进制为10, 则要求得到第13个 (其实是12)回文数, 应该计算 `div(12, 10) = 1, 2`; 在本题中, 外部的数字从1开始, 因此需要再加上1, 也即 `222`
- 5269. 从栈中取出 K 个硬币的最大面值和 `hard`
    - 给定一组栈和可以取的硬币数量k, 要求取到的面值最大.
    - 例如给定 `piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7`, 最大应该为 706
    - 复杂度: 栈数量 n<=1000; 操作次数 k<=2000

### 287

- 6055. 转化时间需要的最少操作数
- 5235. 找出输掉零场或一场比赛的玩家
- 5219. 每个小孩最多能分到多少糖果
    - 给一组糖果, `candies[i]` 表示第i堆糖果有多少, 将其分给k个人, 糖果只能划分不能合并; 求最大.
    - 思路: 二分搜索. 用一个 `test` 函数判断分m个糖果是否可行; 在 [1, sum(candies)//k] 之间二分搜索.
- 5302. 加密解密字符串
    - 题目好长 Orz, 总而言之就是给一个 {key:value} 的映射, 将一个字符映射到长度为2的一个字符串, key不重复但是允许values重复. 然后 key->value 是加密, value->key 解密.
        - 有约束, **所有允许的原字符串仅包含在一个 len<=100 的dictionary中**. (反向思维!)
        - 要求是设计一个数据结构, 支持加解密操作, 最多调用200次.
        - 复杂度分析: keys, values 的长度 <=26, 给出的待解密的字符串长度 <=200; 最多调用200次.
    - 思路1: 模拟 (DFS+Trie)
        - 正常的思路可能是直接模拟; 然而考虑到解密环节的一对多情况, 暴力求解会超时!
        - 容易想到的改进是 DFS+Trie, 参见 [here](https://leetcode-cn.com/problems/encrypt-and-decrypt-strings/solution/by-class_-8pci/)
    - 思路2: 逆向思维
        - 这里给定了所有可能的原字符串 (并且数量很小), 所以要钻的空子就是预计算所有可能的加密结果.
        - 见 [here](https://leetcode-cn.com/problems/encrypt-and-decrypt-strings/solution/by-endlesscheng-sm8h/)

### 288

- 6037. 按奇偶性交换后的最大数字
    - 注意审题! (虽然这题设置有点奇怪) 是 奇偶性 相同的数字可以交换, 而不是 奇偶index
- 6038. 向表达式添加括号后的最小结果 `medium`
    - 在括号左右添加一对括号, 例如 `"12+34"` 变为 `"1(2+3)4"` 也即左中右三个元素的乘积, 要求最小化结果
    - 思路: 遍历两侧可以加入括号的index即可, 要注意边界情况有点烦
- 6039. K 次增加后的最大乘积
    - 给你一个非负整数数组 `nums` 和一个整数 `k`, 可以将k分配到数组元素上 (相加), 要求乘积最大.
    - 思路: intuition是填充最小的那些数字. 因此可以看作是 **阶梯水池蓄水** 的问题.
    - 注意复杂度: `nums.length, k` 为 1e5. 最开始遍历index时 (模拟蓄水过程), 每「上一个台阶」都修改整个序列 `nums[:index]`, 复杂度为 `O(n^2)` 会超时. 修改为记录遍历的终止位置 (最终蓄水高度) 后一次性修改.
- 6040. 花园的最大总美丽值 `hard`
    - 数组 flowers 代表每个花园的花数量, 数字 newFlowers, 可以分配到各个花园中. 花园的分数定义为:
        - 花的数量至少为 `target` 的花园为「完善的」, 每个花园有 `full` 分;
        - 剩余「不完善」的花园, 总共有 `min(num_flower) * partial`, 也即这些花园中 量最少的花数 * 一个分值.
    - 需要注意的是, 即使在可以完全填满的情况下, 也有可能不填满的分数更高. 因此比较繁琐需要遍历.
    - 思路0: 当时很繁琐的想法是, 先尽量尝试填出完善的花园, 然后利用剩余的花来提升其余花园的最少花数. 为此, 先对花园排序, 从右往左计算 `need_for_target` 为填满最大数量花园所需的花朵数; 从右往左 `need_for_partial` 累计「阶梯水池蓄水」所需数量 (将其余花园填到高度 flosers[i] 所需的数量).
        - 然后遍历所有可能的情况. 例如遍历 need_for_target 合法的 index, 然后用剩余数量 bisect `need_for_partial` 以尽量提升其余花园的最少花数.
        - 但是需要注意边界: 1) 本来所有花园都是满的; 2) 在 bisect 时需要考虑 `need_for_partial` 的边界. 当时没想好第一点结果错在了最后一个考验复杂度的用例上, 结果没查出错误.
    - 思路: 好吧, [官方](https://leetcode-cn.com/problems/maximum-total-beauty-of-the-gardens/solution/hua-yuan-de-zui-da-zong-mei-li-zhi-by-le-18d8/) 的解答也是这样的, 不过更简洁些.

### 289

- 6070. 计算字符串的数字和
- 6071. 完成所有任务需要的最少轮数
- 6072. 转角路径的乘积中最多能有几个尾随零
    - 给定一个矩阵, 一条「转角路径」最多出现一个转折, 求所有路径乘积的尾随零的最大数量.
    - 思路: 1) 显然, 路径越长越好, 所以折角的两条边可以直接到矩阵的边上. 2) 为了计算乘积的「尾随零」, 注意到0的数量完全取决于 2/5 因子的数量; 3) 因此, 分别计算行和列级别的前缀和, 然后遍历所有可能的折角.
- 6073. 相邻字符不同的最长路径
    - 给一棵树上的节点都定义一个 label, 要求返回树上一条相邻节点的label不同的最长路径的长度。
    - 思路: 正常 DFS 即可. 注意: 1) 最长路径可能在节点的子树中, 因此需要在遍历过程中更新全局变量; 2) 注意DFS返回: 「从该节点出发的子路径的最大长度」, 而全局维护的是「一条符合条件的路径的最大长度」, 注意区分.

### 290

- 6041. 多个数组求交集
    - 求给定的所有数组的交集. 思路: 直接调用 Python API 暴力解决
- 6042. 统计圆内格点数目
    - 每个圆通过 (x,y,r) 所定义, 要求计算这些圆所覆盖的整数点数量. 思路: 暴力遍历
- 6043. 统计包含每个点的矩形数目
    - 给定一组点所定义的矩形和一组点, 对于每个点, 要求判断包含该点的矩形的数量
    - 重点是数量级分析: `1 <= rectangles.length, points.length <= 5 * 10^4` 因此无法暴力判断
    - 注意这里的条件, (x,y) 中, `1 <= x <= 1^9; 1 <= y <= 100`, 因此, 构建 y2x, 分别排序即可.
    - 此时, 对于每一个点, 从 `recY >= pY` 的最多 100 个序列中进行 bisect 即可.
- 6044. 花期内花的数目
- 每朵花 [start, end] 定义开花时期; 对于每一个在某时刻来的人, 返回此时开花数量.
- 思路: 排序累计, 二分.
    - 转化为, 统计时间维度上, 不同区间内的花朵数量 (这样就可以二分查找了). 为此, 对于 start, end 两类节点统一排序, 然后记录各个变化的时间点即可
    - 具体而言, 用 `timeSplits, flowerNums` 两个数组记录变化时刻和该区间内的花朵数量.

## 双周赛 D60-D100

### D68

- 2114. 句子中的最多单词数
- 2115. 从给定原材料中找到所有可以做出的菜
    - 给定一个菜单, 每道菜的成分可能包括食材或其他的菜品, 要求在一定的初始食材下能够得到的所有菜品
    - 思路一: 本题数据量比较小, 可以暴力遍历. 用一个 flag 记录一次遍历是否有新的菜品(食材) 生成, 当没有时即结束
    - 思路二: 依赖关系构成图, 显然可以用 `拓扑排序` 解决, see [here](https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/solution/cong-gei-ding-yuan-cai-liao-zhong-zhao-d-d02i/)
- 2116. 判断一个括号字符串是否有效 `中`
    - 给定一个在某些位上固定的字符串 (例如 `s = "))()))", locked = "010100"`), 判断能够通过修改其他自由位使其成为合法的括号序列
    - 思路一: 关注 lock 部分 (剩下偶数个自由位一定可以匹配)
        - 先尝试匹配 lock 部分的字符串, 记录未成功匹配的位置 (三种情况, 最后剩下 `((`, `))` or `))((`; 和 空白符号的位置;
        - 利用 space 字符串来匹配剩下的左右括号 leftStack, rightStack
        - 原本分了上面三种情况讨论, 实际上可以合并: 用 space 最前面的部分匹配右括号, 最后面的部分匹配左括号, `len(spaces)>=len(leftStack)+len(rightStack) and all([i>j for i,j in zip(spaces[-len(leftStack):], leftStack)]) and all([i<j for i,j in zip(spaces[:len(rightStack)], rightStack)])`
    - 方法一：数学, see [here](https://leetcode-cn.com/problems/check-if-a-parentheses-string-can-be-valid/solution/pan-duan-yi-ge-gua-hao-zi-fu-chuan-shi-f-0s47/)
        - 定义了有效字符串「分数」的概念, 然后通过: 维护 1. 前缀 s[0..i] 可以达到的最大分数；2. 前缀 s[0..i] 「可以达到的最小分数」及「作为有效前缀所需的最小分数」两者的较大值. 这两个数组来进行判断.
- 2117. 一个区间内所有数乘积的缩写 `难`
    - 放弃了
    - 参见 [思路详解+详细讨论一下精度问题](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/fen-bie-ji-suan-qian-5wei-he-hou-5wei-si-dc9x/), Python 超时了. 另外 [here](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/yi-ge-shu-ju-tuan-mie-jue-da-bu-fen-dai-234yd/) 做了更多的分析

### D69

- 2129. 将标题首字母大写
- 2130. 链表最大孪生和
- 2131. 连接两字母单词得到的最长回文串
    - 给一组长度为2的字符串, 将他们拼接, 形成最大的回文串
    - 考虑 1. aa 的形式, 若数量为奇数, 只能放在中间, 若为偶数, 可以两侧对应位置放置; 2. ab + ba 的形式, 左右对称放置
- 2132. 用邮票贴满网格图
    - 给一个矩阵grid, 其中数字为1的位置不能使用; 要求用 stampHeight x stampWidth 的邮票去贴满所有空的位置, 返回能否实现. 矩阵不可旋转, 可以重叠.
    - 二维前缀和 + 二维差分
        - from [here](<https://leetcode-cn.com/problems/stamping-the-grid/solution/wu-nao-zuo-fa-er-wei-qian-zhui-he-e>
        - r-wei-zwiu/)
        - 首先, 利用 **二维前缀和矩阵** 可以快速计算 (x1,y1), (x2,y2) 区域内的元素和.
            - 前缀和 `m[x,y]` 表示 (0,0),(x,y) 所定义的矩阵之和;
            - 递推计算公式为 `m[x+1,y+1] = m[x+1,y]+m[x,y+1]-m[x,y]+matrix[x,y]`. 这里的前缀和矩阵 m 有哨兵, 即大小为 (m+1,n+1)
            - 利用二维前缀, 求 (x1,y1),(x2,y2) 所定义的子矩阵之和的计算公式为 `m[x2+1,y2+1] - m[x2+1,y1] - m[x1][y2+1] + m[x1,y1]`.
            - 在本题中, 计算grid的前缀和矩阵, 即可以用来判断该区域内是否有1.
        - 根据二维前缀和的计算, 可以定义 **二维差分矩阵**. 另参见 [here](https://zhuanlan.zhihu.com/p/439268614)
            - 计算公式为 `s[x,y] = matrix[x,y] - matrix[x-1,y] - matrix[x,y-1] + matrix[x-1,y-1]` (注意和上面前缀和的递推计算意义不一样)
            - 可知, 我们所定义的差分矩阵, 其前缀和就是原矩阵!!
            - 根据差分矩阵, 我们可以快速在 (x1,y1), (x2,y2) 范围内都加上一个数字: 等价于在其差分矩阵的 `(x1,y1),(x2+1,y2+1)` 位置+1, `(x2,y1+1),(x1+1,y2)` 位置-1.
            - 在本题中, 利用对于每个为空的坐标,尝试以其为左上角贴邮票, 利用差分矩阵记录贴上去的邮票所占据的位置. 最后利用差分矩阵还原, 计算每个位置的邮票数量, 若出现原本为空的位置没有贴上邮票, 说明不满足.
        - 注意, 为了边界条件, 1. 这里定义的前缀和矩阵第一行第一列为0; 2. 而根据差分的定义, 在更新(x2,y2)位置时候用到了 s(x2+1,y2+1), 因此形状也为 (m+1,n+1).

### D70

- 2144. 打折购买糖果的最小开销
- 2145. 统计隐藏数组数目
- 2146. 价格范围内最高排名的 K 样物品
    - 网格搜索, 0表示不能走, 不同的格子有价格, 要求找到价格在 pricing = [low, high] 区间内的位置.
    - 要求找到优先级最高的k个, 优先级为: 1. 距离; 2. 价格; 3. 行坐标; 4. 列坐标.
    - 思路: BFS.
        - 广度优先, 每一轮维护 paths 记录当前可到达的坐标, potentials 为满足pricing约束的坐标集合, 然后 `select(potentials, k)` 根据优先级筛选.
        - 注意边界条件: 1. 每一轮中,当paths为空时说明无法继续搜索; 2. 开始状态, 需要判断start点是否符合要求并加入visited.
- 2147. 分隔长廊的方案数
    - 简单

### D71

- 2160. 拆分数位后四位数字的最小和
- 2161. 根据给定数字划分数组
- 2162. 设置时间的最少代价
    - 设置四位的时间, 前后两位分别表示分钟和秒钟, 例如 `8090` 表示 80*60+90 秒
    - 给定 startAt ，moveCost ，pushCost 和 targetSeconds 分别表示初始的手指位置, 移动和按按钮的代价, 以及目标的秒数, 要求返回最小的代价. **前置0可以不输入**
    - 思路: 模拟
        - 注意到, 犹豫两位数字可以大于59, 因此同样的秒数可能有多种表示. 除了 1. 基本的 `minutes, seconds = targetSeconds//60 , targetSeconds%60`, 还有可能 2. 是 `minutes-1, seconds+60` (`seconds+60<100`), 计算两者较小的代价.
        - 用函数 `getCost(minutes, seconds)` 模拟该方案的代价.
        - 需要注意边界: 1. 当 `targetSeconds<60` 时 第二种方案非法; 2. 当 `targetSeconds>=60000` 时, 第一种方案非法. 因此可以在 getCost 函数中增加判断: `minutes>99 or seconds>99 or minutes<0 or seconds<0` 时返回 Inf, 更简单.
- 2163. 删除元素后和的最小差值
    - 给一个长度为 3n 的数组 nums, 要求删除其中 n个数字, 使得删除后, 数组前n个数字之和 - 后n个数字之和最小.
    - 方法一：优先队列 [here](https://leetcode-cn.com/problems/minimum-difference-in-sums-after-removal-of-elements/solution/shan-chu-yuan-su-hou-he-de-zui-xiao-chai-ah0j/)
        - 目标: 前n个数字之和最小, 后n个数字之和最大.
        - 可知, 最后剩余的两组数字, 其原始的分割点一定在 [n, 2n] 之间. 因此, 可以 遍历遍历每一个分割点, 分别计算前后的最小和最大和, 然后求最小值.
        - 为此, 可以分别建立一个最大堆和最小堆, 遍历 [n, 2n] 个数字 (pushpop), 记录每一个分割点的的值. 需要注意的是, 后半部分应该逆序, 注意代码.

### D72

- 2176. 统计数组中相等且可以被整除的数对
- 2177. 找到和为给定整数的三个连续整数
- 2178. 拆分成最多数目的偶整数之和
- 2179. 统计数组中好三元组数目
    - 给两个数组, 分别是 [0:n-1] 的一个排序, 要求找满足条件的三元组数量, 条件: (x,t,z) 出现在两数组中的次序是一致的.
    - 分析可知, 将nums1中数字在num2中的index依次写出来, 记为 numMap, 则结果就是该数组中递增的三元组的个数
    - 思路1:
        - 遍历 numMap, 对于一个数字 num, 考虑以num结尾的长度为2的递增数组的数量 —— 为数组之前部分比num小的元素数量; 记为 last1
        - 进一步考虑以num结尾的长度为3的递增数组的数量, 可知其为 last1 中, 所有小于num的组数之和.
        - 因此, 这里的核心问题在于: 实现一个数据结构, 可以 1. 查询其中比 query 小的数量; 2. 插入某一个数值的数量.
        - 该问题可以建模为 「**树状数组/线段树**」, 参见 [here](https://oi-wiki.org/ds/fenwick/)
    - 思路2 树状数组:
        - 已知, 问题可以转化为, **在一个数组中计算递增三元组的数量.**
        - 分别用两个 BIT, 计算位置i之前的比 num[i] 小的数量, 以及位置i之后的比 num[i] 大的元素数量. 这样最终的结果就是 `sum(low[i]*high[i] for i in range(n))`
    - 另见 [here](https://leetcode-cn.com/problems/count-good-triplets-in-an-array/solution/deng-jie-zhuan-huan-shu-zhuang-shu-zu-by-xmyd/)

### D73

- 6024. 数组中紧跟 key 之后出现最频繁的数字
- 5217. 将杂乱无章的数字排序
- 5300. 有向无环图中一个节点的所有祖先
    - 给一个 DAG, 要求返回每一个节点的所有祖先节点 (排序)
    - 思路一: 可以通过 DFS 找到节点的所有孩子, 在 **逆图** 上做即可
- 5237. 得到回文串的最少操作次数 `hard`
    - 给一个字符串, 仅有的操作为交换相邻两个字符, 要求转为回文串的最小交换次数
    - 思路一: 两次贪心 [here](https://leetcode-cn.com/problems/minimum-number-of-moves-to-make-palindrome/solution/de-dao-hui-wen-chuan-de-zui-shao-cao-zuo-nnis/)
        - 首先需要理解: **逆序数** 等于一个 序列要变成升序排列所需要的相邻元素交换的最小次数。 see [here](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/ni-xu-shu-yu-pai-xu-de-nei-zai-lian-xi-wu-dai-ma-b/)
        - 先考虑偶数长度的情况: 可知, 对于 2m 个字符ch, 其中的前m个字符, 也一定在最终的回文串的前一半中, 并且它们之间的相对位置保持不变.
            - 因此, 分解为两步: (1) 组间交换. 先划分左右两个子串. 由于不改变相对位置, 其实我们就知道了原本字符串的每一个位置的元素, 在分为好左右组的字符串中的位置.
            - (2) 组内交换, 也即是的左右子串转换为对称. 由于没有相对位置变化, 因此我们固定左子串, 则对于右子串中每一个字符最终的位置其实我们就确定了 —— 等于求逆序数.
        - 而对于奇数情况, 简单令右子串多一个元素, 然后在左子串后加上那个中心的(奇数)字符, 则约束了右串排序中将其移动到中间.
    - 思路二: 贪心 [here](https://leetcode-cn.com/problems/minimum-number-of-moves-to-make-palindrome/solution/tan-xin-zheng-ming-geng-da-shu-ju-fan-we-h57i/)
        - 其实在上面的思路中, 我们已经知道了最终的回文串是怎样的 —— 左子串由所有字符的前一半出现位置决定, 右子串对称.
        - 因此, 更为贪心的策略是: 每次保留左侧的第一个字符, 将最右边的该字符移动到右侧, 这样就完成了匹配.
        - 对于奇数的情况, 只需要将其移动到中心即可.
