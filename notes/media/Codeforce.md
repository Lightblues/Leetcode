
## Div.4

### 806



### 799 (div.4)

- C. Where's the Bishop?
    - 在一个8*8的棋盘上, 标注了一个象可以走的所有位置, 要求找到该棋子的位置.
    - 限制: 象不在四边 (也即坐标在 [2,7] 之间)
    - 思路1: #模拟 #归纳
        - 由于不在四边, 从上往下看每一行象可达的数量, 可以象所在行可达1个位置, 上面一行一定是2个位置.
- D. The Clock
    - 有一个24小时制的时钟, 从start时刻开始, 每隔x分钟看一次时钟 (时间无限) 问看到的时刻中有多少种是回文数 (例如 12:21 )?
    - 思路1: #模拟 判断, 用 #记忆化 来加速
- E. Binary Deque
    - 给定一个长n的数组, 可以从两端去掉数字, 问最少多少次可以是的数组和为s.
    - 限制: n,s 2e5. 需要在线性时间求解
    - 思路: 用一个 #哈希表 记录出现过的 #前缀和 然后遍历的时候检查是否出现过匹配元素.
- F. 3SUM
    - 给定一个数组, 若存在三个下标 i,j,k 使得三个数之和的个位数为 3, 则返回Yes.
    - 约束: 线性复杂度
    - 思路: 先枚举所有可以得到3的组合, 判断是否在其中即可.
- G. 2^Sort
    - 给定一个长n的数组, 统计其中满足条件的长k的连续子数组的数量. 条件为这个长k的子数组, 以 2^0,2^1,2^2... 为权是严格递增的.
    - 思路1: #双指针
        - 在遍历right的过程中, 维护left是最左边的满足条件的位置. 事实上每次仅需要判断 right, right-1 相邻位置是否满足条件即可 (`nums[right]*2<=nums[right-1]`), 若不满足则重置 `left=right`.
- H. Gambling
    - 题目搞得花里胡哨, 归纳: 给定一个长n的数组, 返回一个区间 [l,r] 和数字a, 使区间中数字a出现的次数 - 其他数字的数量最大.
    - 限制: 数组长度 n 2e5, 数组元素 1e9.
    - 思路1: 直接遍历 #模拟
        - 考虑每一个数字, 我们将其看成 1/-1 的数组中, 求区间得到最大值. (实际上用idx数组记录). 遍历过程中, 我们 #贪心 舍弃不需要的部分.
        - 例如, 若之前记录了 [0,1] 位置为正数 (此时最大正数记录为2), 下一个正数坐标为 4, 由于 `sum(nums[:4]) = 2; +2 - (4-2) = 0 <=0`, 我们可以不考虑, 将记录重置为 `[4]`
        - 复杂度: 具体的实现上, 用了dict来存储数字到位置的映射. 若哈希表的操作复杂度为 O(1), 则时间复杂度为 O(n).
            - 但实际上被hack了😭. 因为发生哈希冲突的情况下, 复杂度可能上升为 `O(n^2)` ! 另外的答案中, 所有的数字都用的是 str 就可以过 (理论上也可以被hack 只不过还没有).
        - 参见: [哈希冲突及解决方法](https://blog.csdn.net/qq_41963107/article/details/107849048) 以及 [Python的字典实现](https://harveyqing.gitbooks.io/python-read-and-write/content/python_advance/python_dict_implementation.html), 另外 [这篇](https://zhuanlan.zhihu.com/p/74003719) 更加直观一些.
  - 思路2: 也是因为上述原因? 所以官答用了 #线段树 来解的.