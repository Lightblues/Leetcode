# 周赛笔记

## 周赛 250-300

### 250

- 1935. 可以输入的最大单词数
- 1936. 新增的最少台阶数
- 1937. 扣分后的最大得分 #medium
    - 给定一个grid形式的矩阵, 每行选取一个位置的元素, 累计所有分数; 对于相邻的 i, i+1 行, 需要扣除 `abs(c_i - c_i+1)`, 也即相邻行所选两列的位置差值. 要求最大分数
    - 约束: grid大小 1e5
    - 思路1: #DP
        - 考虑每多一行 row 造成的分数变化? 对于每一列的数字, 都是 `dp[i] = max(dp[j] + row[i] + abs(i-j))` (这里左侧dp是上一行的值).
        - 也即, 当前行本身的值的大小不会影响j的取值. 上一行的值造成的变化是可以计算的.
        - 因此, 递归过程中: 每次都 1) 计算上一行的分数影响; 2) 加上当前行每一列的元素值.
        - 具体而言, 例如上一行的最大值为 `[2,7,4]`, 则下一行每个位置的最优剩余分数为 `[6,7,6]`. 可以看到是较大元素向左右传播. 因此左右两边分别进行一次遍历, 去较大即可.
        - see [here](https://leetcode.cn/problems/maximum-number-of-points-with-cost/solution/kou-fen-hou-de-zui-da-de-fen-by-leetcode-60zl/)


### 260

- 2016. 增量元素之间的最大差值
- 2017. 网格游戏
    - 给定一个 2 x n 的网格, 每个格子有一些分数; 两人只能向右或向下从左上角走到右下角. 第一个人的目标是让第二个人剩余可以吃到的分数最小, 求最小分数.
    - 遍历. 注意 **分析边界**
        - 首先分别计算上下两行从右往左和从左往右的累计和, 在前后加两个哨兵简化判断. 因此 up,down 的长度为 n+1
        - 然后, 假设第一个人从第i个位置往下走(从1开始), 则第二人可以得到的分数为 上半部分的 i+1,...,n, 或者下半部分的 1,...,i-1
        - 对应到这里的两个累计和, 分别是 up[i+1], down[i]. 因此更新 `res = min(res, max(up[i+1], down[i]))`
        - 显然遍历范围为 `range(0, n)`
- 2018. 判断单词是否能放入填字游戏内
    - 给定一个网格, 三种情况: ' ' 表示为空, '#' 表示无法仿制, 还可能已经填入字母.
    - 要求判断一个单词是否能放入填字游戏内. 条件: 1. 方向 上下左右都可(可以从右往左); 2. 边界上不能为空或其他字母, 也即只能是 '#' 或者网格的边界; 3. 字母匹配.
    - 重点: **条件和边界判断**
        - 自己的实现比较乱, 定义了一系列的函数, 贵在比较清楚;
        - 然后又抄了 [here](https://leetcode-cn.com/problems/check-if-word-can-be-placed-in-crossword/solution/mei-ju-liang-ge-zhi-jian-de-zi-fu-by-end-pjq1/) 的解法, 思维难度上大了些. 需要注意, go和Python 中, **在循环内部对于循环变量修改是不同的**, Python中修改不会影响结果! 而go中则是可以进行赋值的.
- 2019. 解出数学表达式的学生分数
    - 给一个只有 +* 运算和 0~9 数字的表达式, 对于不同的答案赋予分数. 1. 正确为5, 2. 因为运算顺序导致的错误, 分数为2, 3. 其他0分.
    - 因此, 核心问题是 遍历所有运算顺序, 给出所有可能的结果.
    - 思路一: **分治 + 记忆化**
        - 利用递归实现分治. 结合 lru_cache 实现. 由于这里的所有数字和运算符都是一个字符的, 解析起来非常方便 (表达式长度一定为奇数).
        - 复杂度分析
            - 注意到, 这里随意更换运算顺序, 至少是一个指数级别的复杂度!
        - 例如对于表达式 `"4+8*8+8+8*8+4*4+8*4+8*8+8*8+8"`, 其不同答案的数量可以达到 `86301`; 直接排列组合在 LC上会超时.
            - 题目中给出了限制 0 <= answers[i] <= 1000 (正确答案在1000以下), 因此可以对于两侧给出的答案进行过滤, 这样不同答案的数量最多只有 `141`. —— 剪枝

### 261

- 2027. 转换字符串的最少操作次数
- 2028. 找出缺失的观测数据
- 2029. 石子游戏 IX #medium #博弈论
    - 有一组数字, AB依次取数字, A先手. 胜利条件:
        - 若两人取的数字之和可以被3整除, 则A获胜.
        - 除此之外, 若数字全部被取走A还未获胜, 则B获胜.
    - 一月的每日一题做过了, 但还是debug了挺久. 这里记录更为 naive 的思路
    - 思路: 模拟判断
        - 显然, 可以将数字根据除3的余数分成三类. 能够被3整除的数字可以起到「交换」的作用.
        - 先不考虑整除的数字, 剩余的两类地位是等价的. 例如, 在数字数量足够的情况下, 两人的最优序列形如 `112121...`. 注意到, **B所取的数字都是一样的**. 一下根据数量分类讨论 A 的胜利与否
            - 计两类数字的数量为 cmin, cmax; 方便起见假设1的数量更少
            - 若 cmin=0 (所给的数字数量 >0), 则无论是 cmax=2时B取完数字, 还是 cmax>=3 时A取数字后总和能够被3整除, 均为 False;
            - 若 cmin=1, A取 `1` 之后, B只能取2, 因此 True;
            - 若 cmin=2, AB取完 `112` 之后, B只能取2, 因此 True;
            - 若 cmin<=3, 胜利条件是 `112121...2` 之后, B只能取2, 因此数量条件时 `count[2] >= count[1]`, 也即 cmax>=cmin, 始终成立, 因此 True.
            - 综上所述, 官答给了一个更好的总结: **A的策略始终为取数量较少的那类数字**; 只要cmin>= 均为 True
        - 考虑可以被3整除的数字的影响: 当数量为偶数时不影响; 以下分析数量为奇数时:
            - 这一情况下, 相当于B获得了一次「换手」的机会.
            - 对于 cmin=0,1,2 进行讨论, 易知此时A均为 False;
            - A获胜的条件只可能为 `221021...2` (这里0表示B换手, 可知在哪个位置换手不影响AB所取的数字数量) 之后, B只能取1, 因此数量条件为 `count[2] - count[1] >= 3`. 也即 `cmax-cmin >= 3` 注意允许一次「换手」之后, A的最后策略变为取数量较多的那一类数字.
- 2030. 含特定字母的最小子序列 #单调栈 #hard #题型
    - 给定一个字符串s要求找到一个长度为k的子序列 (不要求连续), 使得: 1) 其中包含至少 repetition 个特定字符 letter; 2) 子序列字典序最小.
    - 关联: 0316. 去除重复字母; 另有基本题型「求长为 k 的字典序最小子序列」
    - 本题的限制包括 1) 子序列长度为 k; 2) 子序列中包含至少 repetition 个特定字符 letter.
    - 思路: 单调栈, 注意判断这些限制条件!
    - 单调栈相关问题思路:
        - 注意空栈 pop 的错误;
        - 限制子序列长度为 k: 1) 在push的时候判断时候超过限制; 2) pop时判断剩余的是否够, 即使 break;
        - 限制栈内元素数量 (比如要求ch的数量至少为repetition): 1) pop的时候检查剩余是否够; 2) 另外需要检查, 若栈内元素不足以放剩余的ch (repetition-countInStack), 则需要push.

### 262

- 2032. 至少在两个数组中出现的值
- 2033. 获取单值网格的最小操作数 #medium #题型
    - 给定一个数组, 每次操作可以对于其中的每个元素加减x, 要求使得所有元素相同的最小操作数.
    - 思路: #中位数
        - 注意, 这里不应该算mean, 而是中位数!!
        - 考虑一个反例: [1,1,1,1,100] 将小元素移动到mean的成本要高于移动较大值.
        - 中位数的逻辑在于, 每修改一次target都会对于所有的元素产生影响: 要么都加x, 要么都减x. 因此要将左右元素数量均衡.
        - from [here](https://leetcode.cn/problems/minimum-operations-to-make-a-uni-value-grid/solution/zhong-wei-shu-by-endlesscheng-p0vj/): 假设要让所有元素均为 y，设小于 y 的元素有 p 个，大于 y 的元素有 q 个.
            - 则 y 每增加一个 x, 都会使得操作数增加 p - q; (或者说, 每减少 x, 都会使得操作数减少 q - p). 因此取最小值的条件是 `p=q`.
- 2034. 股票价格波动 #medium #题型
    - (timestamp, price) 定义股票价格, 进来的timestamp是乱序的. 注意, **价格可能出现错误, 假设后到的是对于该时刻价格的修正**.
    - 要求实现一个类, 有操作
        - int current() 返回股票 最新价格.
            - 这个比较简单, 维护一个最大时间戳即可
        - void update(int timestamp, int price) 在时间点 timestamp 更新股票价格为 price.
            - 实现更新, 主体逻辑
        - int maximum() 返回股票 最高价格 (相应的还有最低价格)
            - 本题的特殊点即在于有修正错误值的操作, 因为需要用一定的数据结构来存储这一信息
    - 每日一题做过了, 这里再记录一下思路:
    - 时间戳到价格的存储肯定用一个map, 关键在于如何实现更新操作?
    - 思路1: #有序集合 为了快速得到最大最小值, 显然可以维护一个有序结构. 注意: **有序集合的插入(更新)和最大最小查询复杂度均为 `O(log(n))`**
        - 官答用了 SortedList. 尝试了用 slice 语法实现更新, 发现 O(n) 的复杂度还是会超时.
    - 思路2: 最大最小的查询, 另外的一种思路自然是 #堆 结构.
        - 这里多了数据可能无效这一限制, 则可以将 (price, timestamp) 当做一个元素, 从堆顶取出元素的时候, 只需要在 priceMap 中查询数据是否仍有效即可.
        - 这样在没有太多错误数据情况下, 查询的时间复杂度为 `O(1)`
    - [here](https://leetcode.cn/problems/stock-price-fluctuation/solution/gu-piao-jie-ge-bo-dong-by-leetcode-solut-rwrb/)
- 2035. 将数组分成两个数组并最小化数组和的差 #hard #题型
    - 将长度为 2n 的数组分成等长的两部分, 要求两个数组和相差最小.
    - 复杂度: n<=15
    - 思路: #折半枚举 +排序+ #二分
        - 这里用的思路是 #折半枚举. 具体而言, 本题需要从 2n个数字从取 n个. 折半枚举的思路是分别从左侧的一半和右侧的一般数组中取 i, n-i 个.
        - 计算复杂度: 直接枚举的复杂度为 `math.comb(2n, n)`; 折半枚举每一边的复杂度为 `O(2**n)`. 例如在 n=15 时差了好几个数量级
        - 用数组(集合)记录在left中取i个数字可能得到的和, 并排序; 然后在右侧枚举取n-i个数字, 两者匹配计算.
        - [here](https://leetcode.cn/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solution/zhe-ban-mei-ju-pai-xu-er-fen-by-endlessc-04fn/)
    - 关联: 1755.最接近目标值的子序列和; 0805.数组的均值分割; 0416.分割等和子集; 0494.目标和 见 [总结](https://leetcode.cn/problems/closest-subsequence-sum/solution/by-mountain-ocean-1s0v/)

### 263

- 2042. 检查句子中的数字是否递增
- 2043. 简易银行系统
- 2044. 统计按位或能得到最大值的子集数目 #medium #题型
    - 给定一组数字, 将它们依次 「按位或」 得到一个最大值 maxNum, 现要求 list 的所有子集中, 这些集合中的元素按位或可以得到该 maxNum 的组合数量.
    - 复杂度: 数组长度 n<=16
    - 思路1: 暴力遍历 #二进制枚举. 时间复杂度: O(2^n * n). 第二个因子n是指需要对于数组元素进行按位或操作.
        - 之前想多了, 考虑到本题的数组长度有限, 暴力枚举所有可能的组合就行
    - 思路2: 通过 #DFS 记录状态, 避免重复枚举
        - 在上面的思路中, 例如计算 (1,2,3) 位的or 与计算 (1,2,3,4) 位的or 是相互独立的, 因此有重复计算.
        - 可以采用DFS, 用空间来避免重复计算. `dfs(i, orVal)` 表示枚举第 i 个位置时的状态为 orVal.
    - 思路3: 利用 #DP 来记录状态
        - 用 dp[mask] 表示利用 mask 所表示的那些数字的 or 和
        - 如何利用之前的数来帮助计算? 我们可以将 mask 分解成两部分然后对这两个数计算或. 如何划分? 可以利用 **位运算得到一个数字最低位1的位置 lowbit**.
        - 例如, `6=0b0110` 的最低位为 `lowbit = 6 & -6 = 0b0010`, 因此,
        - 递推公式: `dp[mask] = dp[mask-lowbit] | nums[lowbitIdx]`
    - see [here](https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/solution/by-ac_oier-dos6/)
- 2045. 到达目的地的第二短时间
    - 一月的每日一题, BFS即可

### 264

- 2047. 句子中的有效单词数
    - 1月每日一题做过了, 要求的验证条件比较复杂.
- 2048. 下一个更大的数值平衡数
    - 定义「数值平衡数」为, 例如 3133, 包含了1个1, 3个3.
    - 现在给定一个数字, 要求返回比这个数字大的下一个数值平衡数.
    - 复杂度: 1e6
    - 思路1: 暴力遍历. 要test一个数字是否为平衡数是简单的. 由于数字范围不大, 可以直接暴力遍历.
    - 思路2: 整体的数量不多, 为了加速查询, 可以 #打表 预计算范围内的所有平衡数, 然后二分查找.
- 2049. 统计最高分的节点数目 #medium #题型
    - 有一棵二叉树, 定义一个节点的分数: 移除这个节点(和相邻边) 后, 其他部分节点数量的乘积.
    - 要求返回分数最大的节点的数量.
    - 思路1: #DFS
    - 对于一个节点, 先探索子节点包含的节点数量, 剩余部分的节点数量为 `n-1-nChild1-nChild2` (注意需要排除为 0 的情况), 然后计算乘积.
- 2050. 并行课程 III #hard #题型
    - 课程之间存在DAG依赖关系, 每个课程修习需要一定的月份, 前序依赖满足的情况下, 不同课程可以同时修习. 求完成所有可能的最小时间.
    - 复杂度: 节点/边数量 5e4,
    - 关联: 1857. 有向图中最大颜色值
    - 思路1: #拓扑排序 在遍历的过程中记录每个节点的timeLimit, 这样, 遍历每一条边的时候, 可以更新 `timeLimit[v]` 为 max(timeLimit[v], timeLimie[u]+time[v])`

### 265

- 2057. 值相等的最小索引
- 2058. 找出临界点之间的最小和最大距离 #medium #链表
    - 给定一个链表, 定义关键点为局部(严格的)极小/极大值, 要求返回这些关键点之间距离的最小和最大值.
    - 例如, head = [5,3,1,2,5,1,2] 这一链表的关键点位置在 2,4,5, 因此返回 [1,3]
    - 思路1: 模拟遍历
        - 自己的思路是每次仅关注到当前遍历的节点, 因此需要记录上一个节点的值, 以及上一个节点与当前节点的大小比较.
        - 而 [answer](https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/solution/zhao-chu-lin-jie-dian-zhi-jian-de-zui-xi-b08v/) 中, 使用 `cur.next.next.val` 来获取连续三个节点的值, 更为方便, 而不需要记录历史信息. 从代码上更为简洁.
- 2059. 转化数字的最小运算数 #medium
    - 给定一组数字nums, 要求将 start 转为 goal. 每一次操作可以从nums中选择一个与start进行 +/-/^ 操作, 每个nums中的数字可以用任意次. 问最小操作数.
    - 限制: 0 <= x <= 1000. 当操作超过这一范围后, 无法再进行操作 (goal可以超过这一范围).
    - 思路1: #BFS 将每一次允许的操作看作是对于当前数字/点的转移边. 因此建模为可达性问题, 用BFS求解.
        - 技巧: operator 包
- 2060. 同源字符串检测 #hard
    - 定义一种压缩字母字符串的方案: 类似将 "internationalization" 简写为 "i18n". 也即, 将整个字符串分解成若干部分, 某些部分用其长度来表示.
    - 现给定两个压缩后的字符串, 要求判断它们是否可能同源.
    - 复杂度: s1,s2 的长度限制 40, 最多出现的连续数字为 3.
    - 思路1: DFS + 分类讨论
        - from [here](https://leetcode.cn/problems/check-if-an-original-string-exists-given-two-encoded-strings/solution/ji-yi-hua-sou-suo-by-endlesscheng-ll3r/)
        - 整体是采用DFS. 分类准则: dfs[i,j,d] 表示用 s1[:i] 和 s2[:j] 子串 (部分匹配成功), 并且前者长度 - 后者长度的差值为 d.
            - 注意这里的 d!=0 的情况出现在, 采用了数字进行匹配, 还有剩余. (因为两者都是字母的情况下不会有剩余)
            - 终止条件: `i==n and j==m and d==0`
            - 如何检查冲突? 当 d==0 时, 若 s1[i], s2[j] 都是字母并且不相等, 则匹配失败.
            - 如何避免重复访问? 例如, 若两个压缩字符串的前缀均为 `a111a111xxx`, 在匹配到位置8的时候, dfs[8,8,0] 会出现很多次. 因此, 用cache记录 (i,j,d) 以避免重复访问.
        - 总结一下: 分类讨论的优先级是: 1) 若 d==0 且待匹配的都是字母, 则将 i, j 同时向后一位; 2) 否则, 匹配较短的字符串 (d>=0, d<=0) 这里取等号, 是为了处理 d==0 并且 i,j 位置为一个数字一个字母的情况. 3)在匹配较短序列的时候, 基于字母和数字进行分类讨论.
        - [官答](https://leetcode.cn/problems/check-if-an-original-string-exists-given-two-encoded-strings/solution/tong-yuan-zi-fu-chuan-jian-ce-by-leetcod-mwva/) 用了DP来理解, 思路是一样的, 并进行了复杂性估计.

### 266

- 2062. 统计字符串中的元音子字符串 #easy #题型
    - 要求统计连续子序列的数量. 条件为: 1) 所有元素为元音字符 2) 包含所有aeiou五个元素.
    - 思路1: 暴力检索. 时间复杂度 O(n^2)
        - 技巧: 这里要检查数组包括的所有元素, 天然就是 #set 问题.
    - 思路2: #双指针.
        - 先用re抽取所有仅由元音组成的子串, 对于每一个符合要求的子串, 双指针遍历.
        - 具体而言, 存储左右指针内包含的元音数量. 遍历有指针的过程中, 维护左指针使得「左右指针包含的包含所有元音的最短序列」, 这样, 以右指针结尾的包含左右元音的子串数量为 left+1.
- 2063. 所有子字符串中的元音
- 2064. 分配给商店的最多商品的最小值 #medium #二分
    - 将一组商品分配给n家商店, 每家店只能有一种商品 (也可以没有商品). 要求一种最「平均」的分配方式, 也即这些店中的商品数量最大值达到最小.
    - 限制: 商品种类 m = 1e5, 每一种的最大数量 a = 1e5
    - 思路1: #二分查找 每次检查的复杂度为 m, 二分的范围最大为 a, 因此时间复杂度为 O(m*log(a)).
        - 左右边界: sum(quantities)/n), quantities[-1]+1
        - 注意二分的边界: 这里的题型是「满足条件的最小值」. 因此不满足时缩小左边界 `left = mid+1`, 最后返回 `left`.
    - 说明: 出了手动写二分算法之外, [here](https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/solution/er-fen-da-an-by-endlesscheng-aape/)
        - 直接调用了 go 中的 `sort.Search` 函数, 简化了代码.
        - 类似的, 在 Python 中可采用 `bisect.bisect_left`, 语法有所不同, 思路是一样的 (其实都是在一个range数组中二分查找).
- 2065. 最大化一张图中的路径价值 #hard #DFS
    - 给定带权图, 每个节点有分数. 在 maxTime 时限下, 从0回到0, 找到最大分数的路径. 注意, 节点可以重复访问
    - 限制: 每个节点的相连边最多为4; 由于 `10 <= time_j, maxTime <= 100`, 所以最大搜索深度为 10.
    - 思路1: 暴力DFS, 注意是可重复访问的
        - 本题的特殊之处在于节点可重复访问.
        - 题中对于图有着较多的限制, 采用最暴力的 DFS, `4**10` 也不超时.

### 267

- 2073. 买票需要的时间 #easy
    - 给定一个队列表示每个人要买的票的数量. 购票规则是, 每个人只能购买一张, 因此购买后只能回到队尾重新排队. 要求第k个人买到所需的所有票的时间
- 2074. 反转偶数长度组的节点 #medium #链表 #题型
    - 给定一个链表, 将其分割成 1,2,3... 长的子序列 (最后一个剩余的长度可以不符合). 对于这些子序列, 反转其中长度为偶数的.
    - 总结: 对于链表题型还不太熟悉; 重点在于总结基本题型, 而非纠结于细枝末节的调试.
    - 思路1: 暴力模拟. 完全按照 #链表 的思路来写
        - 救命, 这题写了两个小时.
        - 思路是实现一个翻转 [i,j] 范围内节点的函数 (同时要求连上 i-1, j+1); 然后遍历
        - 然而如何判断最后剩余的长度是否为偶数呢? 自己的思路尝试用一次遍历用指针记录, 但是极为繁琐 (还不可行)
    - 思路2: 针对第二个问题, 放弃了整合在一次遍历的想法. 而是通过两次遍历: 第一次判断剩余是否为偶数. 然后在确实下一个目标序列的奇偶性的前提下进行翻转
        - 总体来看, 只需要维护 pre, cur 两个指针即可. 1) 若当前长度 i 为奇数, 将两者都前进i步即可; 2) 若为偶数, 则需要实现「将从cur开始的i个节点进行翻转」, 见下代码.
        - [官方](https://leetcode.cn/problems/reverse-nodes-in-even-length-groups/solution/fan-zhuan-ou-shu-chang-du-zu-de-jie-dian-owra/)
- 2075. 解码斜向换位密码 #medium
    - 定义一种加密方案: 给定一个固定行数 rows 的矩阵 (理解为「加密纸条」), 将originalText按照 主对角线、右上方的次对角线... 的规律进行填充. (填充保证右下角是填了的) 这样得到的encodedText是将这一矩阵一行一行拼接得到的序列.
    - 思路1: #模拟 暴力求解
        - 直接叫 encodedText 展开为矩阵, 然后斜方向依次即可取回原字符串
        - 对于加密纸条中未填充的部分, 去除末尾的空格即可
- 2076. 处理含限制条件的好友请求 #hard #题型
    - 有n个用户, 给定一组约束 restrictions, 每一个约束 (u,v) 表示两者不能联通; 对于一系列好友请求 requests, 判断他们能否建立关系(连边).
    - 思路1: #并查集 的基础上利用 #哈希表 记录能否成为关系
        - 判断是否联通显然可以用并查集框架. 关键是如何判断是否违反了约束? 可以将所有的约束条件记录在根节点上
        - 因此, 对于每一个查询, 先找 (u,v) 的根节点, 基于 `cant[rootu][rootv]` (矩阵形式的哈希表) 的值判断是否违反了约束.
        - 若没有, 则请求成功. 然后合并集合 `father[rootu] = rootv` 并将 cant[rootu] 中所记录的约束条件都记录在节点 rootv 上.
        - 参见 [here](https://leetcode.cn/problems/process-restricted-friend-requests/solution/bing-cha-ji-by-endlesscheng-8ipg/)


### 268

- 2078. 两栋颜色不同且距离最远的房子
- 2079. 给植物浇水
    - 模拟法
- 2080. 区间内查询数字的频率 `中`
    - 需求是查询子数组 arr[left...right] 中 value 的 频率; 考虑到查询数量可能较大, 因此设计一个数据结构存储数据分布信息
    - 解法: 用 map 保存数字所出现的位置列表, 从而查询时候可以用**二分查找**.
        - Python 可以直接用 `bisect.bisect` 好方便!
- 2081. k 镜像数字的和 `难`
    - 找到前 n 个, 在 10进制 和k进制下均为回文数的数字, 返回其最大值
    - 注意题目要求, 2 <= k <= 9, 1 <= n <= 30 当k和n均取较大值时会超时(约10**10量级); 因此重点是如何所见搜索空间.
        - 由于是回文数, 因此只需遍历前半部分即可, 注意可生成奇数或偶数长度的, 例如 1234 -> 1234321 或 12344321;
        - 另外, 每次遍历 [1,9], [10,99]... 的数字, 对于j位十进制数, 可分别生成 2j-1, 2j 位十进制数

### 269

- 2089. 找出数组排序后的目标下标
- 2090. 半径为 k 的子数组平均值
- 2091. 从数组中移除最大值和最小值
    - 滑动平均
- 2092. 找出知晓秘密的所有专家 `难`
    - 包括 (x, y, time) 的三元组, 若 x 和 y 中某一个知道了「秘密」, 则会进行传播; 要求最后知道「秘密」的所有人
    - 解法一: **构建图**, 传播
        - 按照时间排序, 难点在于判断同一时间的多人传播关系 —— 简单的方案是构建图
        - 解法的具体实现: 利用 edges 字典记录连接关系, 建立图后, 利用 一个 `deque` 记录所有激活节点, 迭代直至队列空
    - 解法二: **并查集**

### 270

- 2094. 找出 3 位偶数
    - 给你一个整数数组, 找出所有的三位偶数(也即要求首位不为 0), 顺序输出(直接排序即可)
    - 简单题 (也可根据提示的范围知道不复杂) 别想太多, 直接暴力遍历即可; 为了避免重复可以用 set()
- 2095. 删除链表的中间节点 `中`
    - 长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始）
    - 解法一: 快慢指针即可, 可以在最开始加上一个「哨兵」
- 2096. 从二叉树一个节点到另一个节点每一步的方向 `中`
    - 找到二叉树两个节点之间的路径
    - 解法一: 直接 DFS 找到两个点从 root 出发的路径, 除去公共路径即可
- 2097. 合法重新排列数对 `难`
    - 给定 pairs(表示区间), 重新排列要求排列后每个区间首尾数字相同; 核心在于理解「[欧拉通路](https://oi-wiki.org/graph/euler/)」, 将问题转换
    - `Hierholzer 算法`: 首先很容易想到, 若仅为「**半欧拉图**」(即存在两个奇数度数节点), 可以确定开始和结束的数字, 否则为「欧拉图」随便选择初始数字/节点即可.
        - 若随便选择一条边, 则可能走到「死路」, 注意此时剩下的图构成了一个「欧拉图」 —— 可以用DFS探索
        - 因此, 1. 每次选择一条边, 在图上删去这条边; 2. 递归; 3. 记录这条边. 注意这里的边是在遍历之后加入记录的 (也即是逆序的, 最后要再逆序输出), 这样可以保证可能漏过的「欧拉图」在此之前被遍历.
    - 参见 「332. 重新安排行程」「753. 破解保险箱」
    - 332 重新安排行程, `难`
        - 区别在于, 需要返回所有的通路中, 字母排序最小的那一个 —— 也即, 每次应该选择较小的那一个节点
        - [solution](https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/) 非常清楚
    - 753. 破解保险箱, `难`
        - 密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。要求返回一个最短字符串, 其子字符串包括所有可能的密码.
        - 关键在于将其转化为一个规范的欧拉通路问题: see [here](https://leetcode-cn.com/problems/cracking-the-safe/solution/po-jie-bao-xian-xiang-by-leetcode-solution/) 官方解答有点fancy
        - 解法: 转换为**欧拉通路问题**
            - 简言之, 要求的是 n 长序列, 都可将其看成 n-1长序列加上 0~k-1 的数字. 因此, 可以构建一个图, 节点为所有的 n-1长序列, 其第i个出边就是在最后加上数字i并去除第一位数字, 跳到相应的节点上.
            - 例如, 节点u的第v的出边就跳转到数值为 u*k % (k**(n-1)) + v 的节点上.
            - 可知, 这样构造的图, 每个节点都有 k条出边和入边, 共可代表 $k^{n-1} * k$ 个不同的数字, 正好对应了所有可能的密码.
            - 显然, 这张图是欧拉图, 并且可基于一个欧拉回路对应一个题目所要求的字符串.

### 271

- 2105. 给植物浇水 II
    - 模拟法即可
- 2106. 摘水果 `难`
    - 在一个无限的 x 坐标轴上, 分布一定的水果, 给定 startPos 和可以移动的步数 k, 计算可以拿到的最大数量
    - 题型: 其实就是给定一个累加和, 探索所有可能的范围内的最大值; 问题在于如何在离散存储的数组中找到对应的元素
        - 存储方式: 例如对 `[[2,8],[6,3],[8,6]]` 水果分布而言, 记录位置 `pos=[-Inf, 2,6,8]` 和 累计和 `[0,8,11,17]`
        - **二分查找**. 要注意 **边界情况**, 左边应该是 `bisect.bisect_left`, 而右边是 `bisect.bisect_right`, 注意函数返回的是待插入的 index, 因此最终能采集的水果数量为 `cumsum[rindex-1] - cumsum[lindex-1]`
        - 错误记录: 注意, 先往左边走和先往右边走所能达到的范围是不一样的! 因此两侧的情况都应该考虑到.

### 272

- 2110. 股票平滑下跌阶段的数目
    - 一次遍历即可
- 2111. 使数组 K 递增的最少操作次数 `难`
    - 如果对于每个满足 `k <= i <= n-1` 的下标 i ，都有 `arr[i-k] <= arr[i]` ，那么我们称 arr 是 K 递增 的。
    - 给定一个数组和 k,要求找到使得这个数组 k递增的最小修改次数.
    - 问题可转化为: 寻找一个数组中的最长递增序列, 参见 300 题 [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/)
        - 思路 1: DP, 定义 `dp[i]` 为 第 i 个数字结尾的最长上升子序列的长度, 注意 第 i 个元素必须被选中; 递推公式 `dp[i] = max(dp[j]) + 1`, 其中的 j 要求 `nums[j]<=nums[i]`
            - 时间复杂度 $O(n^2)$
        - 方法二：贪心 + 二分查找
            - 维护一个数组 `d[i]` ，表示**长度为 i 的最长上升子序列的末尾元素的最小值**, 用 len 记录目前最长上升子序列的长度. 注意到数组 d 是单调递增的
            - 我们依次遍历数组 nums 中的每个元素，并更新数组 d 和 len 的值。如果 `nums[i]>d[len]` 则更新 `len = len + 1`，否则在 `d[1…len]`中找满足 `d[i−1]<nums[j]<d[i]` 的下标 i，并更新 `d[i]=nums[j]`。
            - 由于是递增数列, 可以用二分搜索
            - 时间复杂度 $O(n log(n))$

### 273

- 2120. 执行所有后缀指令
    - 模拟机器人动作即可
- 2121. 相同元素的间隔之和 `中`
    - 给定一个数组, 计算其中相同元素所在的 index 之差, 返回所有这些距离的和
    - 用一个 defaultdict(list) 记录各个元素出现的位置.
    - 问题转化为对于一个数字出现的位置, 计算各个位置的 dist 和.
        - 注意数据量, 直接暴力遍历复杂度为 $O(n^2)$ 会超时
        - 思路1: 观察相邻两个元素相差的(子距离数量), 可得递推公式 `dp[i+1] = dp[i] -(n-2i-2) * (arr[i-1]-arr[i])`
        - 思路2: 计算 cumsum, 则 i 处的距离和为 `(cumsum[-1]-cumsum[i] - arr[i]*(n-1-i)) + (cumsum[i]-cumsum[0] - arr[0]*i)`
- 2122. 还原原数组 `难`
    - 就是对于一个数组 arr, 用一个正整数 k, 分别生成两个数组, `lower[i] = arr[i] - k, higher[i] = arr[i] + k`. 要求给定这两个数组的混合, 还原 arr
    - 注意看约束条件, 数组大小最多为 `1000` 所以暴力搜索即可, 题目只是比较繁琐
        - sort, 得到可能的 k
        - 用 `indexRecord` 记录每个数字对应的位置
        - 关键在判断一个 k 是否满足条件. 这里用了一个 `used` 记录每个所对应的元素所在位置, 遍历 nums 后, 若 `sum(used) == n` 则说明 k 满足条件
    - see [here](https://leetcode-cn.com/problems/recover-the-original-array/solution/huan-yuan-yuan-shu-zu-by-leetcode-soluti-nizi/)

### 274

- 5970. 参加会议的最多员工数 `难`
    - 每个人只有一个喜欢的人, 要求安排坐圆桌, 每个人左右要有他喜欢的人, 最大的可安排人数
    - 比较容易想到, 问题主要转化为求这样的有向图上的最大环,
        - 特殊情况是两个互相喜欢的人, 他们相互满足了要求, 因此左右可以有一条「喜欢人的链」, 并且左右的人都是满足的; 因此, 这种大小为 2 的环一个桌上可以安排多个
        - 参见 [这个题解](https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/solution/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/), 这种图叫做 **内向基环树 (pseudotree)**
    - 所以核心问题在于如何在 pseudotree 中找环, 比赛中的尝试没有想到如何「**剪枝**」超时了; 实际上, 可以通过一次 **拓扑排序** 剪掉所有的分支 (最后留在图上的点的度数最大为 1)
        - 具体实现上, 维护一个入度为 0 的队列, 对其喜欢的人的入度 -1, 如果减到了 0 则继续加入队列;
        - 这样, **拓扑排序后最终剩下的点都是成环的**(入度为 1).

### 275

- 5976. 检查是否每一行每一列都包含全部整数
- 5977. 最少交换次数来组合所有的 1 II
    - 滑动平均
- 5978. 统计追加字母可以获得的单词数
    - 注意审题
- 5979. 全部开花的最早一天
    - 两个数组, 分别是 播种 和 开花 所需的时间, 要求使得所有花都开放的最小时间
    - 题目给了干扰: 将一种花分成两次播种没有意义, 因为两者总的播种时间是一样的, 因此在过程中两种花都不会提早开花.
    - 于是可以化简为, 给依次播种的花进行排序
    - 可知, 总的播种时间是一定的, 目标在于减少开花所需时间. 因此每次根据开花所需时间排序, 选择需要最长时间的那种即可.

### 276

- 5980. 将字符串拆分为若干长度为 k 的组
- 5194. 得到目标值的最少行动次数
    - 给定一个目标数, 从 1 开始 +1, *2 两种操作, 限定了倍乘的次数 maxDoubles
    - 贪心, 从 target 往下 /2
- 5982. 解决智力问题
    - 给定一系列的题目, questions[i] = [pointsi, brainpoweri], 你选择做某一题的代价是只能跳过后面 brainpower 题
    - DP, 从后往前, 记录从该位置往后的最大解, 递推公式 `dp[i] = max([dp[i+1], point+dp[i+skip+1]])`
- 5983. 同时运行 N 台电脑的最长时间
    - 给定一组电池 batteries, 每个电池可以给一台电脑运行一定的时间. 可以把一个电池替换给不同的电脑, 要求让所有电脑同时运行的最长时间
    - 这里的限制条件为电量最大的 n 个电池, 小的电池看作对它们的补充.
    - 注意到: 一个电池的电量可以以**任意的比例**分到若干块电池上.
    - 因此, 可以将最大的 n 个电池看成一个「阶梯」, 其余的小电池理解为在这个池子里注水, 求高度

### 277

- 2148. 元素计数
- 2149. 按符号重排数组
- 2150. 找出数组中的所有孤独数字
- 2151. 基于陈述统计最多好人数 #hard
    - 两种角色: 好人只说真话, 坏人可能真也可能假
    - 给定一个矩阵表示每个人的陈述 (0,1,2 分别表示 坏人, 好人, 未判断), 要求计算好人最多可能数量
    - 注意到, **此题中坏人的陈述毫无信息量**!
    - 方法一：使用状态压缩枚举所有可能的情况
        - [here](https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/solution/ji-yu-chen-shu-tong-ji-zui-duo-hao-ren-s-lfn9/)
        - 用一个长度为 n 的二进制数 mask 表示好人坏人情况, 针对 mask 所表示的好人坏人分布, 判断是否合法
            - 冲突的情况只会出现在好人 i 的陈述中 (mask[i]=1)
            - 当 `s[i][j]=0 and mask[j]=1`, 或 `s[i][j]=1 and mask[j]=0` 时冲突
        - 实现一个 `check(mask)` 函数判断是否冲突
        - check 复杂度最大为 n^2, 枚举复杂度为 2^n, 因此总体复杂度为 `n^2 2^n`, 这里用位运算所以比较快?
    - 方法二: 回溯
        - 暴力枚举每个人是好人或坏人, 注意剪枝!!

### 278

- 2154. 将找到的值乘以 2
- 2155. 分组得分最高的所有下标
- 5994. 查找给定哈希值的子串
    - 定义一个字符串的哈希值 `hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m`
    - 给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 `k` 的 子串 sub ，满足 `hash(sub, power, modulo) == hashValue` 。
    - 字符串长度为 e4, 如果暴力遍历, 当所要求的 k 数量级接近是复杂度是 e8, 会超时
    - 方法一: **滑动平均**, O(n)
        - 给出的哈希计算函数是一个等比求和数列，两者可以通过减去首元素，除以power再加上新元素的power的k-1次方计算。
        - 但是 **除法不满足取余的恒等性**。因此需要倒序，减去当前的值，乘以power再加上新元素的值。(乘法满足取余恒等)
        - 参见 [here](https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/cha-zhao-gei-ding-ha-xi-zhi-de-zi-chuan-fi8jd/)
- 2157. 字符串分组 #hard
    - 每个字符串包括了一组不相同的字符 (比如 cde), 定义两个字符串「相连」: 其一可以通过 添加/删除/替换(替换成相同字符也可, 即包括相同字符集合的两字符串相连) 一个字符得到另一个字符串。
    - 定义组: 如果一个字符串与该组中的任一字符串相连，则这个字符串属于该组。
    - 给一组字符串, 计算有多少个不同的组, 以及最大组包括的字符串数量。
    - 方法一：状态压缩 + 广度优先搜索
        - 显然是求连通分量的数量, 问题在于如何构建图? 如果是两两计算复杂度为 O(n^2) 超时;
        - 像这类题, 可以从每一个节点出发, 构造其所有可能相连的边, 例如这里就是按照「相连」的定义, 增删或者替换所有可能的字符, 这样复杂度为 O(nD^2), 其中 D 为字符字典大小
        - 具体而言, 为了进行图遍历, 用一个 used 集合记录所有遍历过的节点, queue 来维护当前进行BFS, 对于所有的节点进行遍历.
        - 状态压缩: 如何表示一个(小写字母)字符集合? 01编码转化为数字以进行压缩. 这样的好处还有方便表示相连边, 参见 `get_adjacent`
        - 参见 [here](https://leetcode-cn.com/problems/groups-of-strings/solution/zi-fu-chuan-fen-zu-by-leetcode-solution-a8dr/)

### 279

- 6000. 对奇偶下标分别排序
- 6001. 重排数字的最小值
    - 给一个数字 (可能为负数), 重拍求最小值
- 6002. 设计位集 #medium
    - 能够快速实现 fix(设置某一位为1), unfix, flip(翻转每一位), add, one(至少一个非零), count(非零位数量) 操作
    - 尝试直接用列表存储, 超时了, 可能是 flip, add, one, count 复杂度较高
    - 优化为 位存储+一个变量intcount存储非零位数量, 从而优化时间复杂度; 可以重新看看**位运算**使用技巧
- 6003. 移除所有载有违禁货物车厢所需的最少时间
    - 一个 01 序列表示违禁物品, 前后移除一辆火车代价位 1, 移除中间的一辆代价为2, 求移除所有违禁货车最小代价
    - 思路一: 从左边和右边非别累加计算单面的最小代价, 加起来求最小 (其实就是在不同的点分割).
        - 注意 更新公式(DP): 当 `s[i+1]=='1'` 时 `dp[i+1] = min(dp[i]+2, i+1)`, 因为若从左边全部移除的代价是 i+1, 从中间取走的代价是 +2
        - 为了计算的方便在头部加一个 [0]; 注意到在点 i 处分割的总代价为 `dp1[i]+dp2[i+1]`, 正好错位加和. 参见 [here](https://leetcode-cn.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/solution/qian-hou-zhui-fen-jie-dp-by-endlesscheng-6u1b/)

### 280

- 6004. 得到 0 的操作数
- 6005. 使数组变成交替数组的最少操作数
    - `[2,1,2,1,2,1,2]` 的形式, 要求奇数和偶数位置的数字不同
    - 分别对于 nums[0::2] 和 nums[1::2] 计数, 注意边界情况 (`len(collections.Counter(nums[0::2])) == 1`)
- 6006. 拿出最少数目的魔法豆
    - 给定一组袋子, 要么拿空, 要求最后剩下来的非空袋子里的豆子数量相同
    - 排序, 想像成一个阶梯, 最后留下来的就是一个矩形; 转化为遍历求矩形最大面积
- 6007. 数组的最大与和
    - 有编号为 1,2,...,numSlot的篮子, 要求把一个长度为 n 的数组放入篮子中, 每个篮子最多放两个数字!
    - 定义放置的分数为, 数字和篮子编号与 `nums[i] & (assign[i]+1)`, 其中 assign 表示 第 i 个数字放在第 assign[i] 个篮子中
    - 方式一: 暴力回溯
        - 用一个 records 数组保存每个篮子中球的数量
        - 回溯函数 `dfs(idx, curSum, curMax)`, 遍历 idx 放置每一颗球

### 281

- 6012. 统计各位数字之和为偶数的整数个数
- 6013. 合并零之间的节点
- 6014. 构造限制重复的字符串
    - 给定一组字符, 要求构造字典序最大的字符串, 限制每个字符最多连续的次数.
    - 当两个字符串长度不同时, 先序比较前面部分, 仅当 min(a.length, b.length) 时算较长的字符串字典序较大.
    - 思路
        - 根据题意, 应该是按照字典序, 尽量把大字符连续放在前面, 之间插入一个次大字符即可, 即 bbbabbba... 这样的形式(repeatLimit=3)
        - 关键在构造方法:
            - 每次取最大字符, 后面添加一个次大字符即可! 终止条件是没有次大字符了.
            - `bbba` 这种形式为一次循环所构造的, 当 a 没有的时候即终止 (终止条件!)
- 6015. 统计可以被 K 整除的下标对数目
    - 给定一个数组 nums 和一个正整数 k, 返回满足条件的下标对 `(i, j)` 的数目, 要求 `nums[i] * nums[j] % k == 0`, 即两数之积能够被k整除.
    - 思路
        - 考虑 `n1*n2 % k == 0` 的条件: n1和n2 和 k 的最大公约数之积能被k整除, 即 `gcd(n1, k) * gcd(n2, k) % k == 0`
        - 由于 k 的因子是有限的, 就可以对于 nums 中的数字分组. (Counter)
        - 对于一个组, 其中的数字与k的最大公约数都是 n1, 假设组大小为 len1
            - 考虑两种情况: 1. 其他组中能够能够配合n1的数字个数为 len2, 则交互共有 `len1*len2` 个数字; 2. 若 `(n1*n1)%k == 0`, 即自身就满足条件, 组内组合数为 `C(2,len1) = len1*(len1-1)/2`
        - 累计. 为了避免重复, 对于因子从大到小排序, 每组都和后边的因子比较
        - 注意: 特殊情况是 k==1

### 282

- 6008. 统计包含给定前缀的字符串
- 6009. 使两字符串互为字母异位词的最少步骤数
- 6010. 完成旅途的最少时间
    - 给一组公交车运行一轮的用时: `time[i]` 表示第 `i` 辆公交车完成 一趟旅途 所需要花费的时间。要求计算所有公交车运行至少 totalTrips 圈所需的最少时间。
    - 思路: 二分查找
        - 对于运行时间排序, 在一定区间内二分查找最短时间
        - 初始化: 考虑左边界, 假设所有车运行一圈都为最小的那一辆, 则最短时间 T 需要满足 `T//min(time) * n >= totalTrips`, 则最小为`T = min(time) * math.ceil(totalTrips/n)`
        - 这里复习一下二分: 循环 `l < r`, 每次查找的 `mid = (l + r) // 2` 有可能为 l. 因此在检查条件后, 根据是否满足分别设置 `r = mid, l = mid + 1` 从而保证不会死循环.
        - 具体而言, 这里要求最小的满足条件的数字, 则可以: 每次检查成功收缩右边界, 令 `r = mid`; 失败则拓展左边界 `l = mid + 1`, 从下一个点开始搜索.
        - 算一下这里的时间复杂度: 假设搜索长度为 L, 每次检查有效性复杂度为 O(n), 则总体为 `O(n * log(L))`, 其中长度约为 `L=totalTrips/n * timeSpan`. 本题中, 变量数量级为 `time[i]=totalTrips=1e7, n=1e5`, 可以看到主要复杂度在 `O(n)`
- 6011. 完成比赛的最少时间
    - 给定一组轮胎, `tires[i] = [fi, ri]` 表示第 `i` 种轮胎如果连续使用，第 `x` 圈需要耗时 `fi * ri ** (x-1)` 秒。
    - 同时给你一个整数 `changeTime` 和一个整数 `numLaps` , 表示换轮胎的时间和总圈数. 要求最短用时.
    - 思路: DP
        - 对于dp[i], 考虑两种情况: 1. 用一种轮胎, 则用时为 `f * (r**laps -  1) / (r-1)` (等比数列); 2. 递推, 则用时为 `dp[i] + dp[i-j] + changeTime` (j = 1...i-1).
        - 注意对于第一种情况, 次题中 numLaps=1e3, len(tires)=1e5, 直接暴力会超时. 因此需要对每一轮次可能达到最短时间的 tires 进行筛选,
        - 这里用了简单的策略: 计算换一个轮胎跑一圈的最短用时 `min0 = min(i[0] for i in tires) + changeTime`, 如果此时继续用轮胎i `i[0]*(i[1]**(laps-1))>= min0` 则不需要考虑了.

### 283

- 6016. Excel 表中某个范围内的单元格
- 6017. 向数组中追加 K 个整数 #medium
    - 给一个数组, 请你向 `nums` 中追加 `k` 个 **未** 出现在 `nums` 中的、**互不相同** 的 **正** 整数，并使结果数组的元素和 **最小** 。
    - 思路一: 模拟. 遍历数组 nums, 并从 1开始递增 `inc` 表示下一个可能可以追加的数字, 累计数组中空的元素.
- 6018. 根据描述创建二叉树
- 6019. 替换数组中的非互质数
    - 对于数组定义一个操作: 任意两个相邻的非互质数 (最大公约数gcd != 1), 将它们替换为其最小公倍数 （Least Common Multiple，LCM）. 返回这样操作之后的数组.
    - 思路一: **栈模拟**
        - 一个数字只能和左右两边的数字合并, 并且 x,y,z 如果可以合并的话先后顺序无所谓. 因此可以合并一遍即可.
        - 因此可以用 **栈** 来进行模拟 —— 每次入栈后看它能消去到前面多少数字.
    - 第一时间应该想到 stack 的…… 不过自己写了一个函数, 尽量对于左右两边进行合并, 居然超时了? 复杂度应该是完全一样的...
    - 线性复杂度应该是没问题的, 还尝试了 `@lru_cache` 也过不了, 本地调试完全可以过 LC 不知道为啥不行.

### 284

- 6031. 找出数组中的所有 K 近邻下标
- 5203. 统计可以提取的工件
- 5227. K 次操作后最大化顶端元素
    - 给一个非空栈和可操作数量k, 要求返回执行这些操作后, 能够留在栈顶的最大值. (如果执行完 k 次操作以后，栈一定为空，请你返回 -1)
    - 两种操作: 1. 弹出栈顶元素; 2. 压入弹出的某一个元素.
    - 思路一: 讨论
        - 先考虑边界: 什么情况下最后栈为空? `len(nums)==1 and k%2==1`
        - 而在一般情况下, 对于k次操作, 我们可以在栈顶留下第 1,...,k-1 和 k+1 个元素 (从1开始). 需要对k和数组长度n的关系讨论.
        - 另外, 需要确保 nums[:k-1] 操作中 k-1 非负, 添加到边界条件中.
- 6032. 得到要求路径的最小带权子图
    - 给一张带权图, 给定三个点, 要求返回 **边权和最小** 的子图 (的边权和)，使得在这个子图中从 `src1` 和 `src2` 出发都可到达 `dest` 。如果这样的子图不存在，请返回 `-1` 。
    - 分析
        - 注意到, 双点出发求最短路径的情况, 可能出现共用一条路径的情况. (此时, 最小边权和为 `s1->u, s2->u, u->d` 三条路径之和, 而非 `s1->d, s2->d`). 需要判断这种情况出现的边界:
        - 简单判断, 假设两点的最短路径分别为 d1,d2, 则共用的路径长度不能超过 d1+d2.
        - 因此, 暴力来解, 可以先从 s1,s2 出发BFS, 然后(逆)从d出发进行长度约束为 d1+d2 的BFS.
        - 为了判断所有可能的中间节点, 需要记录正反向BFS过程中所有经过的点的路径长.
    - 思路一: BFS + 节点判断
        - 首先, 从src1和src2出发, 返回距离d和在这一范围内的节点集合(及其路径长); 分别用 dist1, dist2 两个map记录两个范围内所有点的距离.
        - 然后在逆图上进行长度 d1+d2 约束的BFS, 同样记录各个点的路径长 dist
        - 遍历三个字典交集, 取最短距离 `dist[u]+dist1[u]+dist2[u]`.

### 285

- 6027. 统计数组中峰和谷的数量
    - 首尾的不算, 相同数字算一个峰/谷. 例如 [2,4,1,1,6,5] 就有三个
    - 思路: 遍历, 模拟
- 6028. 统计道路上的碰撞次数
    - 给定一个字符串表示车辆方向. L, R, S 分别表示左右和停止 。每辆车移动时速度相同。相向碰撞 2分, 一个静止的1分; 碰撞后都静止; 求最后的分数。
    - 思路: 模拟. 注意一些边界讨论.
- 6029. 射箭比赛中的最大得分
    - 12个区域得分分别为 0...11; 如果 `ak >= bk` ，那么 Alice 得 `k` 分。如果 `ak < bk` ，则 Bob 得 `k` 分; 现在知道Alice的分布, 要求Bob得分最高的一种方式
    - 思路: 复杂度不高, 直接DFS即可
- 6030. 由单个字符重复的最长子字符串 #hard
    - 给定一个字符串和一组查询, 每次查询会将`queryIndices[i]` 的字符更新为 `queryCharacters[i]`, 要求返回每次查询后, 字符串中保留的最大重复字符长度
        - 例如 `s = "babacc", queryCharacters = "bcb", queryIndices = [1,3,3]`, 将返回 `[3,3,4]`
    - TODO: 线段树

### 286

- 5268. 找出两数组的不同
- 5236. 美化数组的最少删除数 #修改数组
    - 定义美丽数组: (1) 长度为偶数; (2) 2i, 2i+1 位的数字不相同. 空数组也符合
        - 要求: 将一组数组转为美丽数组, 最少删除的数字个数
    - 思路: 贪心. 每遇到 **约束对** 不满足的情况, 这两个数字必然是相同的, 随便删除一个即可.
        - 若出现 [..., 1,1,2,2,3,3, ...] 的情况, 不管是前面删除使得三组相同数字处于不同的约束对, 还是删除最前面的 1, 效果是一样的.
- 5253. 找到指定长度的回文数 #回文数 #进制
    - 要求得到长度为 l 的回文数中的第 k 个; 超出限制则返回 -1
    - 思路: 递归
        - 注意这里回文数数量限制有两种: (1) 内部回文数可以以0开始, (2) 回文数定义, 例如长度为3的最小回文数为 101. 可知, 长度为 1/2 的回文数数量为 9, 长度为 3/4 的回文数数量为 90; 内部回文数数量为 10, 100, 1000...
        - 因此, 实际上是一个「进制」问题, 可以用递归来解.
        - 需要注意: 题目中要求得到第 ith个回文数, 从1开始; 但是 **在进制的计算中, 必须应该从0开始**. 例如, 进制为10, 则要求得到第13个 (其实是12)回文数, 应该计算 `div(12, 10) = 1, 2`; 在本题中, 外部的数字从1开始, 因此需要再加上1, 也即 `222`
- 5269. 从栈中取出 K 个硬币的最大面值和 #hard #排列组合
    - 给定一组栈和可以取的硬币数量k, 要求取到的面值最大.
        - 例如给定 `piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7`, 最大应该为 706
        - 复杂度: 栈数量 n<=1000; 操作次数 k<=2000
    - 思路: 转化为 #背包问题 #DP
        - `dp[i][j]` 表示从前 i 个栈中取出 j 个硬币的最大面值. 为了计算方便, 对于 piles 先取前缀和.
        - 遍历所用栈的数量. 对于第 i 个栈, 更新公式 `dp[i][j] = max(dp[i][j], dp[i-1][j-k] + piles[i][k])` 也即, 尝试从第 i 个栈中取出 k 个硬币.
        - see [here](https://leetcode-cn.com/problems/maximum-value-of-k-coins-from-piles/solution/zhuan-hua-cheng-fen-zu-bei-bao-pythongoc-3xnk/)
        - 参见: <https://oi-wiki.org/dp/knapsack/>
    - #技巧: 看到题目的第一感觉应该是背包, 然后因为没刷过题毫无思路. 看到上述解答之后, 发现本质上还是一个DP, 而所谓「背包」不过是更高阶的总结; 所以关键还在于对于问题的理解, 而非单纯套模板.

### 287

- 6055. 转化时间需要的最少操作数
- 5235. 找出输掉零场或一场比赛的玩家
- 5219. 每个小孩最多能分到多少糖果 #题型
    - 给一组糖果, `candies[i]` 表示第i堆糖果有多少, 将其分给k个人, 要求每个人拿到的数量相同, 糖果只能划分不能合并, 可以有多余的 (即堆数>k); 求每个人拿到的最大数量.
    - 思路: #二分搜索
        - 对于不同的糖果数 m, 原本每一堆糖果可以分配出来的数量是变动的; 难以给出一个准确的映射直接求解; 然而, 对于一个给定的 m, 判断是否足够分给k个人是简单的, 复杂度为 O(candidies). 因此, 考虑二分.
        - 用一个 `test` 函数判断分m个糖果是否可行; 在 [1, sum(candies)//k] 之间二分搜索.
        - #技巧: 对于二分搜索如果不确定边界条件, 可以最后再 test 一下进行判断
- 5302. 加密解密字符串
    - 题目好长 Orz, 总而言之就是给一个 {key:value} 的映射, 将一个字符映射到长度为2的一个字符串, key不重复但是允许values重复. 然后 key->value 是加密, value->key 解密.
        - 有约束, **所有允许的原字符串仅包含在一个 len<=100 的dictionary中**. (反向思维!)
        - 要求是设计一个数据结构, 支持加解密操作, 最多调用200次.
        - 复杂度分析: keys, values 的长度 <=26, 给出的待解密的字符串长度 <=200; 最多调用200次.
    - 思路1: 模拟 (DFS+Trie)
        - 正常的思路可能是直接模拟; 然而考虑到解密环节的一对多情况, 暴力求解会超时!
        - 容易想到的改进是 DFS+Trie, 参见 [here](https://leetcode-cn.com/problems/encrypt-and-decrypt-strings/solution/by-class_-8pci/)
    - 思路2: #逆向思维
        - 这里给定了所有可能的原字符串 (并且数量很小), 所以要钻的空子就是预计算所有可能的加密结果.
        - 见 [here](https://leetcode-cn.com/problems/encrypt-and-decrypt-strings/solution/by-endlesscheng-sm8h/)

### 288

- 6037. 按奇偶性交换后的最大数字
    - 注意审题! (虽然这题设置有点奇怪) 是 奇偶性 相同的数字可以交换, 而不是 奇偶index
- 6038. 向表达式添加括号后的最小结果 #medium
    - 在括号左右添加一对括号, 例如 `"12+34"` 变为 `"1(2+3)4"` 也即左中右三个元素的乘积, 要求最小化结果
    - 思路: 遍历两侧可以加入括号的index即可, 要注意边界情况有点烦
- 6039. K 次增加后的最大乘积 #蓄水 #分配
    - 给你一个非负整数数组 `nums` 和一个整数 `k`, 可以将k分配到数组元素上 (相加), 要求乘积最大.
    - 思路: intuition是填充最小的那些数字. 因此可以看作是 **阶梯水池蓄水** 的问题.
    - 注意复杂度: `nums.length, k` 为 1e5. 最开始遍历index时 (模拟蓄水过程), 每「上一个台阶」都修改整个序列 `nums[:index]`, 复杂度为 `O(n^2)` 会超时. 修改为记录遍历的终止位置 (最终蓄水高度) 后一次性修改.
- 6040. 花园的最大总美丽值 #hard #分配
    - 数组 flowers 代表每个花园的花数量, 数字 newFlowers, 可以分配到各个花园中. 花园的分数定义为:
        - 花的数量至少为 `target` 的花园为「完善的」, 每个花园有 `full` 分;
        - 剩余「不完善」的花园, 总共有 `min(num_flower) * partial`, 也即这些花园中 量最少的花数 * 一个分值.
    - 需要注意的是, 即使在可以完全填满的情况下, 也有可能不填满的分数更高. 因此比较繁琐需要遍历.
    - 思路0: 当时很繁琐的想法是, 先尽量尝试填出完善的花园, 然后利用剩余的花来提升其余花园的最少花数. 为此, 先对花园排序, 从右往左计算 `need_for_target` 为填满最大数量花园所需的花朵数; 从右往左 `need_for_partial` 累计「阶梯水池蓄水」所需数量 (将其余花园填到高度 flosers[i] 所需的数量).
        - 然后遍历所有可能的情况. 例如遍历 need_for_target 合法的 index, 然后用剩余数量 bisect `need_for_partial` 以尽量提升其余花园的最少花数.
        - 但是需要注意边界: 1) 本来所有花园都是满的; 2) 在 bisect 时需要考虑 `need_for_partial` 的边界. 当时没想好第一点结果错在了最后一个考验复杂度的用例上, 结果没查出错误.
    - 思路: 好吧, [官方](https://leetcode-cn.com/problems/maximum-total-beauty-of-the-gardens/solution/hua-yuan-de-zui-da-zong-mei-li-zhi-by-le-18d8/) 的解答也是这样的, 不过更简洁些.

### 289

- 6070. 计算字符串的数字和
- 6071. 完成所有任务需要的最少轮数
- 6072. 转角路径的乘积中最多能有几个尾随零 #乘积
    - 给定一个矩阵, 一条「转角路径」最多出现一个转折, 求所有路径乘积的尾随零的最大数量.
    - 思路: 1) 显然, 路径越长越好, 所以折角的两条边可以直接到矩阵的边上. 2) 为了计算乘积的「尾随零」, 注意到0的数量完全取决于 2/5 因子的数量; 3) 因此, 分别计算行和列级别的前缀和, 然后遍历所有可能的折角.
- 6073. 相邻字符不同的最长路径 #DFS #树 #路径
    - 给一棵树上的节点都定义一个 label, 要求返回树上一条相邻节点的label不同的最长路径的长度。
    - 思路: 正常 DFS 即可. 注意: 1) 最长路径可能在节点的子树中, 因此需要在遍历过程中更新全局变量; 2) 注意DFS返回: 「从该节点出发的子路径的最大长度」, 而全局维护的是「一条符合条件的路径的最大长度」, 注意区分.

### 290

- 6041. 多个数组求交集
    - 求给定的所有数组的交集. 思路: 直接调用 Python API 暴力解决
- 6042. 统计圆内格点数目
    - 每个圆通过 (x,y,r) 所定义, 要求计算这些圆所覆盖的整数点数量. 思路: 暴力遍历
- 6043. 统计包含每个点的矩形数目 #bisect
    - 给定一组点所定义的矩形和一组点, 对于每个点, 要求判断包含该点的矩形的数量
    - 重点是数量级分析: `1 <= rectangles.length, points.length <= 5 * 10^4` 因此无法暴力判断
    - 注意这里的条件, (x,y) 中, `1 <= x <= 1^9; 1 <= y <= 100`, 因此, 构建 y2x, 分别排序即可.
    - 此时, 对于每一个点, 从 `recY >= pY` 的最多 100 个序列中进行 bisect 即可.
- 6044. 花期内花的数目 #区间划分
    - 每朵花 [start, end] 定义开花时期; 对于每一个在某时刻来的人, 返回此时开花数量.
    - 思路: 排序累计, 二分.
        - 转化为, 统计时间维度上, 不同区间内的花朵数量 (这样就可以二分查找了). 为此, 对于 start, end 两类节点统一排序, 然后记录各个变化的时间点即可
        - 具体而言, 用 `timeSplits, flowerNums` 两个数组记录变化时刻和该区间内的花朵数量.

### 291

- 6047. 移除指定数字得到的最大结果
    - 给定一个字符串num, 可以删除指定的一个数字d, 要求删除后的数字最大
    - 思路: 从左往右遍历, 对于位置i的数组d满足 `num[i]<num[i+1]`, 则显然可以删除该数字. 否则, 应该删除最后一个数字d所在的位置.
- 6048. 必须拿起的最小连续卡牌数
- 6049. 含最多 K 个可整除元素的子数组
    - 条件: 子数组中能够被数字 p 整除的元素的个数最多为 k
    - 对一个数组的所有 **连续非空** 子数组, 计算满足条件的不同的数组数量.
    - 思路: 本题复杂度为 `1 <= nums.length <= 200`, 因此用一个 isPdivisible 数组记录每个数字是否可被整出, 然后用一个set记录出现的不重复子数组即可.
- 6050. 字符串的总引力 #hard #题型 #排列组合
    - 定义一个字符串的引力: 不同字符的数量. 要求所有子字符串的引力之和.
    - 复杂度: `1 <= s.length <= 10^5`
    - 尝试了对于每一个长度进行「滑动窗口」, 复杂度为 O(n^2), 显然会超时.
    - 思路: 遍历累计
        - 考虑序列中某一个ch会在多少个子串中出现?
        - 不考虑本题, 一般情况下, 对于位置idx的ch, 序列 `...xxx[ch]xxx...` 的子串中出现ch的个数为: `(idx+1) * (len-idx+1)` 也即左右两边的长度分别匹配.
        - 本题中, 只有在子串中第一次出现的ch才计数假设. 因此假设出现的位置分别为 `idx[1], idx[2],...idx[i], ...`. 对于第 i 个, 其 **作为第一个ch出现在子串中** 的数量为 `(idx[i]-idx[i-1]) * (len-idx[i]+1)`. 注意相较于之前的公式左边界进行了限制.
        - 因此, 在遍历过程中, 对于不同的ch分别记录出现的 idx, 并累计计数.
    - 思路二: 类似DP.
        - 考虑从长度为 i 的前缀字符串拓展到 i+1 的变化情况. 增加了 i+1 个子串, 分别是 `s[1:i+1], s[2:i+1]...s[i+1:i+1]`. 我们要计算这些新子串所包括的引力值: 两部分
            - 末尾字符的: `idx[i+1]-idx[i]`
            - 其他字符的引力值 等价于 **所有以第i个字符结尾的子串的引力值**. 记这个值为 `sum_g`, 易知迭代公式 `sum_g[i+1] = sum_g[i] + (idx[i+1]-idx[i])`
        - see [here](https://leetcode-cn.com/problems/total-appeal-of-a-string/solution/by-endlesscheng-g405/)


### 292

- 6056. 字符串中最大的 3 位相同数字
- 6057. 统计值等于子树平均值的节点数
    - 对于一棵二叉树, 统计「节点值 = 节点所定义的子树中所有节点值的平均值」的节点数量
- 6058. 统计打字方案数
    - 按照 0-9 到字母的键盘映射 (例如, 按 `'5'` 两次得到字母 `'k'`). 这样, `33` 可能表示 `dd` 或者 `e`.
    - 给定按键的序列, 计算其映射出来的字母的方案数
    - 思路: #DP + 累乘
        - 首先, 对于一个数字, 比如 `2` 映射到 `abc`; 给一个长度为 i 的连续 2, 其可能的方案数是: `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`. 因此先用DP预先计算好所有的结果.
        - 然后对于案件序列按照上述 DP 累乘即可
        - 注意: 1) 一个数字可能对应 3/4 个字母, 需要区分; 2) 这样 DP 递归的数字很大, 要在计算过程进行 MOD, 自己提交时没有加, **Python 大整数计算超时**.
- 6059. 检查是否有合法括号字符串路径 #括号匹配
    - 给定一个仅包括 `()` 的grid, 要求判断从左上到右下是否存在一条路径, 使得括号序列合法.
    - 思路0: DFS, 超时了! 因为grid搜索的复杂度为 2^n, 这里n=100还是会超.
        - #cache
        - 改进: 参考 [here](https://leetcode-cn.com/problems/check-if-there-is-a-valid-parentheses-string-path/solution/tian-jia-zhuang-tai-hou-dfscpythonjavago-f287/) 加了 cache 之后过了
        - 离谱的是, 用默认的 `lru_cache(maxsize=128)` 会超时, 答案中用的是 Python 3.9 新的 `cache = lru_cache(maxsize=None)` 就可以过, 而且速度很快, 可能是 lru_cache 的实现太重了吧
    - 思路1: #DP
        - 从上往下一层一层遍历: 没一点可以由左侧或者上方的节点转移过来
        - 用 `dp[i][j]` 记录从左上角遍历到 (i,j), 剩余的左括号的数量, 用 set 记录.
        - 转移: 对于 (i,j), 取 `dp[i-1][j], dp[i][j-1]` 的 union, 然后根据 `grid[i][j]` 是左/右括号, 对于集合中的每个元素 +/-1, 注意不能出现负数

### 293

- 5234. 移除字母异位词后的结果数组
    - 给定一组word, 对于相邻的两个词, 若其包含的字符相同, 则删除前一个word (这样可以保证无论删除顺序最后的结果一致). 要求 最后的结果
    - 思路: 模拟.
- 6064. 不含特殊楼层的最大连续楼层数
- 6065. 按位与结果大于零的最长组合
- 6066. 统计区间中的整数数目 #hard #二分
    - 关联: 0715, 那题更全一点
    - 要求实现一个数据结构, 支持插入和查询两种操作. 插入的元素是一个区间, 查询返回这些区间所包含的所有整数.
    - 思路0: 直接暴力排序 (因为两个相邻的区间一定是不相交的).
        - 每次插入采用二分查找. 然而, 由于采用数组存储, 这样插入的复杂度仍为 O(n).
        - 原本修改index的方式采用了 `self.left = self.left[:idxL] + [valueL] + self.left[idxR:]` 的形式, 超时
        - 显然 `self.left[idxL:idxR] = [valueL]` 这样的效率更高, 直接 100% 了
        - see [here](https://leetcode.cn/problems/count-integers-in-intervals/solution/chun-er-fen-by-migeater-t5kh/)
    - 当然, 更优雅的方法是线段树?

### 294

- 6074. 字母在字符串中的百分比
- 6075. 装满石头的背包的最大数量
- 6076. 表示一个折线图的最少线段数
- 6077. 巫师的总力量和 #hard #单调栈
    - 对一个子数组, 定义score为 **最小元素 * 子数组元素和**, 现给定一个数组求所有子数组的score之和.
        - 结合了 0907 和 1856
        - 复杂度: 长度 1e5, 每个元素 1e9
    - 思路1: #单调栈 #前缀和
        - 考虑「一个元素在哪些子数组作为最小值」? 类似 0907, 利用单调栈求左右的边界.
        - 这些子数组的和如何计算? 参见下面的公式分析, 通过「前缀和的前缀和」.
        - 另外注意 cumsum的使用: 为了得到 arr[l:r] 的和, 可以使用 cumsum[r+1] - cumsum[l]
            - 例如, 对于数组 [1,2,3], 通过 `itertools.accumulate(arr, initial=0))` 得到前缀和 [0,1,3,6], 则 arr[0:2] = cumsum[3] - cumsum[0] = 6
    - 总结: 利用数学公式进行严谨的推导 (和思维方式).
    - from [here](https://leetcode.cn/problems/sum-of-total-strength-of-wizards/solution/dan-diao-zhan-qian-zhui-he-de-qian-zhui-d9nki/)

设子数组右端点为 $r$, 左端点为 $l$, 当前枚举的元素下标为 $i$, 那么有 $l \leq i \leq r$ 。 设 strength 数组的前缀和为 $s$, 在范围 $[L, R]$ 内的所有子数组的元素和的和为
$$
\begin{aligned}
& \sum_{r=i+1}^{R+1} \sum_{l=L}^{i} s[r]-s[l] \\
=& \sum_{r=i+1}^{R+1}\left((i-L+1) \cdot s[r]-\sum_{l=L}^{i} s[l]\right) \\
=&(i-L+1) \cdot \sum_{r=i+1}^{R+1} s[r]-(R-i+1) \cdot \sum_{l=L}^{i} s[l]
\end{aligned}
$$
因此我们还需要计算出前缀和 $s$ 的前缀和 $s s$, 上式即为
$$
(i-L+1) \cdot(s s[R+2]-s s[i+1])-(R-i+1) \cdot(s s[i+1]-s s[L])
$$
累加所有贡献即为答案。

## 双周赛 D60-D100

### D60

- 1991. 找到数组的中间位置 / 0724. 寻找数组的中心下标
- 1992. 找到所有的农场组 #题型
    - 找到一个 grid 中的所有矩形, 矩形之间满足不相邻
    - 思路: 模拟
- 1993. 树上的操作
    - 需要构建一种树结构, 能够实现 Lock, Unlock, Upgrade 操作. 其中 Lock, Unlock 操作针对单个节点比较 naive.
    - Upgrade(node, user) 操作要求满足: 1) 节点及其祖先节点未上锁, 2) 其孩子节点至少有一个上锁.
    - 思路: 对于节点维护 parent, children, lockUser 属性, 在 Upgrade 操作中向上向下分别遍历检查条件.
- 1994. 好子集的数目 #hard
    - 给定一组数字, 都不大于30. 求满足条件的所有子集的数量, 条件为: 子集中所有数字的乘积可以 = 不同的质数的乘积.
    - 方法一：#状态压缩动态规划 #状态压缩
        - [here](https://leetcode-cn.com/problems/the-number-of-good-subsets/solution/hao-zi-ji-de-shu-mu-by-leetcode-solution-ky65/)
        - 由于数字都比较小, 可以罗列所有的质数 `primes=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]`
        - 对于一组数字, 它们所用到的质数可以通过状态压缩来表示, 即 0/1 表示以上10个质数用到了哪几个, 记为 mask
        - 考虑 DP: 用 d`p[i][mask]` 表示只使用数字 `2~i`, 并且所用的数字的质数组合为 mask, 这样的子集的数量.
            - 状态转移方程: 若 数字i本身包含平方因子, 例如 4, 12 等, 则该数字无法采用, `dp[i][mask] = dp[i-1][mask]`;
            - 否则, 假设i包含的质数组合为 subset, 则 `dp[i][mask] = dp[i-1][mask] + dp[i-1][mask\subset] * freq[i]`, 其中的 subset 必然是 mask 的子集, mask\subset 可以异或得到
        - 因此, 从 i=2开始遍历到 30, 最后的结果 `sum(dp[30][mask])` 表示所用的质数组合为 mask 的方案数量. 注意 `dp[][0]` 没有意义: 因为 mask=0 表示没有取到任意质数.
        - 需要注意的是数字 1, 其作为因子不影响乘积, 因此可以取任意数量; 然而, 单纯用数字1不满足条件. 两种方案:
            - 取 `dp[1][0] = 1`, 从而避免 `dp[i-1][mask\subset] * freq[i]` 式子中的判断; 最后取 `sum(dp[30][1:]) * 2**freq[1]`
            - 也可以初始化 `dp[1][0] = 2**freq[1]`, 表示单纯用 1 的组合数量; 最后取 `sum(dp[30][1:])` (因为单纯用数字1不满足条件)

### D61

- 2006. 差的绝对值为 K 的数对数目
- 2007. 从双倍数组中还原原数组 #题型
    - 对于一个数组的所有数字变为双倍, 混入原数组. 现在要求还原数字.
    - 思路: Counter 之后从大到小遍历.
    - 特殊: 0 的双倍还是 0
- 2008. 出租车的最大盈利 #medium #题型
    - 出租车从 1开到n, 给定一组 `rides[i] = [start_i, end_i, tip_i]` 表示可以接到的单子, 每单的价格为 `end_i - start_i + tip_i`, 要求一趟下来最多获得多少钱.
    - 复杂度 n 为 1e5, rides 长度 3e4
    - 思路: #DP
        - 用 dp[s] 表示从时刻 s 开始接单的最大收益.
        - 因此, 对于 rides 基于 start 逆序排序. 对于第i个交易 `dp[start] = max(dp[start], dp[end] + fee_i)`.
        - 存储方式1: (超时了, 按理说复杂度应该还行?) 考虑到不连续性, 对于dp key 采用排序数组, 然后对于有值的那部分用字典存下来 (bisect 查找)
        - 存储方式2: 更为经典的连续存储方案, 保存一个长度为 n 的数组, 通过 `dp[start] = dp[start+1]` 进行初始化
- 2009. 使数组连续的最少操作数 #题型
    - 给定一个长度为L的数组, 每次可以对于数组的任意一个元素替换为任意的值, 要求最少替换次数, 是的数组中的元素构成连续的L的整数. 例如 nums = [4, 2, 5, 3] 是 连续的
    - 思路1: 排序+ #双指针
        - 注意到出现多次的数字一定需要被修改, 因此取 unique 然后对于数组排序. 用 left 指针从左往右扫描, 尝试移动 right 指针, 满足 `nums[right] - nums[left] < L`.
        - 这样对于每一个 left 位置, 原数组中保持不变的index区间为 [left, right], 每次更新答案 `ans = min(ans, L-(right-left+1))`
        - see [here](https://leetcode-cn.com/problems/minimum-number-of-operations-to-make-array-continuous/solution/on-zuo-fa-by-endlesscheng-l7yi/) 对于 right 如果不用双指针还可以直接 bisect

### D62

- 2022. 将一维数组转变成二维数组
- 2023. 连接后等于目标字符串的字符串对
    - 给定一组字符串 和一个目标字符串 target, 返回从这组字符串中选择两个拼接可以得到 target 的组合数量.
- 2024. 考试的最大困扰度 #题型
    - 给定一个包含两种元素的序列, 最大改动数量为 k, 尽可能使得出现的连续相同元素最大
    - 思路: #双指针 #滑动窗口
    - 针对每种元素遍历数组 (可以写成一个函数), 在双指针遍历过程中, 维护左右指针之间的修改数量不超过 k. 具体而言, 可以 for 循环 `right`, 在超出条件的时候步进 `left`
    - 参 [here](https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/solution/kao-shi-de-zui-da-kun-rao-du-by-leetcode-qub5/)
- 2025. 分割数组的最多方案数 #题型
    - 给定一个数组和一个数字k, 允许将数组中的某一个数字修改为k (也可以不修改), 要求最大化满足条件的分割数量.
    - 条件: 给定一个 `1<=pivot<n`, 将数组分割为 nums[0:pivot-1] 和 nums[pivot:n-1] 两部分 (闭区间), 使得两部分的和相等.
    - 思路: #双哈希表 #前缀和
    - 计数组的前缀和为 cumsum, 总和为 total.
    - 在不修改的情况下, 合法分割为 cumsum[i] = total-cumsum[i], 即 cumsum[i] = total/2.
    - 考虑修改的情况: 将第i个元素进行修改, 记变化量为 `d = k-nums[i]`, 对于i之前的元素其累计和不变, 之后的元素累计和增加d.
        - 因此, 1) 对于之前的元素, 合法条件变为 cumsum[j] = total+d-cumsum[j], 即 `cumsum[j] = (total+d)/2`; 2) 对i及其之后的元素, cumsum[j]+d = (total+d)-(cumsum[j]+d), 即 `cumsum[j] = (total-d)/2`
    - 因此, 在遍历修改元素 i 的过程中, 用双哈希表记录前后的 cumsum 分布情况.
    - 参 [前缀和+双哈希表+枚举修改元素](https://leetcode-cn.com/problems/maximum-number-of-ways-to-partition-an-array/solution/qian-zhui-he-ha-xi-biao-mei-ju-xiu-gai-y-l546/)
    - 注意: 这里要求的分割点必须在数组的中间, 在维护双哈希表的时候应该去掉total的情况. (见代码)

### D63

- 2037. 使每位学生都有座位的最少移动次数
    - 给定一组座位的位置和一组学生当前的位置, 要求对每个人匹配到合适的位置所需最少移动次数
    - 思路: 直接按照排序的结果一一匹配
- 2038. 如果相邻两个颜色均相同则删除当前颜色
- 2039. 网络空闲的时刻 #网络
    - 有 n 个节点, 0 号为服务器, 其他为数据节点. 节点之间通过网络连接, 经过一个时间段信息传递一条边.
        - 现所有的数据节点需要向服务器发送信息, 服务器收到后发送反馈. 每个数据节点还有一个 `patience[i]`, 表示在经历这么长时间没有收到回复则重发消息.
        - 要求计算经过多少时刻后, 网络上没有数据包 (空闲).
    - 思路: #BFS + 遍历
        - 每个数据节点和服务器的关系是独立的, 因此, 分别计算每个数据节点到服务器的距离, 遍历计算即可.
        - 对于数据节点 i 来说, 其距离和等待时间为 distance[i], patience[i], 则收到最后一个数据包的时间为: `2*distance[i] + 1 + 2*distance[i]//patience[i]*patience[i]`
        - 其中, `2*distance[i] + 1` 是第一个数据包发送到收到回复的时间, `2*distance[i]//patience[i]*patience[i]` 是可能有的接受不了重发数据包所需的额外时间.
- 2040. 两个有序数组的第 K 小乘积 #hard
    - 对于两个有序数组 nums1 和 nums2, 定义它们之间的交互乘积 `nums1[i] * nums2[j]`, 要求返回这些数中第 k 小的 (从1开始).
    - 复杂度: 两数组的长度为 5e4, 数字范围为 -1e5~1e5.
    - 思路 1: #二分查找 + #双指针 + #分类讨论
        - 基本的思路是二分查找可能的范围 `[-1e10, 1e10]`
        - 根据零将两个数组分别分为负数和非负数两部分, 然后分类统计两两组合之下, <= 待搜索的 m 的组合的数量; 由于采用双指针形式, 二分判断的复杂度为 O(L), 因此总复杂度为 O(Llog(N)), 这里 L为数组长度N为搜索空间大小.
        - [解答](https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/solution/yi-ti-san-jie-shuang-zhi-zhen-jie-bu-den-sqsu/) 还可以对于四种条件进行合并讨论
    - 思路 2: 也是二分查找框架, 不过在组合 nums1, nums2 的时候, 直接利用不等式条件, 内部进行一次二分搜索.
        - 这样, 内部二分的复杂度为 O(LlogL), 整体的复杂度为 O(NLlogL).
        - 具体而言, 对于 nums1[i], 要求 nums1[i] * nums2[j] <= m, 根据 nums1[i] 与0 的关系, 可以直接计算出如 nums2[j]<=m/nums1[i], 基于这个条件进行二分搜索.
    - 思路 3: 通过前缀和代替二分
        - 在上一种解法中, 复杂度增加了, 实际上我们可以通过 #前缀和 来避免内部的二分. 注意到 nums 的元素范围为 `[-1e5, 1e5]`, 我们可以利用前缀和得到 `cumsum[m]` 表示数组中包括多少个小于等于 m 的元素.

### D64

- 2053. 数组中第 K 个独一无二的字符串
- 2054. 两个最好的不重叠活动 #medium #题型
    - 有一组活动 (start, end, value), 可以选择其中一个/两个不重叠的活动, 要求value最大化.
        - 要求: 两个活动不重叠, 也即 end1 < start2
        - 复杂度: 活动数量 1e5, 起止时间 1e9
    - 思路1: #统一排序
        - 将活动的s/e时间统一进行排序, 排序元素为 (time, type, value), 这里的time是活动的起止时间, type是0/1, 0表示s, 1表示e, value是活动的value.
        - 维护 bestEnd 为截止到当前时间已经结束的单个事件的最大value. 这样在遍历排好序的数组的过程中: 1) type=0, 更新 `ans = max(ans, bestEnd+value)`; 2) 否则更新 `bestEnd = max(bestEnd, value)`
        - 注意, 这里有效的排序是 time和type. 题目要求两活动不重叠, 因此将 start排在end 之前 —— 这样如果有s/e时间相同, 会先更新 ans, 此时用的是上一时刻的 bestEnd.
        - [官方解答](https://leetcode.cn/problems/two-best-non-overlapping-events/solution/liang-ge-zui-hao-de-bu-zhong-die-huo-don-urq5/) 很优雅
    - 思路2: 排序 + #最小堆
        - 更为直观的思路: 先对于start进行排序. 在遍历的过程中, 如何得到早于该时刻的所有事件的最大value? 显然可以用一个最小堆来维护.
        - 具体而言, 堆的元素为 `(end, value)`. 遍历过程中同样维护 bestEnd: 对于当前事件的 start, 从堆出取出所有 end_i < start 来更新 bestEnd.
        - 参见 [here](https://leetcode.cn/problems/two-best-non-overlapping-events/solution/yong-you-xian-dui-lie-wei-hu-ling-yi-ge-8ld3x/)
- 2055. 蜡烛之间的盘子
    - 一个数组包括两种元素 (蜡烛、盘子). 给一个查询 [l,r], 要求返回在该子序列中, 被蜡烛包围的盘子数量.
    - 思路: 二分搜索. 先抽取提取所有蜡烛的idx, 然后在这个数组中进行二分. 注意边界判断.
- 2056. 棋盘上有效移动组合的数目 #hard
    - 大小为 8*8 的棋盘上有三种类型的的棋子 车, 象, 后 (rook, bishop, queen), 分别可以按照横竖、斜, 以及两者的组合这些方向移动.
        - 每个棋子可以在指定的方向上移动 k步, 然后停在该点. 若一个棋子先到达某点, 另一个棋子也需要经过该点, 则冲突.
        - 已知棋盘上最多有四个棋子 (最多只有一个后), 要求返回最终所有棋子的组合中有效移动的组合的数目.
    - 思路: #模拟 #product. 先根据棋子类型计算出其所有可能的 (direction, step) 组合, 然后模拟移动 (也即判断该组合是否合法).
        - 见 [here](https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/solution/python-producthan-shu-de-yong-fa-by-9813-p0cp/) typing 写得很规范
    - 总结: 可以充分 **利用 Python 的相关函数简化代码**, 例如这里用了两次 product 来 生成棋子的走法, 和生成所有棋子的走法组合.
    - [这里](https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/solution/go-mo-ni-by-endlesscheng-kjpt/) 还用了 DFS 的思路, 但复杂度上应该差不多.
        - 其实是更为「直觉」的想法 —— 用DFS来避免重复枚举, 然后DFS感觉上似乎比上面暴力组合可以降低一点计算? 但实际上代码会更复杂些.

### D65

- 2068. 检查两个字符串是否几乎相等
- 2069. 模拟行走机器人 II #medium
    - 模拟一个机器人沿着矩形的边缘行走, 每次下一步要出边界的时候, 进行右转. 要求实现一个类, 可以 1) 查询机器人的位置和方向; 2) 要求机器人前进 num步.
        - 初始状态为 (0,0)点, 方向向右.
    - 思路1: 直接模拟.
        - 然后, 由于矩形的范围不是很大, 而前进的步数可能很高, 因此需要避免重复走圈 (`num = num%self.circleLen`)
        - 这样就遇到一个边界情况: 当机器人到达边界点的时候方便不变, 要走下一步方向才会变化; 因此其实状态的方向为向右, 但下一次机器人到达该 (0,0) 点时的方向应该是向下. 需要特殊处理一下
    - 思路2: 直接记录位置到方向的映射
    - 如[官方答案](https://leetcode.cn/problems/walking-robot-simulation-ii/solution/mo-ni-xing-zou-ji-qi-ren-ii-by-leetcode-lhf24/) 所言, 可以直接得到位置到行动方向的映射
        - 这样, 对于矩形的每一个位置建立 index, 然后在行动的时候根据前进方向整除得到机器人的 index 即可.
- 2070. 每一个查询的最大美丽值 #题型 #medium
    - 有一组 (price, beauty) 所定义的商品. 要求在小于 O(n) 的复杂度内查询价格在 p 以下的商品中, beauty 的最大值.
    - 复杂度: 物品数量 1e5, price/beauty 值 1e9.
    - 思路: #索引 + #二分
        - 不能直接对于每一个价格建立到最大美丽值的映射, 因此考虑只对出现过的价格建立映射, 然后二分查找答案即可.
        - 具体而言, 对于出现过的所有价格, 预计算 (price, maxBeauty) 的索引, 表示在price以下的所有价格中, 最大的美丽值.
        - 查询时, 对于所要查询的 p, 在price中二分搜索 index, 然而返回对应的 maxBeauty 即可.
- 2071. 你可以安排的最多任务数目 #题型 #二分
    - 给定一组任务和工人, 当工人的分数高于任务分数时可以完成; 另外给 k 个药丸可以增加单个工人的 strength 点能力值 (一个人只能用一次). 求最多匹配的数量.
    - 复杂度: n 个任务和 m 个工人为 5e4, 能力值大小 1e9
    - 思路: #二分搜索.
        - 匹配的数量范围为 [0, min(m,n)]. 关键在于如何检查是否可以得到 k 个匹配?
        - 用贪心: 如果可以有 k 个匹配, 显然是 k个能力最大的工人和 k个所需点最小的任务. 排序, 然后对任务从高到低遍历: 1) 能力值最大工人可以胜任, 则直接匹配; 2) 否则, 从吃了药丸可以胜任的功能中找到能力值最小的, 小号一颗药丸.
        - 终止条件: 药丸用完了, 或者加上 strength 也没有人可以胜任.
    - 注意复杂度分析: 每一次检测, 最多需要再 min(m,n) 个候选工人中进行二分搜索, 因此为 `O(min(m,n) * log(min(m,n)))`. 整体二分的复杂度为 `O(min(m,n) * log^2(min(m,n)))`.
    - 事实上可以优化: 用「双端队列」来维护所有可以（在使用药丸的情况下）完成任务的工人，此时要么队首的工人被选择（删除），要么队尾的工人被选择（删除），那么单次删除操作的时间复杂度由 O(log(min(m,n))) 降低为 O(1)
    - see [here](https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/solution/ni-ke-yi-an-pai-de-zui-duo-ren-wu-shu-mu-p7dm/)
    - 技巧: **二分查找时, 可以额外用一个 ans 记录二分的结果, 而不需要纠结最后返回 l or l-1**

### D66

- 2085. 统计出现过一次的公共字符串
- 2086. 从房屋收集雨水需要的最少水桶数 #题型 #medium #贪心
    - 给定一个字符串, 两种元素表示房屋和空地; 要求在每一栋房屋边上放一个水桶, 最少的数量 (无法安排则返回 -1).
    - 第一次做的时候思路很乱: 尝试一次遍历解答, 用两个指针分别记录最近的一个水桶和最近的一个没有被覆盖的房屋. 但是判断比较复杂.
    - 思路1: 重新做发现了更简单粗暴的思路 (没有必要追求一次遍历, 反正复杂度不要超即可). 也是 #贪心 的思路: 这里能够节省水桶的情况就是其两侧都有房屋.
        - 因此, 每遇到 `H.H` 的情况就放置一个水桶 (注意 `H.H.H` 这种情况, 要对于以覆盖的房屋进行标记). 这样, 剩余的没有被覆盖的房屋在其相邻的空地放一个水桶即可.
    - 思路2: 贪心 see [官方答案](https://leetcode-cn.com/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/solution/cong-fang-wu-shou-ji-yu-shui-xu-yao-de-z-w2vj/)
        - 这里的想法更为简洁: 因为实际上, 我们放置冗余水桶的情况只可能为 `.H.H` 这样的特征错放在第一个位置上了. 因此, 贪心只需要 **优先将水桶放在右侧**.
        - 只考虑遍历到房子的情况: 1) 两侧有了, 则不放; 2) 否则, 判断该点的房屋是否可被覆盖, 优先放右侧.
        - 改进: 这里需要记录水桶的放置情况, 1) 可以通过修改数组 (将原本的字符串转为可变结构); 2) 进一步可知, 对于右侧放水桶的情况, 可以直接向前跳两个, 从而避免了修改字符串.
- 2087. 网格图中机器人回家的最小代价
- 2088. 统计农场中肥沃金字塔的数目 #hard #题型
    - 给定一个gird, 每个格子 0/1 表示是否肥沃. 定义「肥沃金字塔」为 `.:.` 这种样子的 (高度 > 2). 要求统计所有肥沃金字塔 (还有倒三角也算) 的数目.
    - 解法1: #DP, 参见 [here](https://leetcode-cn.com/problems/count-fertile-pyramids-in-a-land/solution/tong-ji-nong-chang-zhong-fei-wo-jin-zi-t-paok/)
        - 关键在于如何判断一个格子是否是 (以及是多少个) 肥沃金字塔的顶点? 注意到, **一个高度为 h 的金字塔, 其顶点之下的三个元素也必然为高度为 h-1 的金字塔的顶点**. 例如这一观察, 可以得到递归方程.
        - 这样, 一个最大高度为 h 的金字塔, 顶点元素作为金字塔顶点的所有可能为 h-1 个. 为了计算的方便, 定义 dp 矩阵的元素:
        - 若不合法 -1, 合法则为最大可能三角的 h-1. (也即单一个肥沃格子, 无法构成三角, 定义其元素为 0)
        - 这样, 可以得到统一的递推公式: 当 i,j 位置合法的时候, `dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + 1`.
    - 思路2: #前缀和 判断底边中心点可以构成几个金字塔
        - 上一种 DP思路聚焦顶点, 我的直觉是看底边可以构成多少金字塔. 注意到, 一个金字塔, 其底边的每个元素之上肥沃土地的数量形如 `12321`. 因此可以从上往下累计每块土地之上的肥沃土地数量 (复杂度 mn).
        - 然后, 对于每一行序列, 例如 `[3,3,3,3,1]`, 我们需要判断以这一行为底边的金字塔数量.
        - 分析可知, 以每个元素为底边中心的金字塔数量为 [0,1,2,1,0]. 如何计算? 我们用左右两个数组来表示当前元素左右的情况.
        - 例如, 这一例子中, left=[0,1,2,2,0], right=[2,2,2,1,0]. 综合这两个约束, 求和可知这一行共包含 4个金字塔.
        - 如何更新这一约束? 以left为例, 初始化 lLimit=-1, 对于位置j的元素有递推公式 `lLimit = min(lLimit+1, v-1)`: 1) 金字塔是阶梯形的; 2) 当前高低为v点的元素为中心最多有 v-1 个金字塔.


### D67

- 2099. 找到和最大的长度为 K 的子序列 #题型 #easy
    - 给定一个序列, 要求返回一个长度为 K 的子序列 (元素可以不连续, 但要求顺序不变), 使其和最大.
    - 思路: 返回最大的 k 的元素, 同时要求保留idx信息.
- 2100. 适合打劫银行的日子 #medium #题型
    - 求数组中所有满足条件的idx. 条件为: 该元素在 nums[i-k:i+k] 这一区间内为谷底.
    - 思路0: 对于第i个元素, 符合条件意味着左侧长度k的区间非递增, 右侧长度k的区间非递减. 因此考虑滑动窗口: 计算窗口内的增加元素数量.
        - 这样, 对于每个idx, 从左往右和从右往左计算 validL, validR, 汇总所有符合条件的idx即可.
        - 这里具体实现上复杂了: 先用 isUpL, isUpR 记录每个idx是否左/右上升, 然后滑动窗口计算 validL, validR. [here](https://leetcode.cn/problems/find-good-days-to-rob-the-bank/solution/gong-shui-san-xie-qian-zhui-he-yun-yong-gf604/) 指出滑动窗口可以通过前缀和直接得到.
    - 思路1: [官方](https://leetcode.cn/problems/find-good-days-to-rob-the-bank/solution/gua-he-da-jie-yin-xing-de-ri-zi-by-leetc-z6r1/)解答
        - 没有必要限制窗口大小: 对于每个元素, 分别维护左右非递增元素的数量, 只需要判断 `left[i] >= time and right[i] >= time` 即可.
- 2101. 引爆最多的炸弹
    - 每一个炸弹由 (x,y,r) 所定义, 若另一个炸弹在该炸弹的r范围内, 则可连环引爆. 要求返回最多引燃一个可以引爆的炸弹数量.
    - 思路: 构图后BFS
    - 注意: 这里炸弹之间是有向边! 因此不是 #并查集 ! 思路, 对于炸弹两两构建有向边, (复杂度 n^2), 然后从每个点出发 BFS (整体复杂度n*n^2), 找到最大可引爆数.
- 2102. 序列顺序查询 #hard #题型 #优先队列
    - 比较特殊的插入和查询要求: 实现一个数据结构, 支持插入元素, 查询大小为第 k 个元素. 这里的查询有些特殊: 第i次查询需要返回的是第i大的元素.
    - 复杂度: add, get 两种操作的复杂度为 1e4. 元素结构为 (score, name) 要求 score 降序 name 升序. score 范围 1e5.
    - 思路0: #二分 理论的插入复杂度为 O(n), 但这里没有掐直接过了.
    - 思路1: 考虑本题的特殊性: 每次查询的元素是特定的. 具体而言, 我们每次关心的只是查询次数k附近的元素.
        - 因此, 可以分别维护一个最小堆MinHeap 和最大堆MaxHeap: 用最小堆存储前k大的元素, 用最大堆存储其他元素.
        - 每次查询时, 返回最大堆堆顶元素即可
        - 而插入时, 若元素比 MinHeap 堆顶元素大, 则 pushpop, 然后加入到 MaxHeap; 否则直接入 MaxHeap.
    - Python: 注意heapq只提供了最小堆 (优先队列), 并且需要对于数字和字符串按照不同的方式排序, 因此需要手动写数据结构实现 `__lt__` 或 `__gt__`. 例如对于最小堆而言, 更小的元素优先, 则较小元素的 `__lt__` 函数应该返回 True.
    - 技巧: Python 的 sortedcontainers 还提供了现成的 SortedList 使用. 插入、删除的复杂度约为 O(log n).

### D68

- 2114. 句子中的最多单词数
- 2115. 从给定原材料中找到所有可以做出的菜
    - 给定一个菜单, 每道菜的成分可能包括食材或其他的菜品, 要求在一定的初始食材下能够得到的所有菜品
    - 思路一: 本题数据量比较小, 可以暴力遍历. 用一个 flag 记录一次遍历是否有新的菜品(食材) 生成, 当没有时即结束
    - 思路二: 依赖关系构成图, 显然可以用 `拓扑排序` 解决, see [here](https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/solution/cong-gei-ding-yuan-cai-liao-zhong-zhao-d-d02i/)
- 2116. 判断一个括号字符串是否有效 `中`
    - 给定一个在某些位上固定的字符串 (例如 `s = "))()))", locked = "010100"`), 判断能够通过修改其他自由位使其成为合法的括号序列
    - 思路一: 关注 lock 部分 (剩下偶数个自由位一定可以匹配)
        - 先尝试匹配 lock 部分的字符串, 记录未成功匹配的位置 (三种情况, 最后剩下 `((`, `))` or `))((`; 和 空白符号的位置;
        - 利用 space 字符串来匹配剩下的左右括号 leftStack, rightStack
        - 原本分了上面三种情况讨论, 实际上可以合并: 用 space 最前面的部分匹配右括号, 最后面的部分匹配左括号, `len(spaces)>=len(leftStack)+len(rightStack) and all([i>j for i,j in zip(spaces[-len(leftStack):], leftStack)]) and all([i<j for i,j in zip(spaces[:len(rightStack)], rightStack)])`
    - 方法一：数学, see [here](https://leetcode-cn.com/problems/check-if-a-parentheses-string-can-be-valid/solution/pan-duan-yi-ge-gua-hao-zi-fu-chuan-shi-f-0s47/)
        - 定义了有效字符串「分数」的概念, 然后通过: 维护 1. 前缀 s[0..i] 可以达到的最大分数；2. 前缀 s[0..i] 「可以达到的最小分数」及「作为有效前缀所需的最小分数」两者的较大值. 这两个数组来进行判断.
- 2117. 一个区间内所有数乘积的缩写 `难`
    - 放弃了
    - 参见 [思路详解+详细讨论一下精度问题](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/fen-bie-ji-suan-qian-5wei-he-hou-5wei-si-dc9x/), Python 超时了. 另外 [here](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/yi-ge-shu-ju-tuan-mie-jue-da-bu-fen-dai-234yd/) 做了更多的分析

### D69

- 2129. 将标题首字母大写
- 2130. 链表最大孪生和
- 2131. 连接两字母单词得到的最长回文串
    - 给一组长度为2的字符串, 将他们拼接, 形成最大的回文串
    - 考虑 1. aa 的形式, 若数量为奇数, 只能放在中间, 若为偶数, 可以两侧对应位置放置; 2. ab + ba 的形式, 左右对称放置
- 2132. 用邮票贴满网格图
    - 给一个矩阵grid, 其中数字为1的位置不能使用; 要求用 stampHeight x stampWidth 的邮票去贴满所有空的位置, 返回能否实现. 矩阵不可旋转, 可以重叠.
    - 二维前缀和 + 二维差分
        - from [here](<https://leetcode-cn.com/problems/stamping-the-grid/solution/wu-nao-zuo-fa-er-wei-qian-zhui-he-e>
        - r-wei-zwiu/)
        - 首先, 利用 **二维前缀和矩阵** 可以快速计算 (x1,y1), (x2,y2) 区域内的元素和.
            - 前缀和 `m[x,y]` 表示 (0,0),(x,y) 所定义的矩阵之和;
            - 递推计算公式为 `m[x+1,y+1] = m[x+1,y]+m[x,y+1]-m[x,y]+matrix[x,y]`. 这里的前缀和矩阵 m 有哨兵, 即大小为 (m+1,n+1)
            - 利用二维前缀, 求 (x1,y1),(x2,y2) 所定义的子矩阵之和的计算公式为 `m[x2+1,y2+1] - m[x2+1,y1] - m[x1][y2+1] + m[x1,y1]`.
            - 在本题中, 计算grid的前缀和矩阵, 即可以用来判断该区域内是否有1.
        - 根据二维前缀和的计算, 可以定义 **二维差分矩阵**. 另参见 [here](https://zhuanlan.zhihu.com/p/439268614)
            - 计算公式为 `s[x,y] = matrix[x,y] - matrix[x-1,y] - matrix[x,y-1] + matrix[x-1,y-1]` (注意和上面前缀和的递推计算意义不一样)
            - 可知, 我们所定义的差分矩阵, 其前缀和就是原矩阵!!
            - 根据差分矩阵, 我们可以快速在 (x1,y1), (x2,y2) 范围内都加上一个数字: 等价于在其差分矩阵的 `(x1,y1),(x2+1,y2+1)` 位置+1, `(x2,y1+1),(x1+1,y2)` 位置-1.
            - 在本题中, 利用对于每个为空的坐标,尝试以其为左上角贴邮票, 利用差分矩阵记录贴上去的邮票所占据的位置. 最后利用差分矩阵还原, 计算每个位置的邮票数量, 若出现原本为空的位置没有贴上邮票, 说明不满足.
        - 注意, 为了边界条件, 1. 这里定义的前缀和矩阵第一行第一列为0; 2. 而根据差分的定义, 在更新(x2,y2)位置时候用到了 s(x2+1,y2+1), 因此形状也为 (m+1,n+1).

### D70

- 2144. 打折购买糖果的最小开销
- 2145. 统计隐藏数组数目
- 2146. 价格范围内最高排名的 K 样物品
    - 网格搜索, 0表示不能走, 不同的格子有价格, 要求找到价格在 pricing = [low, high] 区间内的位置.
    - 要求找到优先级最高的k个, 优先级为: 1. 距离; 2. 价格; 3. 行坐标; 4. 列坐标.
    - 思路: BFS.
        - 广度优先, 每一轮维护 paths 记录当前可到达的坐标, potentials 为满足pricing约束的坐标集合, 然后 `select(potentials, k)` 根据优先级筛选.
        - 注意边界条件: 1. 每一轮中,当paths为空时说明无法继续搜索; 2. 开始状态, 需要判断start点是否符合要求并加入visited.
- 2147. 分隔长廊的方案数
    - 简单

### D71

- 2160. 拆分数位后四位数字的最小和
- 2161. 根据给定数字划分数组
- 2162. 设置时间的最少代价
    - 设置四位的时间, 前后两位分别表示分钟和秒钟, 例如 `8090` 表示 80*60+90 秒
    - 给定 startAt ，moveCost ，pushCost 和 targetSeconds 分别表示初始的手指位置, 移动和按按钮的代价, 以及目标的秒数, 要求返回最小的代价. **前置0可以不输入**
    - 思路: 模拟
        - 注意到, 犹豫两位数字可以大于59, 因此同样的秒数可能有多种表示. 除了 1. 基本的 `minutes, seconds = targetSeconds//60 , targetSeconds%60`, 还有可能 2. 是 `minutes-1, seconds+60` (`seconds+60<100`), 计算两者较小的代价.
        - 用函数 `getCost(minutes, seconds)` 模拟该方案的代价.
        - 需要注意边界: 1. 当 `targetSeconds<60` 时 第二种方案非法; 2. 当 `targetSeconds>=60000` 时, 第一种方案非法. 因此可以在 getCost 函数中增加判断: `minutes>99 or seconds>99 or minutes<0 or seconds<0` 时返回 Inf, 更简单.
- 2163. 删除元素后和的最小差值
    - 给一个长度为 3n 的数组 nums, 要求删除其中 n个数字, 使得删除后, 数组前n个数字之和 - 后n个数字之和最小.
    - 方法一：优先队列 [here](https://leetcode-cn.com/problems/minimum-difference-in-sums-after-removal-of-elements/solution/shan-chu-yuan-su-hou-he-de-zui-xiao-chai-ah0j/)
        - 目标: 前n个数字之和最小, 后n个数字之和最大.
        - 可知, 最后剩余的两组数字, 其原始的分割点一定在 [n, 2n] 之间. 因此, 可以 遍历遍历每一个分割点, 分别计算前后的最小和最大和, 然后求最小值.
        - 为此, 可以分别建立一个最大堆和最小堆, 遍历 [n, 2n] 个数字 (pushpop), 记录每一个分割点的的值. 需要注意的是, 后半部分应该逆序, 注意代码.

### D72

- 2176. 统计数组中相等且可以被整除的数对
- 2177. 找到和为给定整数的三个连续整数
- 2178. 拆分成最多数目的偶整数之和
- 2179. 统计数组中好三元组数目
    - 给两个数组, 分别是 [0:n-1] 的一个排序, 要求找满足条件的三元组数量, 条件: (x,t,z) 出现在两数组中的次序是一致的.
    - 分析可知, 将nums1中数字在num2中的index依次写出来, 记为 numMap, 则结果就是该数组中递增的三元组的个数
    - 思路1:
        - 遍历 numMap, 对于一个数字 num, 考虑以num结尾的长度为2的递增数组的数量 —— 为数组之前部分比num小的元素数量; 记为 last1
        - 进一步考虑以num结尾的长度为3的递增数组的数量, 可知其为 last1 中, 所有小于num的组数之和.
        - 因此, 这里的核心问题在于: 实现一个数据结构, 可以 1. 查询其中比 query 小的数量; 2. 插入某一个数值的数量.
        - 该问题可以建模为 「**树状数组/线段树**」, 参见 [here](https://oi-wiki.org/ds/fenwick/)
    - 思路2 树状数组:
        - 已知, 问题可以转化为, **在一个数组中计算递增三元组的数量.**
        - 分别用两个 BIT, 计算位置i之前的比 num[i] 小的数量, 以及位置i之后的比 num[i] 大的元素数量. 这样最终的结果就是 `sum(low[i]*high[i] for i in range(n))`
    - 另见 [here](https://leetcode-cn.com/problems/count-good-triplets-in-an-array/solution/deng-jie-zhuan-huan-shu-zhuang-shu-zu-by-xmyd/)

### D73

- 6024. 数组中紧跟 key 之后出现最频繁的数字
- 5217. 将杂乱无章的数字排序
- 5300. 有向无环图中一个节点的所有祖先
    - 给一个 DAG, 要求返回每一个节点的所有祖先节点 (排序)
    - 思路一: 可以通过 DFS 找到节点的所有孩子, 在 **逆图** 上做即可
- 5237. 得到回文串的最少操作次数 #hard
    - 给一个字符串, 仅有的操作为交换相邻两个字符, 要求转为回文串的最小交换次数
    - 思路一: 两次贪心 [here](https://leetcode-cn.com/problems/minimum-number-of-moves-to-make-palindrome/solution/de-dao-hui-wen-chuan-de-zui-shao-cao-zuo-nnis/)
        - 首先需要理解: **逆序数** 等于一个 序列要变成升序排列所需要的相邻元素交换的最小次数。 see [here](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/ni-xu-shu-yu-pai-xu-de-nei-zai-lian-xi-wu-dai-ma-b/)
        - 先考虑偶数长度的情况: 可知, 对于 2m 个字符ch, 其中的前m个字符, 也一定在最终的回文串的前一半中, 并且它们之间的相对位置保持不变.
            - 因此, 分解为两步: (1) 组间交换. 先划分左右两个子串. 由于不改变相对位置, 其实我们就知道了原本字符串的每一个位置的元素, 在分为好左右组的字符串中的位置.
            - (2) 组内交换, 也即是的左右子串转换为对称. 由于没有相对位置变化, 因此我们固定左子串, 则对于右子串中每一个字符最终的位置其实我们就确定了 —— 等于求逆序数.
        - 而对于奇数情况, 简单令右子串多一个元素, 然后在左子串后加上那个中心的(奇数)字符, 则约束了右串排序中将其移动到中间.
    - 思路二: 贪心 [here](https://leetcode-cn.com/problems/minimum-number-of-moves-to-make-palindrome/solution/tan-xin-zheng-ming-geng-da-shu-ju-fan-we-h57i/)
        - 其实在上面的思路中, 我们已经知道了最终的回文串是怎样的 —— 左子串由所有字符的前一半出现位置决定, 右子串对称.
        - 因此, 更为贪心的策略是: 每次保留左侧的第一个字符, 将最右边的该字符移动到右侧, 这样就完成了匹配.
        - 对于奇数的情况, 只需要将其移动到中心即可.

### D74

- 2206. 将数组划分成相等数对
- 2207. 字符串中最多数目的子字符串
    - 有可以字符串 text 和长度为 2 的 pattern (记为字符 a 和 b), 可以对 text 插入一个字符 a/b.
        - 要求计算操作后 text 的子字符串恰好是 pattern 的数量. 注意「子字符串」的定义不要求连续, 因此 `aabb` 包括 四个子字符串 `ab`.
    - 思路: 注意到, 这里插入的字符最优解为在最前面插入a 或最后插入b (取决于text中a/b的数量). 而原本text自身的子字符串数量可以 O(n) 求解 (记录 countA, countB).
        - 特殊情况: a==b
- 2208. 将数组和减半的最少操作次数
    - 每次选择数组中的一个元素减半, 要求使得数组和减半需要的次数.
    - 思路: 每次选最大的即可. 采用 heap 实现. 注意 heapify 默认是最小堆, 因此需要取反.
- 2209. 用地毯覆盖后的最少白色砖块
    - 给一条黑白地板 floor 铺地毯, 要求剩余最少的白色. 给定 numCarpets 条长度为 carpetLen 的黑色地毯.
    - 思路: DP
        - 定义状态: dp[i][j] 表示用 i 条铺 **前面 j 个地砖**, 剩余的最少白色砖块数.
        - 状态转移: dp[i][j] = min(dp[i][j-1]+(floor[j]=="1"), dp[i-1][j-carpetLen]). 其中第一式表示不用地毯.
        - 参见 [here](https://leetcode-cn.com/problems/minimum-white-tiles-after-covering-with-carpets/solution/by-endlesscheng-pa3v/)

### D75

- 2220. 转换数字的最少位翻转次数
- 2221. 数组的三角和
    - 对于一个数组, 重复进行如下操作, 直到长度为 1, 返回最后的数据
        - 将相邻两个元素相加, 得到新的长度 -1 的数组.
    - 分析可知, 就是杨辉三角, 调用 math.comb(n-1, i) 即可.
- 2222. 选择建筑的方案数
    - 有两类建筑, 要求从中选择三栋, 选择的三个中相邻的类别不能相同. 返回所有方案的数量.
    - 思路: 1) 考虑中间的那栋楼, 则两侧的选择必须是另外一个类型; 2) 为了计数, 考虑 cumsum; 3) 为了避免确定变量, 可以讲 "001101" 转为 [2,2,1,1] 的形式
        - 具体而言, 可以分别从左到右, 从右到左计算累加和 (间隔为2的累加和, 例如上例为 [2,2,3,3]), 然后直接 `cumsumLeft[i-1] * newS[i] * cumsumRight[i+1]` 即可.
    - 写得复杂了, 由于形式只可能为 010/101, 实际上遍历一次index即可; 记录下目前已有的 1, 则遇到0时, 以这个0为中间数的方案数为 `count_a * total_a - count_a`, 参见 [here](https://leetcode-cn.com/problems/number-of-ways-to-select-buildings/solution/xuan-ze-jian-zhu-de-fang-an-shu-by-leetc-jhup/)
- 2223. 构造字符串的总得分和 #hard
    - 对于一个字符串, 从右往左得到长度为 1,2,... 的连续子串, 分别计算该子串与原字符串的最大前缀长.
    - **Z 函数**（**扩展 KMP**） 参见 <https://oi-wiki.org/string/z-func/>
    - 我们定义 Z 函数为: **z[i] 为 s[i:n-1] 与原字符串 s 的最长前缀匹配长度**.
        - 也即, `s[i:i+z[i]-1] = s[0:z[i]-1]` (闭区间), 称为 匹配段, 也可以叫 **Z-box**
    - 核心是要维护一个匹配区间 [l,r] (Z-box)) 满足该区间为前缀匹配; 在遍历过程中, 维护 `l<=i`.
        - 对于遍历到的 i, 若 `i<=r`, 此时有 `s[i:r] = s[i-l:r-l]` (闭区间),
            - 若还满足 `z[i-l]<r-i+1` (区间 [i,r] 的长度为 r-i+1, 我们已经在遍历 i-l 时发现了前缀匹配长度比它小), 则有 z[i] = z[i-l]
            - 否则, 说明 [i,r] 区间是前缀, 从 r+1 开始继续匹配
        - 若不满足 `i<=r`, 则从 i+1 开始继续匹配 (和上面的情况2一样)
        - 注意当我们遍历超过 r 时需要更新 `l, r = i, i+z[i]-1` (显然维护的条件 `i<=l` 仍满足)
    - 复杂度分析 (看下面的代码): 外层 i 循环一遍, 内部的 while 训练每执行一次都会使得 r 向后移动, 因此最多执行 O(n) 次; 所以总的复杂度为 O(n).

### D76

- 2239. 找到最接近 0 的数字
- 2240. 买钢笔和铅笔的方案数
- 2241. 设计一个 ATM 机器 #medium
    - 难度不大. 需要写一个类. 通过这题希望写一个函数进行本地调试.
- 2242. 节点序列的最大得分
    - 给一张带节点权重的无向图, 求长度为4的节点序列的最大得分. 序列之间需要连接, 四个节点不得重复.
    - 复杂度: 节点和边均为 5*1e4
    - 思路: 直接遍历肯定会超时. 关键看这里的序列长度为4, 因此可以考虑 **遍历中间的两个节点** (边)
        - 进一步降低复杂度: 从边 uv 的两个节点出发, 各拓展出一个节点 a,b; 为了使得分数和最大, 则搜索的 ab 节点权重必然是最大/次大的; 因此, 仅需要对每个节点维护最大的三个邻居即可 (还要考虑 uv 边可能最最大邻居)
        - 在简化了搜索空间的基础上, 可以用 `itertools.product(neighbors(u), neighbors(v))` 直接遍历所有可能的节点对, 而不需要 uv 的邻居进行排序比较等复杂的判断.
        - 参见 [here](https://leetcode-cn.com/problems/maximum-score-of-a-node-sequence/solution/by-endlesscheng-dt8h/)

### D77

- 6051. 统计是给定字符串前缀的字符串数目
- 6052. 最小平均差
- 6053. 统计网格图中没有被保卫的格子数
    - grid 上有一组墙和一组guard, 守卫可以守护上下左右四个方向的格子, 遇到墙就停止. 要求累计grid中没有被守卫守护的格子数.
    - 思路: 对于每个guard 的四个方向遍历即可, 时间复杂度 O(m*n*4)
- 6054. 逃离火灾 <https://leetcode-cn.com/problems/escape-the-spreading-fire> #hard
    - 给定一个 grid, 有一组火源和一组墙, 每过一个时刻, 火网四周蔓延一圈, 但是不能穿过墙. 人要从左上角逃到右下角, 问人能够在起点等待的最长时间.
    - 思路: BFS.
        - 1) 先从所有的火点开始进行BFS, 记录所有点距离火的位置; 2) 然后从起点出发BFS, 对于路径上的每一个点, 火到达的时间为 `fireDist[(nx,ny)]`, 而距离为 `nd`, 因此:
            - 若 fireDist[(nx,ny)]<=nd 说明火先到达, 该点探索失败; 否则, 所能等待的时间为 `nLimit = fireDist[(nx,ny)] - nd - 1`;
        - 3) 这样, 进行 BFS遍历后, 若能到达终点, 该条路径的最大等待时间为 `max([nLimit])`.
        - 繁琐的是要处理边界情况: 当人和火同时到达终点时, 算成功逃生.
        - 另外, 在本题中, 可能出现多条路径都能到达终点的情况, 因此遍历到终点后, 不能直接返回!
    - 注意: DFS 若要不重复访问节点, 就要用visited记录访问的点; 但第一次访问不一定是最短, 因此无法得到最短路径; 若要得到最短路径, 就只能记录当前路径经过的点, 会带来重复访问的问题!
        - 用BFS 同样可以记录路径: 只需要记录当前路径经过的点即可, 增加少量的存储开销
    - 一开始纠结于BFS如何记录路径的问题, 采用DFS求最短路径, 结果因为重复访问超时了

### D78

- 2269. 找到一个数字的 K 美丽值
- 2270. 分割数组的方案数
- 2271. 毯子覆盖的最多白色砖块数 #medium #双指针
    - 给定一组 [l,r] 所定义的白色砖块 (闭区间), 这些区间之间不重叠. 给一个长度为 carpetLen 的地毯, 要求返回最多可以覆盖的地砖数.
    - 思路: #贪心 注意到, 如果毯子覆盖多个区域, 我们手动令毯子的最左侧放在最左边那个区间的左端点上即可.
        - 具体而言, 可以用双指针 (i,j) 来记录毯子可以覆盖的范围, 并且用一个数字记录当前指针范围内的白色砖块数量. 遍历 j:
            - 当 `tiles[j][1] - tiles[i][0] + 1 <= carpetLen` 时, 说明足够长 j+=1
            - 否则, 需要更新答案 `ans = max(ans, tmp + max(0, carpetLen + tiles[i][0] - tiles[j][0]))` 并更新 i+=1
- 2272. 最大波动的子字符串 #题型 #hard
    - 定义字符串的波动为「出现次数 最多 的字符次数与出现次数 最少 的字符次数之差」. 要求计算一个字符串中, 所有可能的连续子串的波动最大值.
    - 注意, 这里有一个限制是, 加入最多最少的字符是 a/b, 则要求b一定要在子串中出现.
    - 复杂度: 长度为 1e4
    - 思路1: 转为 #最大子数组和 问题 + 变形
        - 注意到, 假若我们关注的是 a/b 次数之差, 则将它们记作 +1/-1, 其他字符记作 0, 则问题转为求子数组最大和问题. 题目复杂度为 1e4, 暴力遍历 a/b 的组合即可.
        - 需要注意的是, 与原问题不同之处在于, 题目要求子串中一定要包括 b: 而原本 最大子数组和 的DP: `dp[i+1] = dp[i] + nums[i+1] * (nums[i+1] > 0)` 无法记录是否包含了b.
        - 为此, 相较于记录两数字之差的 `diff` (dp迭代的数字), 这里加了一个辅助变量.
            - 当遇到 b时, 我们先 `diff -= 1` 并且用 `diff_with_b = diff` 记录, 然后再 `diff = max(diff, 0)` 更新;
            - 当遇到 a时, 直接对于 `diff, diff_with_b` +1.
        - 注意到, 相较于 diff>=0, 这里的变量 diff_with_b 最小值为 -1 (延后执行了 max(0, diff)), 因此是「包含了b的a/b最大差」.
        - 优化: 上面的时间复杂度为 O(n * 26^2), 空间复杂度 O(1)
            - 注意到这里 a/b 之外的字母取值都为 0, 而我们每次是针对 a/b 更新的, 因此实际上计算浪费了.
            - 可以用 diff[a][b] 记录两字母的差值, 随着对于字符串的遍历更新矩阵中的相关元素. 这样, 计算复杂度为 O(n * 26).
            - 具体见 [here](https://leetcode.cn/problems/substring-with-largest-variance/solution/by-endlesscheng-5775/)
    - 思路2: 动态规划
        - [这里](https://leetcode.cn/problems/substring-with-largest-variance/solution/mei-ju-chu-xian-zui-duo-he-zui-shao-de-z-g9gz/) 给出了更容易想到的思路
        - 我们用 dp0 正常求解最大子数组和; 另外用一个 dp1 记录「以第i个字符结尾的, 至少包括一个b的的最大差值」.
        - 注意两者的更新公式区别在于, `nums[i+1]==b` 时后者需要考虑 dp0[i] 的转移.
