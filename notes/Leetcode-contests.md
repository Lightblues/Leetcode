# 周赛笔记

## 周赛 260-300

### 260

- 2016. 增量元素之间的最大差值
- 2017. 网格游戏
    - 给定一个 2 x n 的网格, 每个格子有一些分数; 两人只能向右或向下从左上角走到右下角. 第一个人的目标是让第二个人剩余可以吃到的分数最小, 求最小分数.
    - 遍历. 注意 **分析边界**
        - 首先分别计算上下两行从右往左和从左往右的累计和, 在前后加两个哨兵简化判断. 因此 up,down 的长度为 n+1
        - 然后, 假设第一个人从第i个位置往下走(从1开始), 则第二人可以得到的分数为 上半部分的 i+1,...,n, 或者下半部分的 1,...,i-1
        - 对应到这里的两个累计和, 分别是 up[i+1], down[i]. 因此更新 `res = min(res, max(up[i+1], down[i]))`
        - 显然遍历范围为 `range(0, n)`
- 2018. 判断单词是否能放入填字游戏内
    - 给定一个网格, 三种情况: ' ' 表示为空, '#' 表示无法仿制, 还可能已经填入字母.
    - 要求判断一个单词是否能放入填字游戏内. 条件: 1. 方向 上下左右都可(可以从右往左); 2. 边界上不能为空或其他字母, 也即只能是 '#' 或者网格的边界; 3. 字母匹配.
    - 重点: **条件和边界判断**
        - 自己的实现比较乱, 定义了一系列的函数, 贵在比较清楚;
        - 然后又抄了 [here](https://leetcode-cn.com/problems/check-if-word-can-be-placed-in-crossword/solution/mei-ju-liang-ge-zhi-jian-de-zi-fu-by-end-pjq1/) 的解法, 思维难度上大了些. 需要注意, go和Python 中, **在循环内部对于循环变量修改是不同的**, Python中修改不会影响结果! 而go中则是可以进行赋值的.
- 2019. 解出数学表达式的学生分数
    - 给一个只有 +* 运算和 0~9 数字的表达式, 对于不同的答案赋予分数. 1. 正确为5, 2. 因为运算顺序导致的错误, 分数为2, 3. 其他0分.
    - 因此, 核心问题是 遍历所有运算顺序, 给出所有可能的结果.
    - 思路一: **分治 + 记忆化**
        - 利用递归实现分治. 结合 lru_cache 实现. 由于这里的所有数字和运算符都是一个字符的, 解析起来非常方便 (表达式长度一定为奇数).
        - 复杂度分析
            - 注意到, 这里随意更换运算顺序, 至少是一个指数级别的复杂度!
        - 例如对于表达式 `"4+8*8+8+8*8+4*4+8*4+8*8+8*8+8"`, 其不同答案的数量可以达到 `86301`; 直接排列组合在 LC上会超时.
            - 题目中给出了限制 0 <= answers[i] <= 1000 (正确答案在1000以下), 因此可以对于两侧给出的答案进行过滤, 这样不同答案的数量最多只有 `141`. —— 剪枝

### 268

- 2078. 两栋颜色不同且距离最远的房子
- 2079. 给植物浇水
    - 模拟法
- 2080. 区间内查询数字的频率 `中`
    - 需求是查询子数组 arr[left...right] 中 value 的 频率; 考虑到查询数量可能较大, 因此设计一个数据结构存储数据分布信息
    - 解法: 用 map 保存数字所出现的位置列表, 从而查询时候可以用**二分查找**.
        - Python 可以直接用 `bisect.bisect` 好方便!
- 2081. k 镜像数字的和 `难`
    - 找到前 n 个, 在 10进制 和k进制下均为回文数的数字, 返回其最大值
    - 注意题目要求, 2 <= k <= 9, 1 <= n <= 30 当k和n均取较大值时会超时(约10**10量级); 因此重点是如何所见搜索空间.
        - 由于是回文数, 因此只需遍历前半部分即可, 注意可生成奇数或偶数长度的, 例如 1234 -> 1234321 或 12344321;
        - 另外, 每次遍历 [1,9], [10,99]... 的数字, 对于j位十进制数, 可分别生成 2j-1, 2j 位十进制数

### 269

- 2089. 找出数组排序后的目标下标
- 2090. 半径为 k 的子数组平均值
- 2091. 从数组中移除最大值和最小值
    - 滑动平均
- 2092. 找出知晓秘密的所有专家 `难`
    - 包括 (x, y, time) 的三元组, 若 x 和 y 中某一个知道了「秘密」, 则会进行传播; 要求最后知道「秘密」的所有人
    - 解法一: **构建图**, 传播
        - 按照时间排序, 难点在于判断同一时间的多人传播关系 —— 简单的方案是构建图
        - 解法的具体实现: 利用 edges 字典记录连接关系, 建立图后, 利用 一个 `deque` 记录所有激活节点, 迭代直至队列空
    - 解法二: **并查集**

### 270

- 2094. 找出 3 位偶数
    - 给你一个整数数组, 找出所有的三位偶数(也即要求首位不为 0), 顺序输出(直接排序即可)
    - 简单题 (也可根据提示的范围知道不复杂) 别想太多, 直接暴力遍历即可; 为了避免重复可以用 set()
- 2095. 删除链表的中间节点 `中`
    - 长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始）
    - 解法一: 快慢指针即可, 可以在最开始加上一个「哨兵」
- 2096. 从二叉树一个节点到另一个节点每一步的方向 `中`
    - 找到二叉树两个节点之间的路径
    - 解法一: 直接 DFS 找到两个点从 root 出发的路径, 除去公共路径即可
- 2097. 合法重新排列数对 `难`
    - 给定 pairs(表示区间), 重新排列要求排列后每个区间首尾数字相同; 核心在于理解「[欧拉通路](https://oi-wiki.org/graph/euler/)」, 将问题转换
    - `Hierholzer 算法`: 首先很容易想到, 若仅为「**半欧拉图**」(即存在两个奇数度数节点), 可以确定开始和结束的数字, 否则为「欧拉图」随便选择初始数字/节点即可.
        - 若随便选择一条边, 则可能走到「死路」, 注意此时剩下的图构成了一个「欧拉图」 —— 可以用DFS探索
        - 因此, 1. 每次选择一条边, 在图上删去这条边; 2. 递归; 3. 记录这条边. 注意这里的边是在遍历之后加入记录的 (也即是逆序的, 最后要再逆序输出), 这样可以保证可能漏过的「欧拉图」在此之前被遍历.
    - 参见 「332. 重新安排行程」「753. 破解保险箱」
    - 332 重新安排行程, `难`
        - 区别在于, 需要返回所有的通路中, 字母排序最小的那一个 —— 也即, 每次应该选择较小的那一个节点
        - [solution](https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/) 非常清楚
    - 753. 破解保险箱, `难`
        - 密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。要求返回一个最短字符串, 其子字符串包括所有可能的密码.
        - 关键在于将其转化为一个规范的欧拉通路问题: see [here](https://leetcode-cn.com/problems/cracking-the-safe/solution/po-jie-bao-xian-xiang-by-leetcode-solution/) 官方解答有点fancy
        - 解法: 转换为**欧拉通路问题**
            - 简言之, 要求的是 n 长序列, 都可将其看成 n-1长序列加上 0~k-1 的数字. 因此, 可以构建一个图, 节点为所有的 n-1长序列, 其第i个出边就是在最后加上数字i并去除第一位数字, 跳到相应的节点上.
            - 例如, 节点u的第v的出边就跳转到数值为 u*k % (k**(n-1)) + v 的节点上.
            - 可知, 这样构造的图, 每个节点都有 k条出边和入边, 共可代表 $k^{n-1} * k$ 个不同的数字, 正好对应了所有可能的密码.
            - 显然, 这张图是欧拉图, 并且可基于一个欧拉回路对应一个题目所要求的字符串.

### 271

- 2105. 给植物浇水 II
    - 模拟法即可
- 2106. 摘水果 `难`
    - 在一个无限的 x 坐标轴上, 分布一定的水果, 给定 startPos 和可以移动的步数 k, 计算可以拿到的最大数量
    - 题型: 其实就是给定一个累加和, 探索所有可能的范围内的最大值; 问题在于如何在离散存储的数组中找到对应的元素
        - 存储方式: 例如对 `[[2,8],[6,3],[8,6]]` 水果分布而言, 记录位置 `pos=[-Inf, 2,6,8]` 和 累计和 `[0,8,11,17]`
        - **二分查找**. 要注意 **边界情况**, 左边应该是 `bisect.bisect_left`, 而右边是 `bisect.bisect_right`, 注意函数返回的是待插入的 index, 因此最终能采集的水果数量为 `cumsum[rindex-1] - cumsum[lindex-1]`
        - 错误记录: 注意, 先往左边走和先往右边走所能达到的范围是不一样的! 因此两侧的情况都应该考虑到.

### 272

- 2110. 股票平滑下跌阶段的数目
    - 一次遍历即可
- 2111. 使数组 K 递增的最少操作次数 `难`
    - 如果对于每个满足 `k <= i <= n-1` 的下标 i ，都有 `arr[i-k] <= arr[i]` ，那么我们称 arr 是 K 递增 的。
    - 给定一个数组和 k,要求找到使得这个数组 k递增的最小修改次数.
    - 问题可转化为: 寻找一个数组中的最长递增序列, 参见 300 题 [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/)
        - 思路 1: DP, 定义 `dp[i]` 为 第 i 个数字结尾的最长上升子序列的长度, 注意 第 i 个元素必须被选中; 递推公式 `dp[i] = max(dp[j]) + 1`, 其中的 j 要求 `nums[j]<=nums[i]`
            - 时间复杂度 $O(n^2)$
        - 方法二：贪心 + 二分查找
            - 维护一个数组 `d[i]` ，表示**长度为 i 的最长上升子序列的末尾元素的最小值**, 用 len 记录目前最长上升子序列的长度. 注意到数组 d 是单调递增的
            - 我们依次遍历数组 nums 中的每个元素，并更新数组 d 和 len 的值。如果 `nums[i]>d[len]` 则更新 `len = len + 1`，否则在 `d[1…len]`中找满足 `d[i−1]<nums[j]<d[i]` 的下标 i，并更新 `d[i]=nums[j]`。
            - 由于是递增数列, 可以用二分搜索
            - 时间复杂度 $O(n log(n))$

### 273

- 2120. 执行所有后缀指令
    - 模拟机器人动作即可
- 2121. 相同元素的间隔之和 `中`
    - 给定一个数组, 计算其中相同元素所在的 index 之差, 返回所有这些距离的和
    - 用一个 defaultdict(list) 记录各个元素出现的位置.
    - 问题转化为对于一个数字出现的位置, 计算各个位置的 dist 和.
        - 注意数据量, 直接暴力遍历复杂度为 $O(n^2)$ 会超时
        - 思路1: 观察相邻两个元素相差的(子距离数量), 可得递推公式 `dp[i+1] = dp[i] -(n-2i-2) * (arr[i-1]-arr[i])`
        - 思路2: 计算 cumsum, 则 i 处的距离和为 `(cumsum[-1]-cumsum[i] - arr[i]*(n-1-i)) + (cumsum[i]-cumsum[0] - arr[0]*i)`
- 2122. 还原原数组 `难`
    - 就是对于一个数组 arr, 用一个正整数 k, 分别生成两个数组, `lower[i] = arr[i] - k, higher[i] = arr[i] + k`. 要求给定这两个数组的混合, 还原 arr
    - 注意看约束条件, 数组大小最多为 `1000` 所以暴力搜索即可, 题目只是比较繁琐
        - sort, 得到可能的 k
        - 用 `indexRecord` 记录每个数字对应的位置
        - 关键在判断一个 k 是否满足条件. 这里用了一个 `used` 记录每个所对应的元素所在位置, 遍历 nums 后, 若 `sum(used) == n` 则说明 k 满足条件
    - see [here](https://leetcode-cn.com/problems/recover-the-original-array/solution/huan-yuan-yuan-shu-zu-by-leetcode-soluti-nizi/)

### 274

- 5970. 参加会议的最多员工数 `难`
    - 每个人只有一个喜欢的人, 要求安排坐圆桌, 每个人左右要有他喜欢的人, 最大的可安排人数
    - 比较容易想到, 问题主要转化为求这样的有向图上的最大环,
        - 特殊情况是两个互相喜欢的人, 他们相互满足了要求, 因此左右可以有一条「喜欢人的链」, 并且左右的人都是满足的; 因此, 这种大小为 2 的环一个桌上可以安排多个
        - 参见 [这个题解](https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/solution/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/), 这种图叫做 **内向基环树 (pseudotree)**
    - 所以核心问题在于如何在 pseudotree 中找环, 比赛中的尝试没有想到如何「**剪枝**」超时了; 实际上, 可以通过一次 **拓扑排序** 剪掉所有的分支 (最后留在图上的点的度数最大为 1)
        - 具体实现上, 维护一个入度为 0 的队列, 对其喜欢的人的入度 -1, 如果减到了 0 则继续加入队列;
        - 这样, **拓扑排序后最终剩下的点都是成环的**(入度为 1).

### 275

- 5976. 检查是否每一行每一列都包含全部整数
- 5977. 最少交换次数来组合所有的 1 II
    - 滑动平均
- 5978. 统计追加字母可以获得的单词数
    - 注意审题
- 5979. 全部开花的最早一天
    - 两个数组, 分别是 播种 和 开花 所需的时间, 要求使得所有花都开放的最小时间
    - 题目给了干扰: 将一种花分成两次播种没有意义, 因为两者总的播种时间是一样的, 因此在过程中两种花都不会提早开花.
    - 于是可以化简为, 给依次播种的花进行排序
    - 可知, 总的播种时间是一定的, 目标在于减少开花所需时间. 因此每次根据开花所需时间排序, 选择需要最长时间的那种即可.

### 276

- 5980. 将字符串拆分为若干长度为 k 的组
- 5194. 得到目标值的最少行动次数
    - 给定一个目标数, 从 1 开始 +1, *2 两种操作, 限定了倍乘的次数 maxDoubles
    - 贪心, 从 target 往下 /2
- 5982. 解决智力问题
    - 给定一系列的题目, questions[i] = [pointsi, brainpoweri], 你选择做某一题的代价是只能跳过后面 brainpower 题
    - DP, 从后往前, 记录从该位置往后的最大解, 递推公式 `dp[i] = max([dp[i+1], point+dp[i+skip+1]])`
- 5983. 同时运行 N 台电脑的最长时间
    - 给定一组电池 batteries, 每个电池可以给一台电脑运行一定的时间. 可以把一个电池替换给不同的电脑, 要求让所有电脑同时运行的最长时间
    - 这里的限制条件为电量最大的 n 个电池, 小的电池看作对它们的补充.
    - 注意到: 一个电池的电量可以以**任意的比例**分到若干块电池上.
    - 因此, 可以将最大的 n 个电池看成一个「阶梯」, 其余的小电池理解为在这个池子里注水, 求高度

### 277

- 2148. 元素计数
- 2149. 按符号重排数组
- 2150. 找出数组中的所有孤独数字
- 2151. 基于陈述统计最多好人数 #hard
    - 两种角色: 好人只说真话, 坏人可能真也可能假
    - 给定一个矩阵表示每个人的陈述 (0,1,2 分别表示 坏人, 好人, 未判断), 要求计算好人最多可能数量
    - 注意到, **此题中坏人的陈述毫无信息量**!
    - 方法一：使用状态压缩枚举所有可能的情况
        - [here](https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/solution/ji-yu-chen-shu-tong-ji-zui-duo-hao-ren-s-lfn9/)
        - 用一个长度为 n 的二进制数 mask 表示好人坏人情况, 针对 mask 所表示的好人坏人分布, 判断是否合法
            - 冲突的情况只会出现在好人 i 的陈述中 (mask[i]=1)
            - 当 `s[i][j]=0 and mask[j]=1`, 或 `s[i][j]=1 and mask[j]=0` 时冲突
        - 实现一个 `check(mask)` 函数判断是否冲突
        - check 复杂度最大为 n^2, 枚举复杂度为 2^n, 因此总体复杂度为 `n^2 2^n`, 这里用位运算所以比较快?
    - 方法二: 回溯
        - 暴力枚举每个人是好人或坏人, 注意剪枝!!

### 278

- 2154. 将找到的值乘以 2
- 2155. 分组得分最高的所有下标
- 5994. 查找给定哈希值的子串
    - 定义一个字符串的哈希值 `hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m`
    - 给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 `k` 的 子串 sub ，满足 `hash(sub, power, modulo) == hashValue` 。
    - 字符串长度为 e4, 如果暴力遍历, 当所要求的 k 数量级接近是复杂度是 e8, 会超时
    - 方法一: **滑动平均**, O(n)
        - 给出的哈希计算函数是一个等比求和数列，两者可以通过减去首元素，除以power再加上新元素的power的k-1次方计算。
        - 但是 **除法不满足取余的恒等性**。因此需要倒序，减去当前的值，乘以power再加上新元素的值。(乘法满足取余恒等)
        - 参见 [here](https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/cha-zhao-gei-ding-ha-xi-zhi-de-zi-chuan-fi8jd/)
- 2157. 字符串分组 #hard
    - 每个字符串包括了一组不相同的字符 (比如 cde), 定义两个字符串「相连」: 其一可以通过 添加/删除/替换(替换成相同字符也可, 即包括相同字符集合的两字符串相连) 一个字符得到另一个字符串。
    - 定义组: 如果一个字符串与该组中的任一字符串相连，则这个字符串属于该组。
    - 给一组字符串, 计算有多少个不同的组, 以及最大组包括的字符串数量。
    - 方法一：状态压缩 + 广度优先搜索
        - 显然是求连通分量的数量, 问题在于如何构建图? 如果是两两计算复杂度为 O(n^2) 超时;
        - 像这类题, 可以从每一个节点出发, 构造其所有可能相连的边, 例如这里就是按照「相连」的定义, 增删或者替换所有可能的字符, 这样复杂度为 O(nD^2), 其中 D 为字符字典大小
        - 具体而言, 为了进行图遍历, 用一个 used 集合记录所有遍历过的节点, queue 来维护当前进行BFS, 对于所有的节点进行遍历.
        - 状态压缩: 如何表示一个(小写字母)字符集合? 01编码转化为数字以进行压缩. 这样的好处还有方便表示相连边, 参见 `get_adjacent`
        - 参见 [here](https://leetcode-cn.com/problems/groups-of-strings/solution/zi-fu-chuan-fen-zu-by-leetcode-solution-a8dr/)

### 279

- 6000. 对奇偶下标分别排序
- 6001. 重排数字的最小值
    - 给一个数字 (可能为负数), 重拍求最小值
- 6002. 设计位集 #medium
    - 能够快速实现 fix(设置某一位为1), unfix, flip(翻转每一位), add, one(至少一个非零), count(非零位数量) 操作
    - 尝试直接用列表存储, 超时了, 可能是 flip, add, one, count 复杂度较高
    - 优化为 位存储+一个变量intcount存储非零位数量, 从而优化时间复杂度; 可以重新看看**位运算**使用技巧
- 6003. 移除所有载有违禁货物车厢所需的最少时间
    - 一个 01 序列表示违禁物品, 前后移除一辆火车代价位 1, 移除中间的一辆代价为2, 求移除所有违禁货车最小代价
    - 思路一: 从左边和右边非别累加计算单面的最小代价, 加起来求最小 (其实就是在不同的点分割).
        - 注意 更新公式(DP): 当 `s[i+1]=='1'` 时 `dp[i+1] = min(dp[i]+2, i+1)`, 因为若从左边全部移除的代价是 i+1, 从中间取走的代价是 +2
        - 为了计算的方便在头部加一个 [0]; 注意到在点 i 处分割的总代价为 `dp1[i]+dp2[i+1]`, 正好错位加和. 参见 [here](https://leetcode-cn.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/solution/qian-hou-zhui-fen-jie-dp-by-endlesscheng-6u1b/)

### 280

- 6004. 得到 0 的操作数
- 6005. 使数组变成交替数组的最少操作数
    - `[2,1,2,1,2,1,2]` 的形式, 要求奇数和偶数位置的数字不同
    - 分别对于 nums[0::2] 和 nums[1::2] 计数, 注意边界情况 (`len(collections.Counter(nums[0::2])) == 1`)
- 6006. 拿出最少数目的魔法豆
    - 给定一组袋子, 要么拿空, 要求最后剩下来的非空袋子里的豆子数量相同
    - 排序, 想像成一个阶梯, 最后留下来的就是一个矩形; 转化为遍历求矩形最大面积
- 6007. 数组的最大与和
    - 有编号为 1,2,...,numSlot的篮子, 要求把一个长度为 n 的数组放入篮子中, 每个篮子最多放两个数字!
    - 定义放置的分数为, 数字和篮子编号与 `nums[i] & (assign[i]+1)`, 其中 assign 表示 第 i 个数字放在第 assign[i] 个篮子中
    - 方式一: 暴力回溯
        - 用一个 records 数组保存每个篮子中球的数量
        - 回溯函数 `dfs(idx, curSum, curMax)`, 遍历 idx 放置每一颗球

### 281

- 6012. 统计各位数字之和为偶数的整数个数
- 6013. 合并零之间的节点
- 6014. 构造限制重复的字符串
    - 给定一组字符, 要求构造字典序最大的字符串, 限制每个字符最多连续的次数.
    - 当两个字符串长度不同时, 先序比较前面部分, 仅当 min(a.length, b.length) 时算较长的字符串字典序较大.
    - 思路
        - 根据题意, 应该是按照字典序, 尽量把大字符连续放在前面, 之间插入一个次大字符即可, 即 bbbabbba... 这样的形式(repeatLimit=3)
        - 关键在构造方法:
            - 每次取最大字符, 后面添加一个次大字符即可! 终止条件是没有次大字符了.
            - `bbba` 这种形式为一次循环所构造的, 当 a 没有的时候即终止 (终止条件!)
- 6015. 统计可以被 K 整除的下标对数目
    - 给定一个数组 nums 和一个正整数 k, 返回满足条件的下标对 `(i, j)` 的数目, 要求 `nums[i] * nums[j] % k == 0`, 即两数之积能够被k整除.
    - 思路
        - 考虑 `n1*n2 % k == 0` 的条件: n1和n2 和 k 的最大公约数之积能被k整除, 即 `gcd(n1, k) * gcd(n2, k) % k == 0`
        - 由于 k 的因子是有限的, 就可以对于 nums 中的数字分组. (Counter)
        - 对于一个组, 其中的数字与k的最大公约数都是 n1, 假设组大小为 len1
            - 考虑两种情况: 1. 其他组中能够能够配合n1的数字个数为 len2, 则交互共有 `len1*len2` 个数字; 2. 若 `(n1*n1)%k == 0`, 即自身就满足条件, 组内组合数为 `C(2,len1) = len1*(len1-1)/2`
        - 累计. 为了避免重复, 对于因子从大到小排序, 每组都和后边的因子比较
        - 注意: 特殊情况是 k==1

### 282

- 6008. 统计包含给定前缀的字符串
- 6009. 使两字符串互为字母异位词的最少步骤数
- 6010. 完成旅途的最少时间
    - 给一组公交车运行一轮的用时: `time[i]` 表示第 `i` 辆公交车完成 一趟旅途 所需要花费的时间。要求计算所有公交车运行至少 totalTrips 圈所需的最少时间。
    - 思路: 二分查找
        - 对于运行时间排序, 在一定区间内二分查找最短时间
        - 初始化: 考虑左边界, 假设所有车运行一圈都为最小的那一辆, 则最短时间 T 需要满足 `T//min(time) * n >= totalTrips`, 则最小为`T = min(time) * math.ceil(totalTrips/n)`
        - 这里复习一下二分: 循环 `l < r`, 每次查找的 `mid = (l + r) // 2` 有可能为 l. 因此在检查条件后, 根据是否满足分别设置 `r = mid, l = mid + 1` 从而保证不会死循环.
        - 具体而言, 这里要求最小的满足条件的数字, 则可以: 每次检查成功收缩右边界, 令 `r = mid`; 失败则拓展左边界 `l = mid + 1`, 从下一个点开始搜索.
        - 算一下这里的时间复杂度: 假设搜索长度为 L, 每次检查有效性复杂度为 O(n), 则总体为 `O(n * log(L))`, 其中长度约为 `L=totalTrips/n * timeSpan`. 本题中, 变量数量级为 `time[i]=totalTrips=1e7, n=1e5`, 可以看到主要复杂度在 `O(n)`
- 6011. 完成比赛的最少时间
    - 给定一组轮胎, `tires[i] = [fi, ri]` 表示第 `i` 种轮胎如果连续使用，第 `x` 圈需要耗时 `fi * ri ** (x-1)` 秒。
    - 同时给你一个整数 `changeTime` 和一个整数 `numLaps` , 表示换轮胎的时间和总圈数. 要求最短用时.
    - 思路: DP
        - 对于dp[i], 考虑两种情况: 1. 用一种轮胎, 则用时为 `f * (r**laps -  1) / (r-1)` (等比数列); 2. 递推, 则用时为 `dp[i] + dp[i-j] + changeTime` (j = 1...i-1).
        - 注意对于第一种情况, 次题中 numLaps=1e3, len(tires)=1e5, 直接暴力会超时. 因此需要对每一轮次可能达到最短时间的 tires 进行筛选,
        - 这里用了简单的策略: 计算换一个轮胎跑一圈的最短用时 `min0 = min(i[0] for i in tires) + changeTime`, 如果此时继续用轮胎i `i[0]*(i[1]**(laps-1))>= min0` 则不需要考虑了.

### 283

- 6016. Excel 表中某个范围内的单元格
- 6017. 向数组中追加 K 个整数 #medium
    - 给一个数组, 请你向 `nums` 中追加 `k` 个 **未** 出现在 `nums` 中的、**互不相同** 的 **正** 整数，并使结果数组的元素和 **最小** 。
    - 思路一: 模拟. 遍历数组 nums, 并从 1开始递增 `inc` 表示下一个可能可以追加的数字, 累计数组中空的元素.
- 6018. 根据描述创建二叉树
- 6019. 替换数组中的非互质数
    - 对于数组定义一个操作: 任意两个相邻的非互质数 (最大公约数gcd != 1), 将它们替换为其最小公倍数 （Least Common Multiple，LCM）. 返回这样操作之后的数组.
    - 思路一: **栈模拟**
        - 一个数字只能和左右两边的数字合并, 并且 x,y,z 如果可以合并的话先后顺序无所谓. 因此可以合并一遍即可.
        - 因此可以用 **栈** 来进行模拟 —— 每次入栈后看它能消去到前面多少数字.
    - 第一时间应该想到 stack 的…… 不过自己写了一个函数, 尽量对于左右两边进行合并, 居然超时了? 复杂度应该是完全一样的...
    - 线性复杂度应该是没问题的, 还尝试了 `@lru_cache` 也过不了, 本地调试完全可以过 LC 不知道为啥不行.

### 284

- 6031. 找出数组中的所有 K 近邻下标
- 5203. 统计可以提取的工件
- 5227. K 次操作后最大化顶端元素
    - 给一个非空栈和可操作数量k, 要求返回执行这些操作后, 能够留在栈顶的最大值. (如果执行完 k 次操作以后，栈一定为空，请你返回 -1)
    - 两种操作: 1. 弹出栈顶元素; 2. 压入弹出的某一个元素.
    - 思路一: 讨论
        - 先考虑边界: 什么情况下最后栈为空? `len(nums)==1 and k%2==1`
        - 而在一般情况下, 对于k次操作, 我们可以在栈顶留下第 1,...,k-1 和 k+1 个元素 (从1开始). 需要对k和数组长度n的关系讨论.
        - 另外, 需要确保 nums[:k-1] 操作中 k-1 非负, 添加到边界条件中.
- 6032. 得到要求路径的最小带权子图
    - 给一张带权图, 给定三个点, 要求返回 **边权和最小** 的子图 (的边权和)，使得在这个子图中从 `src1` 和 `src2` 出发都可到达 `dest` 。如果这样的子图不存在，请返回 `-1` 。
    - 分析
        - 注意到, 双点出发求最短路径的情况, 可能出现共用一条路径的情况. (此时, 最小边权和为 `s1->u, s2->u, u->d` 三条路径之和, 而非 `s1->d, s2->d`). 需要判断这种情况出现的边界:
        - 简单判断, 假设两点的最短路径分别为 d1,d2, 则共用的路径长度不能超过 d1+d2.
        - 因此, 暴力来解, 可以先从 s1,s2 出发BFS, 然后(逆)从d出发进行长度约束为 d1+d2 的BFS.
        - 为了判断所有可能的中间节点, 需要记录正反向BFS过程中所有经过的点的路径长.
    - 思路一: BFS + 节点判断
        - 首先, 从src1和src2出发, 返回距离d和在这一范围内的节点集合(及其路径长); 分别用 dist1, dist2 两个map记录两个范围内所有点的距离.
        - 然后在逆图上进行长度 d1+d2 约束的BFS, 同样记录各个点的路径长 dist
        - 遍历三个字典交集, 取最短距离 `dist[u]+dist1[u]+dist2[u]`.

### 285

- 6027. 统计数组中峰和谷的数量
    - 首尾的不算, 相同数字算一个峰/谷. 例如 [2,4,1,1,6,5] 就有三个
    - 思路: 遍历, 模拟
- 6028. 统计道路上的碰撞次数
    - 给定一个字符串表示车辆方向. L, R, S 分别表示左右和停止 。每辆车移动时速度相同。相向碰撞 2分, 一个静止的1分; 碰撞后都静止; 求最后的分数。
    - 思路: 模拟. 注意一些边界讨论.
- 6029. 射箭比赛中的最大得分
    - 12个区域得分分别为 0...11; 如果 `ak >= bk` ，那么 Alice 得 `k` 分。如果 `ak < bk` ，则 Bob 得 `k` 分; 现在知道Alice的分布, 要求Bob得分最高的一种方式
    - 思路: 复杂度不高, 直接DFS即可
- 6030. 由单个字符重复的最长子字符串 #hard
    - 给定一个字符串和一组查询, 每次查询会将`queryIndices[i]` 的字符更新为 `queryCharacters[i]`, 要求返回每次查询后, 字符串中保留的最大重复字符长度
        - 例如 `s = "babacc", queryCharacters = "bcb", queryIndices = [1,3,3]`, 将返回 `[3,3,4]`
    - TODO: 线段树

### 286

- 5268. 找出两数组的不同
- 5236. 美化数组的最少删除数 #修改数组
    - 定义美丽数组: (1) 长度为偶数; (2) 2i, 2i+1 位的数字不相同. 空数组也符合
        - 要求: 将一组数组转为美丽数组, 最少删除的数字个数
    - 思路: 贪心. 每遇到 **约束对** 不满足的情况, 这两个数字必然是相同的, 随便删除一个即可.
        - 若出现 [..., 1,1,2,2,3,3, ...] 的情况, 不管是前面删除使得三组相同数字处于不同的约束对, 还是删除最前面的 1, 效果是一样的.
- 5253. 找到指定长度的回文数 #回文数 #进制
    - 要求得到长度为 l 的回文数中的第 k 个; 超出限制则返回 -1
    - 思路: 递归
        - 注意这里回文数数量限制有两种: (1) 内部回文数可以以0开始, (2) 回文数定义, 例如长度为3的最小回文数为 101. 可知, 长度为 1/2 的回文数数量为 9, 长度为 3/4 的回文数数量为 90; 内部回文数数量为 10, 100, 1000...
        - 因此, 实际上是一个「进制」问题, 可以用递归来解.
        - 需要注意: 题目中要求得到第 ith个回文数, 从1开始; 但是 **在进制的计算中, 必须应该从0开始**. 例如, 进制为10, 则要求得到第13个 (其实是12)回文数, 应该计算 `div(12, 10) = 1, 2`; 在本题中, 外部的数字从1开始, 因此需要再加上1, 也即 `222`
- 5269. 从栈中取出 K 个硬币的最大面值和 #hard #排列组合
    - 给定一组栈和可以取的硬币数量k, 要求取到的面值最大.
        - 例如给定 `piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7`, 最大应该为 706
        - 复杂度: 栈数量 n<=1000; 操作次数 k<=2000
    - 思路: 转化为 #背包问题 #DP
        - `dp[i][j]` 表示从前 i 个栈中取出 j 个硬币的最大面值. 为了计算方便, 对于 piles 先取前缀和.
        - 遍历所用栈的数量. 对于第 i 个栈, 更新公式 `dp[i][j] = max(dp[i][j], dp[i-1][j-k] + piles[i][k])` 也即, 尝试从第 i 个栈中取出 k 个硬币.
        - see [here](https://leetcode-cn.com/problems/maximum-value-of-k-coins-from-piles/solution/zhuan-hua-cheng-fen-zu-bei-bao-pythongoc-3xnk/)
        - 参见: <https://oi-wiki.org/dp/knapsack/>
    - #技巧: 看到题目的第一感觉应该是背包, 然后因为没刷过题毫无思路. 看到上述解答之后, 发现本质上还是一个DP, 而所谓「背包」不过是更高阶的总结; 所以关键还在于对于问题的理解, 而非单纯套模板.

### 287

- 6055. 转化时间需要的最少操作数
- 5235. 找出输掉零场或一场比赛的玩家
- 5219. 每个小孩最多能分到多少糖果 #题型
    - 给一组糖果, `candies[i]` 表示第i堆糖果有多少, 将其分给k个人, 要求每个人拿到的数量相同, 糖果只能划分不能合并, 可以有多余的 (即堆数>k); 求每个人拿到的最大数量.
    - 思路: #二分搜索
        - 对于不同的糖果数 m, 原本每一堆糖果可以分配出来的数量是变动的; 难以给出一个准确的映射直接求解; 然而, 对于一个给定的 m, 判断是否足够分给k个人是简单的, 复杂度为 O(candidies). 因此, 考虑二分.
        - 用一个 `test` 函数判断分m个糖果是否可行; 在 [1, sum(candies)//k] 之间二分搜索.
        - #技巧: 对于二分搜索如果不确定边界条件, 可以最后再 test 一下进行判断
- 5302. 加密解密字符串
    - 题目好长 Orz, 总而言之就是给一个 {key:value} 的映射, 将一个字符映射到长度为2的一个字符串, key不重复但是允许values重复. 然后 key->value 是加密, value->key 解密.
        - 有约束, **所有允许的原字符串仅包含在一个 len<=100 的dictionary中**. (反向思维!)
        - 要求是设计一个数据结构, 支持加解密操作, 最多调用200次.
        - 复杂度分析: keys, values 的长度 <=26, 给出的待解密的字符串长度 <=200; 最多调用200次.
    - 思路1: 模拟 (DFS+Trie)
        - 正常的思路可能是直接模拟; 然而考虑到解密环节的一对多情况, 暴力求解会超时!
        - 容易想到的改进是 DFS+Trie, 参见 [here](https://leetcode-cn.com/problems/encrypt-and-decrypt-strings/solution/by-class_-8pci/)
    - 思路2: #逆向思维
        - 这里给定了所有可能的原字符串 (并且数量很小), 所以要钻的空子就是预计算所有可能的加密结果.
        - 见 [here](https://leetcode-cn.com/problems/encrypt-and-decrypt-strings/solution/by-endlesscheng-sm8h/)

### 288

- 6037. 按奇偶性交换后的最大数字
    - 注意审题! (虽然这题设置有点奇怪) 是 奇偶性 相同的数字可以交换, 而不是 奇偶index
- 6038. 向表达式添加括号后的最小结果 #medium
    - 在括号左右添加一对括号, 例如 `"12+34"` 变为 `"1(2+3)4"` 也即左中右三个元素的乘积, 要求最小化结果
    - 思路: 遍历两侧可以加入括号的index即可, 要注意边界情况有点烦
- 6039. K 次增加后的最大乘积 #蓄水 #分配
    - 给你一个非负整数数组 `nums` 和一个整数 `k`, 可以将k分配到数组元素上 (相加), 要求乘积最大.
    - 思路: intuition是填充最小的那些数字. 因此可以看作是 **阶梯水池蓄水** 的问题.
    - 注意复杂度: `nums.length, k` 为 1e5. 最开始遍历index时 (模拟蓄水过程), 每「上一个台阶」都修改整个序列 `nums[:index]`, 复杂度为 `O(n^2)` 会超时. 修改为记录遍历的终止位置 (最终蓄水高度) 后一次性修改.
- 6040. 花园的最大总美丽值 #hard #分配
    - 数组 flowers 代表每个花园的花数量, 数字 newFlowers, 可以分配到各个花园中. 花园的分数定义为:
        - 花的数量至少为 `target` 的花园为「完善的」, 每个花园有 `full` 分;
        - 剩余「不完善」的花园, 总共有 `min(num_flower) * partial`, 也即这些花园中 量最少的花数 * 一个分值.
    - 需要注意的是, 即使在可以完全填满的情况下, 也有可能不填满的分数更高. 因此比较繁琐需要遍历.
    - 思路0: 当时很繁琐的想法是, 先尽量尝试填出完善的花园, 然后利用剩余的花来提升其余花园的最少花数. 为此, 先对花园排序, 从右往左计算 `need_for_target` 为填满最大数量花园所需的花朵数; 从右往左 `need_for_partial` 累计「阶梯水池蓄水」所需数量 (将其余花园填到高度 flosers[i] 所需的数量).
        - 然后遍历所有可能的情况. 例如遍历 need_for_target 合法的 index, 然后用剩余数量 bisect `need_for_partial` 以尽量提升其余花园的最少花数.
        - 但是需要注意边界: 1) 本来所有花园都是满的; 2) 在 bisect 时需要考虑 `need_for_partial` 的边界. 当时没想好第一点结果错在了最后一个考验复杂度的用例上, 结果没查出错误.
    - 思路: 好吧, [官方](https://leetcode-cn.com/problems/maximum-total-beauty-of-the-gardens/solution/hua-yuan-de-zui-da-zong-mei-li-zhi-by-le-18d8/) 的解答也是这样的, 不过更简洁些.

### 289

- 6070. 计算字符串的数字和
- 6071. 完成所有任务需要的最少轮数
- 6072. 转角路径的乘积中最多能有几个尾随零 #乘积
    - 给定一个矩阵, 一条「转角路径」最多出现一个转折, 求所有路径乘积的尾随零的最大数量.
    - 思路: 1) 显然, 路径越长越好, 所以折角的两条边可以直接到矩阵的边上. 2) 为了计算乘积的「尾随零」, 注意到0的数量完全取决于 2/5 因子的数量; 3) 因此, 分别计算行和列级别的前缀和, 然后遍历所有可能的折角.
- 6073. 相邻字符不同的最长路径 #DFS #树 #路径
    - 给一棵树上的节点都定义一个 label, 要求返回树上一条相邻节点的label不同的最长路径的长度。
    - 思路: 正常 DFS 即可. 注意: 1) 最长路径可能在节点的子树中, 因此需要在遍历过程中更新全局变量; 2) 注意DFS返回: 「从该节点出发的子路径的最大长度」, 而全局维护的是「一条符合条件的路径的最大长度」, 注意区分.

### 290

- 6041. 多个数组求交集
    - 求给定的所有数组的交集. 思路: 直接调用 Python API 暴力解决
- 6042. 统计圆内格点数目
    - 每个圆通过 (x,y,r) 所定义, 要求计算这些圆所覆盖的整数点数量. 思路: 暴力遍历
- 6043. 统计包含每个点的矩形数目 #bisect
    - 给定一组点所定义的矩形和一组点, 对于每个点, 要求判断包含该点的矩形的数量
    - 重点是数量级分析: `1 <= rectangles.length, points.length <= 5 * 10^4` 因此无法暴力判断
    - 注意这里的条件, (x,y) 中, `1 <= x <= 1^9; 1 <= y <= 100`, 因此, 构建 y2x, 分别排序即可.
    - 此时, 对于每一个点, 从 `recY >= pY` 的最多 100 个序列中进行 bisect 即可.
- 6044. 花期内花的数目 #区间划分
    - 每朵花 [start, end] 定义开花时期; 对于每一个在某时刻来的人, 返回此时开花数量.
    - 思路: 排序累计, 二分.
        - 转化为, 统计时间维度上, 不同区间内的花朵数量 (这样就可以二分查找了). 为此, 对于 start, end 两类节点统一排序, 然后记录各个变化的时间点即可
        - 具体而言, 用 `timeSplits, flowerNums` 两个数组记录变化时刻和该区间内的花朵数量.

### 291

- 6047. 移除指定数字得到的最大结果
    - 给定一个字符串num, 可以删除指定的一个数字d, 要求删除后的数字最大
    - 思路: 从左往右遍历, 对于位置i的数组d满足 `num[i]<num[i+1]`, 则显然可以删除该数字. 否则, 应该删除最后一个数字d所在的位置.
- 6048. 必须拿起的最小连续卡牌数
- 6049. 含最多 K 个可整除元素的子数组
    - 条件: 子数组中能够被数字 p 整除的元素的个数最多为 k
    - 对一个数组的所有 **连续非空** 子数组, 计算满足条件的不同的数组数量.
    - 思路: 本题复杂度为 `1 <= nums.length <= 200`, 因此用一个 isPdivisible 数组记录每个数字是否可被整出, 然后用一个set记录出现的不重复子数组即可.
- 6050. 字符串的总引力 #hard #题型 #排列组合
    - 定义一个字符串的引力: 不同字符的数量. 要求所有子字符串的引力之和.
    - 复杂度: `1 <= s.length <= 10^5`
    - 尝试了对于每一个长度进行「滑动窗口」, 复杂度为 O(n^2), 显然会超时.
    - 思路: 遍历累计
        - 考虑序列中某一个ch会在多少个子串中出现?
        - 不考虑本题, 一般情况下, 对于位置idx的ch, 序列 `...xxx[ch]xxx...` 的子串中出现ch的个数为: `(idx+1) * (len-idx+1)` 也即左右两边的长度分别匹配.
        - 本题中, 只有在子串中第一次出现的ch才计数假设. 因此假设出现的位置分别为 `idx[1], idx[2],...idx[i], ...`. 对于第 i 个, 其 **作为第一个ch出现在子串中** 的数量为 `(idx[i]-idx[i-1]) * (len-idx[i]+1)`. 注意相较于之前的公式左边界进行了限制.
        - 因此, 在遍历过程中, 对于不同的ch分别记录出现的 idx, 并累计计数.
    - 思路二: 类似DP.
        - 考虑从长度为 i 的前缀字符串拓展到 i+1 的变化情况. 增加了 i+1 个子串, 分别是 `s[1:i+1], s[2:i+1]...s[i+1:i+1]`. 我们要计算这些新子串所包括的引力值: 两部分
            - 末尾字符的: `idx[i+1]-idx[i]`
            - 其他字符的引力值 等价于 **所有以第i个字符结尾的子串的引力值**. 记这个值为 `sum_g`, 易知迭代公式 `sum_g[i+1] = sum_g[i] + (idx[i+1]-idx[i])`
        - see [here](https://leetcode-cn.com/problems/total-appeal-of-a-string/solution/by-endlesscheng-g405/)


### 292

- 6056. 字符串中最大的 3 位相同数字
- 6057. 统计值等于子树平均值的节点数
    - 对于一棵二叉树, 统计「节点值 = 节点所定义的子树中所有节点值的平均值」的节点数量
- 6058. 统计打字方案数
    - 按照 0-9 到字母的键盘映射 (例如, 按 `'5'` 两次得到字母 `'k'`). 这样, `33` 可能表示 `dd` 或者 `e`.
    - 给定按键的序列, 计算其映射出来的字母的方案数
    - 思路: #DP + 累乘
        - 首先, 对于一个数字, 比如 `2` 映射到 `abc`; 给一个长度为 i 的连续 2, 其可能的方案数是: `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`. 因此先用DP预先计算好所有的结果.
        - 然后对于案件序列按照上述 DP 累乘即可
        - 注意: 1) 一个数字可能对应 3/4 个字母, 需要区分; 2) 这样 DP 递归的数字很大, 要在计算过程进行 MOD, 自己提交时没有加, **Python 大整数计算超时**.
- 6059. 检查是否有合法括号字符串路径 #括号匹配
    - 给定一个仅包括 `()` 的grid, 要求判断从左上到右下是否存在一条路径, 使得括号序列合法.
    - 思路0: DFS, 超时了! 因为grid搜索的复杂度为 2^n, 这里n=100还是会超.
        - #cache
        - 改进: 参考 [here](https://leetcode-cn.com/problems/check-if-there-is-a-valid-parentheses-string-path/solution/tian-jia-zhuang-tai-hou-dfscpythonjavago-f287/) 加了 cache 之后过了
        - 离谱的是, 用默认的 `lru_cache(maxsize=128)` 会超时, 答案中用的是 Python 3.9 新的 `cache = lru_cache(maxsize=None)` 就可以过, 而且速度很快, 可能是 lru_cache 的实现太重了吧
    - 思路1: #DP
        - 从上往下一层一层遍历: 没一点可以由左侧或者上方的节点转移过来
        - 用 `dp[i][j]` 记录从左上角遍历到 (i,j), 剩余的左括号的数量, 用 set 记录.
        - 转移: 对于 (i,j), 取 `dp[i-1][j], dp[i][j-1]` 的 union, 然后根据 `grid[i][j]` 是左/右括号, 对于集合中的每个元素 +/-1, 注意不能出现负数

## 双周赛 D60-D100

### D60

- 1991. 找到数组的中间位置 / 0724. 寻找数组的中心下标
- 1992. 找到所有的农场组 #题型
    - 找到一个 grid 中的所有矩形, 矩形之间满足不相邻
    - 思路: 模拟
- 1993. 树上的操作
    - 需要构建一种树结构, 能够实现 Lock, Unlock, Upgrade 操作. 其中 Lock, Unlock 操作针对单个节点比较 naive.
    - Upgrade(node, user) 操作要求满足: 1) 节点及其祖先节点未上锁, 2) 其孩子节点至少有一个上锁.
    - 思路: 对于节点维护 parent, children, lockUser 属性, 在 Upgrade 操作中向上向下分别遍历检查条件.
- 1994. 好子集的数目 #hard
    - 给定一组数字, 都不大于30. 求满足条件的所有子集的数量, 条件为: 子集中所有数字的乘积可以 = 不同的质数的乘积.
    - 方法一：#状态压缩动态规划 #状态压缩
        - [here](https://leetcode-cn.com/problems/the-number-of-good-subsets/solution/hao-zi-ji-de-shu-mu-by-leetcode-solution-ky65/)
        - 由于数字都比较小, 可以罗列所有的质数 `primes=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]`
        - 对于一组数字, 它们所用到的质数可以通过状态压缩来表示, 即 0/1 表示以上10个质数用到了哪几个, 记为 mask
        - 考虑 DP: 用 d`p[i][mask]` 表示只使用数字 `2~i`, 并且所用的数字的质数组合为 mask, 这样的子集的数量.
            - 状态转移方程: 若 数字i本身包含平方因子, 例如 4, 12 等, 则该数字无法采用, `dp[i][mask] = dp[i-1][mask]`;
            - 否则, 假设i包含的质数组合为 subset, 则 `dp[i][mask] = dp[i-1][mask] + dp[i-1][mask\subset] * freq[i]`, 其中的 subset 必然是 mask 的子集, mask\subset 可以异或得到
        - 因此, 从 i=2开始遍历到 30, 最后的结果 `sum(dp[30][mask])` 表示所用的质数组合为 mask 的方案数量. 注意 `dp[][0]` 没有意义: 因为 mask=0 表示没有取到任意质数.
        - 需要注意的是数字 1, 其作为因子不影响乘积, 因此可以取任意数量; 然而, 单纯用数字1不满足条件. 两种方案:
            - 取 `dp[1][0] = 1`, 从而避免 `dp[i-1][mask\subset] * freq[i]` 式子中的判断; 最后取 `sum(dp[30][1:]) * 2**freq[1]`
            - 也可以初始化 `dp[1][0] = 2**freq[1]`, 表示单纯用 1 的组合数量; 最后取 `sum(dp[30][1:])` (因为单纯用数字1不满足条件)

### D61

- 2006. 差的绝对值为 K 的数对数目
- 2007. 从双倍数组中还原原数组 #题型
    - 对于一个数组的所有数字变为双倍, 混入原数组. 现在要求还原数字.
    - 思路: Counter 之后从大到小遍历.
    - 特殊: 0 的双倍还是 0
- 2008. 出租车的最大盈利 #medium #题型
    - 出租车从 1开到n, 给定一组 `rides[i] = [start_i, end_i, tip_i]` 表示可以接到的单子, 每单的价格为 `end_i - start_i + tip_i`, 要求一趟下来最多获得多少钱.
    - 复杂度 n 为 1e5, rides 长度 3e4
    - 思路: #DP
        - 用 dp[s] 表示从时刻 s 开始接单的最大收益.
        - 因此, 对于 rides 基于 start 逆序排序. 对于第i个交易 `dp[start] = max(dp[start], dp[end] + fee_i)`.
        - 存储方式1: (超时了, 按理说复杂度应该还行?) 考虑到不连续性, 对于dp key 采用排序数组, 然后对于有值的那部分用字典存下来 (bisect 查找)
        - 存储方式2: 更为经典的连续存储方案, 保存一个长度为 n 的数组, 通过 `dp[start] = dp[start+1]` 进行初始化
- 2009. 使数组连续的最少操作数 #题型
    - 给定一个长度为L的数组, 每次可以对于数组的任意一个元素替换为任意的值, 要求最少替换次数, 是的数组中的元素构成连续的L的整数. 例如 nums = [4, 2, 5, 3] 是 连续的
    - 思路1: 排序+ #双指针
        - 注意到出现多次的数字一定需要被修改, 因此取 unique 然后对于数组排序. 用 left 指针从左往右扫描, 尝试移动 right 指针, 满足 `nums[right] - nums[left] < L`.
        - 这样对于每一个 left 位置, 原数组中保持不变的index区间为 [left, right], 每次更新答案 `ans = min(ans, L-(right-left+1))`
        - see [here](https://leetcode-cn.com/problems/minimum-number-of-operations-to-make-array-continuous/solution/on-zuo-fa-by-endlesscheng-l7yi/) 对于 right 如果不用双指针还可以直接 bisect

### D62

- 2022. 将一维数组转变成二维数组
- 2023. 连接后等于目标字符串的字符串对
    - 给定一组字符串 和一个目标字符串 target, 返回从这组字符串中选择两个拼接可以得到 target 的组合数量.
- 2024. 考试的最大困扰度 #题型
    - 给定一个包含两种元素的序列, 最大改动数量为 k, 尽可能使得出现的连续相同元素最大
    - 思路: #双指针 #滑动窗口
    - 针对每种元素遍历数组 (可以写成一个函数), 在双指针遍历过程中, 维护左右指针之间的修改数量不超过 k. 具体而言, 可以 for 循环 `right`, 在超出条件的时候步进 `left`
    - 参 [here](https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/solution/kao-shi-de-zui-da-kun-rao-du-by-leetcode-qub5/)
- 2025. 分割数组的最多方案数 #题型
    - 给定一个数组和一个数字k, 允许将数组中的某一个数字修改为k (也可以不修改), 要求最大化满足条件的分割数量.
    - 条件: 给定一个 `1<=pivot<n`, 将数组分割为 nums[0:pivot-1] 和 nums[pivot:n-1] 两部分 (闭区间), 使得两部分的和相等.
    - 思路: #双哈希表 #前缀和
    - 计数组的前缀和为 cumsum, 总和为 total.
    - 在不修改的情况下, 合法分割为 cumsum[i] = total-cumsum[i], 即 cumsum[i] = total/2.
    - 考虑修改的情况: 将第i个元素进行修改, 记变化量为 `d = k-nums[i]`, 对于i之前的元素其累计和不变, 之后的元素累计和增加d.
        - 因此, 1) 对于之前的元素, 合法条件变为 cumsum[j] = total+d-cumsum[j], 即 `cumsum[j] = (total+d)/2`; 2) 对i及其之后的元素, cumsum[j]+d = (total+d)-(cumsum[j]+d), 即 `cumsum[j] = (total-d)/2`
    - 因此, 在遍历修改元素 i 的过程中, 用双哈希表记录前后的 cumsum 分布情况.
    - 参 [前缀和+双哈希表+枚举修改元素](https://leetcode-cn.com/problems/maximum-number-of-ways-to-partition-an-array/solution/qian-zhui-he-ha-xi-biao-mei-ju-xiu-gai-y-l546/)
    - 注意: 这里要求的分割点必须在数组的中间, 在维护双哈希表的时候应该去掉total的情况. (见代码)

### D63

- 2037. 使每位学生都有座位的最少移动次数
    - 给定一组座位的位置和一组学生当前的位置, 要求对每个人匹配到合适的位置所需最少移动次数
    - 思路: 直接按照排序的结果一一匹配
- 2038. 如果相邻两个颜色均相同则删除当前颜色
- 2039. 网络空闲的时刻 #网络
    - 有 n 个节点, 0 号为服务器, 其他为数据节点. 节点之间通过网络连接, 经过一个时间段信息传递一条边.
        - 现所有的数据节点需要向服务器发送信息, 服务器收到后发送反馈. 每个数据节点还有一个 `patience[i]`, 表示在经历这么长时间没有收到回复则重发消息.
        - 要求计算经过多少时刻后, 网络上没有数据包 (空闲).
    - 思路: #BFS + 遍历
        - 每个数据节点和服务器的关系是独立的, 因此, 分别计算每个数据节点到服务器的距离, 遍历计算即可.
        - 对于数据节点 i 来说, 其距离和等待时间为 distance[i], patience[i], 则收到最后一个数据包的时间为: `2*distance[i] + 1 + 2*distance[i]//patience[i]*patience[i]`
        - 其中, `2*distance[i] + 1` 是第一个数据包发送到收到回复的时间, `2*distance[i]//patience[i]*patience[i]` 是可能有的接受不了重发数据包所需的额外时间.
- 2040. 两个有序数组的第 K 小乘积 #hard
    - 对于两个有序数组 nums1 和 nums2, 定义它们之间的交互乘积 `nums1[i] * nums2[j]`, 要求返回这些数中第 k 小的 (从1开始).
    - 复杂度: 两数组的长度为 5e4, 数字范围为 -1e5~1e5.
    - 思路 1: #二分查找 + #双指针 + #分类讨论
        - 基本的思路是二分查找可能的范围 `[-1e10, 1e10]`
        - 根据零将两个数组分别分为负数和非负数两部分, 然后分类统计两两组合之下, <= 待搜索的 m 的组合的数量; 由于采用双指针形式, 二分判断的复杂度为 O(L), 因此总复杂度为 O(Llog(N)), 这里 L为数组长度N为搜索空间大小.
        - [解答](https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/solution/yi-ti-san-jie-shuang-zhi-zhen-jie-bu-den-sqsu/) 还可以对于四种条件进行合并讨论
    - 思路 2: 也是二分查找框架, 不过在组合 nums1, nums2 的时候, 直接利用不等式条件, 内部进行一次二分搜索.
        - 这样, 内部二分的复杂度为 O(LlogL), 整体的复杂度为 O(NLlogL).
        - 具体而言, 对于 nums1[i], 要求 nums1[i] * nums2[j] <= m, 根据 nums1[i] 与0 的关系, 可以直接计算出如 nums2[j]<=m/nums1[i], 基于这个条件进行二分搜索.
    - 思路 3: 通过前缀和代替二分
        - 在上一种解法中, 复杂度增加了, 实际上我们可以通过 #前缀和 来避免内部的二分. 注意到 nums 的元素范围为 `[-1e5, 1e5]`, 我们可以利用前缀和得到 `cumsum[m]` 表示数组中包括多少个小于等于 m 的元素.



### D68

- 2114. 句子中的最多单词数
- 2115. 从给定原材料中找到所有可以做出的菜
    - 给定一个菜单, 每道菜的成分可能包括食材或其他的菜品, 要求在一定的初始食材下能够得到的所有菜品
    - 思路一: 本题数据量比较小, 可以暴力遍历. 用一个 flag 记录一次遍历是否有新的菜品(食材) 生成, 当没有时即结束
    - 思路二: 依赖关系构成图, 显然可以用 `拓扑排序` 解决, see [here](https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/solution/cong-gei-ding-yuan-cai-liao-zhong-zhao-d-d02i/)
- 2116. 判断一个括号字符串是否有效 `中`
    - 给定一个在某些位上固定的字符串 (例如 `s = "))()))", locked = "010100"`), 判断能够通过修改其他自由位使其成为合法的括号序列
    - 思路一: 关注 lock 部分 (剩下偶数个自由位一定可以匹配)
        - 先尝试匹配 lock 部分的字符串, 记录未成功匹配的位置 (三种情况, 最后剩下 `((`, `))` or `))((`; 和 空白符号的位置;
        - 利用 space 字符串来匹配剩下的左右括号 leftStack, rightStack
        - 原本分了上面三种情况讨论, 实际上可以合并: 用 space 最前面的部分匹配右括号, 最后面的部分匹配左括号, `len(spaces)>=len(leftStack)+len(rightStack) and all([i>j for i,j in zip(spaces[-len(leftStack):], leftStack)]) and all([i<j for i,j in zip(spaces[:len(rightStack)], rightStack)])`
    - 方法一：数学, see [here](https://leetcode-cn.com/problems/check-if-a-parentheses-string-can-be-valid/solution/pan-duan-yi-ge-gua-hao-zi-fu-chuan-shi-f-0s47/)
        - 定义了有效字符串「分数」的概念, 然后通过: 维护 1. 前缀 s[0..i] 可以达到的最大分数；2. 前缀 s[0..i] 「可以达到的最小分数」及「作为有效前缀所需的最小分数」两者的较大值. 这两个数组来进行判断.
- 2117. 一个区间内所有数乘积的缩写 `难`
    - 放弃了
    - 参见 [思路详解+详细讨论一下精度问题](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/fen-bie-ji-suan-qian-5wei-he-hou-5wei-si-dc9x/), Python 超时了. 另外 [here](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/yi-ge-shu-ju-tuan-mie-jue-da-bu-fen-dai-234yd/) 做了更多的分析

### D69

- 2129. 将标题首字母大写
- 2130. 链表最大孪生和
- 2131. 连接两字母单词得到的最长回文串
    - 给一组长度为2的字符串, 将他们拼接, 形成最大的回文串
    - 考虑 1. aa 的形式, 若数量为奇数, 只能放在中间, 若为偶数, 可以两侧对应位置放置; 2. ab + ba 的形式, 左右对称放置
- 2132. 用邮票贴满网格图
    - 给一个矩阵grid, 其中数字为1的位置不能使用; 要求用 stampHeight x stampWidth 的邮票去贴满所有空的位置, 返回能否实现. 矩阵不可旋转, 可以重叠.
    - 二维前缀和 + 二维差分
        - from [here](<https://leetcode-cn.com/problems/stamping-the-grid/solution/wu-nao-zuo-fa-er-wei-qian-zhui-he-e>
        - r-wei-zwiu/)
        - 首先, 利用 **二维前缀和矩阵** 可以快速计算 (x1,y1), (x2,y2) 区域内的元素和.
            - 前缀和 `m[x,y]` 表示 (0,0),(x,y) 所定义的矩阵之和;
            - 递推计算公式为 `m[x+1,y+1] = m[x+1,y]+m[x,y+1]-m[x,y]+matrix[x,y]`. 这里的前缀和矩阵 m 有哨兵, 即大小为 (m+1,n+1)
            - 利用二维前缀, 求 (x1,y1),(x2,y2) 所定义的子矩阵之和的计算公式为 `m[x2+1,y2+1] - m[x2+1,y1] - m[x1][y2+1] + m[x1,y1]`.
            - 在本题中, 计算grid的前缀和矩阵, 即可以用来判断该区域内是否有1.
        - 根据二维前缀和的计算, 可以定义 **二维差分矩阵**. 另参见 [here](https://zhuanlan.zhihu.com/p/439268614)
            - 计算公式为 `s[x,y] = matrix[x,y] - matrix[x-1,y] - matrix[x,y-1] + matrix[x-1,y-1]` (注意和上面前缀和的递推计算意义不一样)
            - 可知, 我们所定义的差分矩阵, 其前缀和就是原矩阵!!
            - 根据差分矩阵, 我们可以快速在 (x1,y1), (x2,y2) 范围内都加上一个数字: 等价于在其差分矩阵的 `(x1,y1),(x2+1,y2+1)` 位置+1, `(x2,y1+1),(x1+1,y2)` 位置-1.
            - 在本题中, 利用对于每个为空的坐标,尝试以其为左上角贴邮票, 利用差分矩阵记录贴上去的邮票所占据的位置. 最后利用差分矩阵还原, 计算每个位置的邮票数量, 若出现原本为空的位置没有贴上邮票, 说明不满足.
        - 注意, 为了边界条件, 1. 这里定义的前缀和矩阵第一行第一列为0; 2. 而根据差分的定义, 在更新(x2,y2)位置时候用到了 s(x2+1,y2+1), 因此形状也为 (m+1,n+1).

### D70

- 2144. 打折购买糖果的最小开销
- 2145. 统计隐藏数组数目
- 2146. 价格范围内最高排名的 K 样物品
    - 网格搜索, 0表示不能走, 不同的格子有价格, 要求找到价格在 pricing = [low, high] 区间内的位置.
    - 要求找到优先级最高的k个, 优先级为: 1. 距离; 2. 价格; 3. 行坐标; 4. 列坐标.
    - 思路: BFS.
        - 广度优先, 每一轮维护 paths 记录当前可到达的坐标, potentials 为满足pricing约束的坐标集合, 然后 `select(potentials, k)` 根据优先级筛选.
        - 注意边界条件: 1. 每一轮中,当paths为空时说明无法继续搜索; 2. 开始状态, 需要判断start点是否符合要求并加入visited.
- 2147. 分隔长廊的方案数
    - 简单

### D71

- 2160. 拆分数位后四位数字的最小和
- 2161. 根据给定数字划分数组
- 2162. 设置时间的最少代价
    - 设置四位的时间, 前后两位分别表示分钟和秒钟, 例如 `8090` 表示 80*60+90 秒
    - 给定 startAt ，moveCost ，pushCost 和 targetSeconds 分别表示初始的手指位置, 移动和按按钮的代价, 以及目标的秒数, 要求返回最小的代价. **前置0可以不输入**
    - 思路: 模拟
        - 注意到, 犹豫两位数字可以大于59, 因此同样的秒数可能有多种表示. 除了 1. 基本的 `minutes, seconds = targetSeconds//60 , targetSeconds%60`, 还有可能 2. 是 `minutes-1, seconds+60` (`seconds+60<100`), 计算两者较小的代价.
        - 用函数 `getCost(minutes, seconds)` 模拟该方案的代价.
        - 需要注意边界: 1. 当 `targetSeconds<60` 时 第二种方案非法; 2. 当 `targetSeconds>=60000` 时, 第一种方案非法. 因此可以在 getCost 函数中增加判断: `minutes>99 or seconds>99 or minutes<0 or seconds<0` 时返回 Inf, 更简单.
- 2163. 删除元素后和的最小差值
    - 给一个长度为 3n 的数组 nums, 要求删除其中 n个数字, 使得删除后, 数组前n个数字之和 - 后n个数字之和最小.
    - 方法一：优先队列 [here](https://leetcode-cn.com/problems/minimum-difference-in-sums-after-removal-of-elements/solution/shan-chu-yuan-su-hou-he-de-zui-xiao-chai-ah0j/)
        - 目标: 前n个数字之和最小, 后n个数字之和最大.
        - 可知, 最后剩余的两组数字, 其原始的分割点一定在 [n, 2n] 之间. 因此, 可以 遍历遍历每一个分割点, 分别计算前后的最小和最大和, 然后求最小值.
        - 为此, 可以分别建立一个最大堆和最小堆, 遍历 [n, 2n] 个数字 (pushpop), 记录每一个分割点的的值. 需要注意的是, 后半部分应该逆序, 注意代码.

### D72

- 2176. 统计数组中相等且可以被整除的数对
- 2177. 找到和为给定整数的三个连续整数
- 2178. 拆分成最多数目的偶整数之和
- 2179. 统计数组中好三元组数目
    - 给两个数组, 分别是 [0:n-1] 的一个排序, 要求找满足条件的三元组数量, 条件: (x,t,z) 出现在两数组中的次序是一致的.
    - 分析可知, 将nums1中数字在num2中的index依次写出来, 记为 numMap, 则结果就是该数组中递增的三元组的个数
    - 思路1:
        - 遍历 numMap, 对于一个数字 num, 考虑以num结尾的长度为2的递增数组的数量 —— 为数组之前部分比num小的元素数量; 记为 last1
        - 进一步考虑以num结尾的长度为3的递增数组的数量, 可知其为 last1 中, 所有小于num的组数之和.
        - 因此, 这里的核心问题在于: 实现一个数据结构, 可以 1. 查询其中比 query 小的数量; 2. 插入某一个数值的数量.
        - 该问题可以建模为 「**树状数组/线段树**」, 参见 [here](https://oi-wiki.org/ds/fenwick/)
    - 思路2 树状数组:
        - 已知, 问题可以转化为, **在一个数组中计算递增三元组的数量.**
        - 分别用两个 BIT, 计算位置i之前的比 num[i] 小的数量, 以及位置i之后的比 num[i] 大的元素数量. 这样最终的结果就是 `sum(low[i]*high[i] for i in range(n))`
    - 另见 [here](https://leetcode-cn.com/problems/count-good-triplets-in-an-array/solution/deng-jie-zhuan-huan-shu-zhuang-shu-zu-by-xmyd/)

### D73

- 6024. 数组中紧跟 key 之后出现最频繁的数字
- 5217. 将杂乱无章的数字排序
- 5300. 有向无环图中一个节点的所有祖先
    - 给一个 DAG, 要求返回每一个节点的所有祖先节点 (排序)
    - 思路一: 可以通过 DFS 找到节点的所有孩子, 在 **逆图** 上做即可
- 5237. 得到回文串的最少操作次数 #hard
    - 给一个字符串, 仅有的操作为交换相邻两个字符, 要求转为回文串的最小交换次数
    - 思路一: 两次贪心 [here](https://leetcode-cn.com/problems/minimum-number-of-moves-to-make-palindrome/solution/de-dao-hui-wen-chuan-de-zui-shao-cao-zuo-nnis/)
        - 首先需要理解: **逆序数** 等于一个 序列要变成升序排列所需要的相邻元素交换的最小次数。 see [here](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/ni-xu-shu-yu-pai-xu-de-nei-zai-lian-xi-wu-dai-ma-b/)
        - 先考虑偶数长度的情况: 可知, 对于 2m 个字符ch, 其中的前m个字符, 也一定在最终的回文串的前一半中, 并且它们之间的相对位置保持不变.
            - 因此, 分解为两步: (1) 组间交换. 先划分左右两个子串. 由于不改变相对位置, 其实我们就知道了原本字符串的每一个位置的元素, 在分为好左右组的字符串中的位置.
            - (2) 组内交换, 也即是的左右子串转换为对称. 由于没有相对位置变化, 因此我们固定左子串, 则对于右子串中每一个字符最终的位置其实我们就确定了 —— 等于求逆序数.
        - 而对于奇数情况, 简单令右子串多一个元素, 然后在左子串后加上那个中心的(奇数)字符, 则约束了右串排序中将其移动到中间.
    - 思路二: 贪心 [here](https://leetcode-cn.com/problems/minimum-number-of-moves-to-make-palindrome/solution/tan-xin-zheng-ming-geng-da-shu-ju-fan-we-h57i/)
        - 其实在上面的思路中, 我们已经知道了最终的回文串是怎样的 —— 左子串由所有字符的前一半出现位置决定, 右子串对称.
        - 因此, 更为贪心的策略是: 每次保留左侧的第一个字符, 将最右边的该字符移动到右侧, 这样就完成了匹配.
        - 对于奇数的情况, 只需要将其移动到中心即可.

### D74

- 2206. 将数组划分成相等数对
- 2207. 字符串中最多数目的子字符串
    - 有可以字符串 text 和长度为 2 的 pattern (记为字符 a 和 b), 可以对 text 插入一个字符 a/b.
        - 要求计算操作后 text 的子字符串恰好是 pattern 的数量. 注意「子字符串」的定义不要求连续, 因此 `aabb` 包括 四个子字符串 `ab`.
    - 思路: 注意到, 这里插入的字符最优解为在最前面插入a 或最后插入b (取决于text中a/b的数量). 而原本text自身的子字符串数量可以 O(n) 求解 (记录 countA, countB).
        - 特殊情况: a==b
- 2208. 将数组和减半的最少操作次数
    - 每次选择数组中的一个元素减半, 要求使得数组和减半需要的次数.
    - 思路: 每次选最大的即可. 采用 heap 实现. 注意 heapify 默认是最小堆, 因此需要取反.
- 2209. 用地毯覆盖后的最少白色砖块
    - 给一条黑白地板 floor 铺地毯, 要求剩余最少的白色. 给定 numCarpets 条长度为 carpetLen 的黑色地毯.
    - 思路: DP
        - 定义状态: dp[i][j] 表示用 i 条铺 **前面 j 个地砖**, 剩余的最少白色砖块数.
        - 状态转移: dp[i][j] = min(dp[i][j-1]+(floor[j]=="1"), dp[i-1][j-carpetLen]). 其中第一式表示不用地毯.
        - 参见 [here](https://leetcode-cn.com/problems/minimum-white-tiles-after-covering-with-carpets/solution/by-endlesscheng-pa3v/)

### D75

- 2220. 转换数字的最少位翻转次数
- 2221. 数组的三角和
    - 对于一个数组, 重复进行如下操作, 直到长度为 1, 返回最后的数据
        - 将相邻两个元素相加, 得到新的长度 -1 的数组.
    - 分析可知, 就是杨辉三角, 调用 math.comb(n-1, i) 即可.
- 2222. 选择建筑的方案数
    - 有两类建筑, 要求从中选择三栋, 选择的三个中相邻的类别不能相同. 返回所有方案的数量.
    - 思路: 1) 考虑中间的那栋楼, 则两侧的选择必须是另外一个类型; 2) 为了计数, 考虑 cumsum; 3) 为了避免确定变量, 可以讲 "001101" 转为 [2,2,1,1] 的形式
        - 具体而言, 可以分别从左到右, 从右到左计算累加和 (间隔为2的累加和, 例如上例为 [2,2,3,3]), 然后直接 `cumsumLeft[i-1] * newS[i] * cumsumRight[i+1]` 即可.
    - 写得复杂了, 由于形式只可能为 010/101, 实际上遍历一次index即可; 记录下目前已有的 1, 则遇到0时, 以这个0为中间数的方案数为 `count_a * total_a - count_a`, 参见 [here](https://leetcode-cn.com/problems/number-of-ways-to-select-buildings/solution/xuan-ze-jian-zhu-de-fang-an-shu-by-leetc-jhup/)
- 2223. 构造字符串的总得分和 #hard
    - 对于一个字符串, 从右往左得到长度为 1,2,... 的连续子串, 分别计算该子串与原字符串的最大前缀长.
    - **Z 函数**（**扩展 KMP**） 参见 <https://oi-wiki.org/string/z-func/>
    - 我们定义 Z 函数为: **z[i] 为 s[i:n-1] 与原字符串 s 的最长前缀匹配长度**.
        - 也即, `s[i:i+z[i]-1] = s[0:z[i]-1]` (闭区间), 称为 匹配段, 也可以叫 **Z-box**
    - 核心是要维护一个匹配区间 [l,r] (Z-box)) 满足该区间为前缀匹配; 在遍历过程中, 维护 `l<=i`.
        - 对于遍历到的 i, 若 `i<=r`, 此时有 `s[i:r] = s[i-l:r-l]` (闭区间),
            - 若还满足 `z[i-l]<r-i+1` (区间 [i,r] 的长度为 r-i+1, 我们已经在遍历 i-l 时发现了前缀匹配长度比它小), 则有 z[i] = z[i-l]
            - 否则, 说明 [i,r] 区间是前缀, 从 r+1 开始继续匹配
        - 若不满足 `i<=r`, 则从 i+1 开始继续匹配 (和上面的情况2一样)
        - 注意当我们遍历超过 r 时需要更新 `l, r = i, i+z[i]-1` (显然维护的条件 `i<=l` 仍满足)
    - 复杂度分析 (看下面的代码): 外层 i 循环一遍, 内部的 while 训练每执行一次都会使得 r 向后移动, 因此最多执行 O(n) 次; 所以总的复杂度为 O(n).

### D76

- 2239. 找到最接近 0 的数字
- 2240. 买钢笔和铅笔的方案数
- 2241. 设计一个 ATM 机器 #medium
    - 难度不大. 需要写一个类. 通过这题希望写一个函数进行本地调试.
- 2242. 节点序列的最大得分
    - 给一张带节点权重的无向图, 求长度为4的节点序列的最大得分. 序列之间需要连接, 四个节点不得重复.
    - 复杂度: 节点和边均为 5*1e4
    - 思路: 直接遍历肯定会超时. 关键看这里的序列长度为4, 因此可以考虑 **遍历中间的两个节点** (边)
        - 进一步降低复杂度: 从边 uv 的两个节点出发, 各拓展出一个节点 a,b; 为了使得分数和最大, 则搜索的 ab 节点权重必然是最大/次大的; 因此, 仅需要对每个节点维护最大的三个邻居即可 (还要考虑 uv 边可能最最大邻居)
        - 在简化了搜索空间的基础上, 可以用 `itertools.product(neighbors(u), neighbors(v))` 直接遍历所有可能的节点对, 而不需要 uv 的邻居进行排序比较等复杂的判断.
        - 参见 [here](https://leetcode-cn.com/problems/maximum-score-of-a-node-sequence/solution/by-endlesscheng-dt8h/)

### D77

- 6051. 统计是给定字符串前缀的字符串数目
- 6052. 最小平均差
- 6053. 统计网格图中没有被保卫的格子数
    - grid 上有一组墙和一组guard, 守卫可以守护上下左右四个方向的格子, 遇到墙就停止. 要求累计grid中没有被守卫守护的格子数.
    - 思路: 对于每个guard 的四个方向遍历即可, 时间复杂度 O(m*n*4)
- 6054. 逃离火灾 <https://leetcode-cn.com/problems/escape-the-spreading-fire> #hard
    - 给定一个 grid, 有一组火源和一组墙, 每过一个时刻, 火网四周蔓延一圈, 但是不能穿过墙. 人要从左上角逃到右下角, 问人能够在起点等待的最长时间.
    - 思路: BFS.
        - 1) 先从所有的火点开始进行BFS, 记录所有点距离火的位置; 2) 然后从起点出发BFS, 对于路径上的每一个点, 火到达的时间为 `fireDist[(nx,ny)]`, 而距离为 `nd`, 因此:
            - 若 fireDist[(nx,ny)]<=nd 说明火先到达, 该点探索失败; 否则, 所能等待的时间为 `nLimit = fireDist[(nx,ny)] - nd - 1`;
        - 3) 这样, 进行 BFS遍历后, 若能到达终点, 该条路径的最大等待时间为 `max([nLimit])`.
        - 繁琐的是要处理边界情况: 当人和火同时到达终点时, 算成功逃生.
        - 另外, 在本题中, 可能出现多条路径都能到达终点的情况, 因此遍历到终点后, 不能直接返回!
    - 注意: DFS 若要不重复访问节点, 就要用visited记录访问的点; 但第一次访问不一定是最短, 因此无法得到最短路径; 若要得到最短路径, 就只能记录当前路径经过的点, 会带来重复访问的问题!
        - 用BFS 同样可以记录路径: 只需要记录当前路径经过的点即可, 增加少量的存储开销
    - 一开始纠结于BFS如何记录路径的问题, 采用DFS求最短路径, 结果因为重复访问超时了
