!!! warning
    原本计划把值得的题目记录在这里, 但实际上重看的可能性较低. 之后直接放到单独的文件中, 并进行分类整理.

# 周赛笔记

## 周赛 151-200

### 194

T2 细节较多; T3的复杂度比较玄学, 感觉官答也不太清楚; T4要求最小生成树的「关键边」, 比较高级的内容了.

- 1487. 保证文件名唯一 #medium #细节
    - 顺序来一系列的文件名创建请求. 若文件已经创建过, 则修改为 `name(1)` 这种形式. 要求模拟返回的结果.
    - 注意: 可能会有 `["gta","gta(1)","gta"]` 这样的序列. 因此, 对于新生成的文件名也需要检查是否占用.
- 1488. 避免洪水泛滥 #medium #题型
    - 有无限个湖泊, 给定一个数组表示晴雨, 若值=0说明那天是晴天, 否则第i个湖泊会装满水. 若雨下在装满水的湖泊, 则发生洪水. 你可以在晴天抽干一个湖泊. 目标是不发生洪水, 给出一个抽水的策略. 限制: 数组长度 n 1e5
    - 思路1: 顺序记录晴天的每个日期, 在发生洪水的日期范围内 #二分 搜索晴天.
        - 注意, 例如 [0,2,2] 虽然前面有一个抽水机会, 但不在两次下雨的日期范围内.
        - 复杂度: 若使用数组, 可能每次都需要移除第一个元素, 则这样的复杂度为 `O(n^2)`. 若采用有序数组, 则 `O(n logn)`.
- 1489. 找到最小生成树里的关键边和伪关键边 #hard #题型 #kruskal
    - 给定一张带权图, 要求返回「关键边」和「伪关键边」, 也即必须出现在 #最小生成树 上的边, 和存在某一棵最小生成树其中包含的边. 限制: 节点数量 n 100; 边数量 m 200
    - 提示:
        - 如何最小生成树? 可以采用 #kruskal 算法, 也即从小到大枚举边. 假设已经排好序, 复杂度 `O(m *a)`. 其中a是判断两个节点是否在同一个连通分量的复杂度, 例如用优化的 #并查集 就是 阿克曼函数的反函数.
        - 如何判断是否为「关键边」? 删去后再运行kruskal, 看是否还能生成最小生成树.
        - 如何判断是否为「伪关键边」? 首先将该边加入集合, 看是否能生成最小值.
    - 思路1: 先求出不带约束的最小生成树值 mn. 然后便利每一条边, 根据提示判断是否为 (伪)关键边.
        - 1.1 可以写一个 `kruskal(forbid=set(), pre:int=-1)` 的函数
        - 1.2 借助通用的并查集实现, 可以方便地对于 kruskal 进行修改, 见官答
        - 复杂度: O(m^2 *a)
        - 细节: 如何判断是否全联通? 一种思路是维护每一个分支的大小, 但有一些细节判断 (见1.1); 但这里可以直接用一个数字 setCount 记录当前连通分量的数量.
    - 思路2: 利用 #kruskal 算法的性质 和 #连通性 性质 #hardhard
        - 提示: 1) **对于kruskal算法, 当遍历完所有权重小于等于x的边之后, 「对应的并查集的连通性是唯一确定的，无论我们在排序时如何规定权值相同的边的顺序」**. 也即联通分量的数量, 每个分量所包含的节点是唯一的.
        - 因此, 我们可以根据权重大小一层一层往外看. 对于权重都为w的边, 1) 假如两个点在同一个联通分量上, 则为不相关的边; 2) 如何判断 关键/伪关键边? 注意到, **把相关的节点看成一张图, 则关键边对应的是其中的「桥边」**. 可采用 #Tarjan 算法得到.
        - 复杂度: 最慢的是排序, O(m logm)
    - [官答](https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/solution/zhao-dao-zui-xiao-sheng-cheng-shu-li-de-gu57q/).
    - 

### 195

- 1498. 满足条件的子序列数目 #medium
    - 给定一个数组， 问其子序列中， 满足最大元素和最小元素之和不大于 target 的数量。 限制： 数量 n 1e5
    - 思路1: 对于每一个元素, 二分查找可以匹配的最大元素.
        - 我们枚举最小元素为第i位置的, 通过二分找到它可以匹配的最大元素位置j (实际上bisect是其下一个位置). 第i个元素必选, 其他元素可选有 `2^(j-i-1)` 种方案.))`
        - 复杂度: O(nlog(n))
- 1499. 满足不等式的最大值 #hard #题型
    - 给定一组点， 要求在 xi,xj 在k范围内的， yi+yj+|xi-xj| 最大值。 限制: 点数量 1e5
    - 思路1： #优先队列
        - 在枚举第j个元素， 与其匹配的前面的第j个元素， 分数为 `yi+yj+xj-xi`, 因此i的分数为 si = yi-xi.
        - 因此, 用一个最小堆来记录 (si,xi) 信息; 在遍历j的时候, 通过 xj-xi 判断是否过期.
        - 复杂度: O(n logn)



### 196

T2有噱头, 需要想到转化情况; T3和T4 都是非常经典的题型, 需要较高的思维量.

- 1503. 所有蚂蚁掉下来前的最后一刻 #medium #脑筋急转弯
    - 有一根长n的木板, 上面有一组蚂蚁, 向左或向右移动, 到两侧会掉下木板, 左右相遇则调转方向. 问经过多少时间所有蚂蚁都掉下来? 限制: 数量 n 1e4
    - 提示: 两蚂蚁相遇, 虽然改变了方向, 但因为速度是一样的, 所以可以理解为相遇了没有任何影响.
- 1504. 统计全 1 子矩形 #medium #题型 #star
    - 给定一个01矩阵, 统计其所有子矩阵中, 全1矩阵的数量. 限制: 长宽 n 150
    - 思路1: #枚举 利用部分前缀和来加速.
        - 考虑以 (i,j) 为右下角的子矩阵数量. 若直接枚举左上角, 则复杂度过高.
        - 注意到, 对于 (h,w) 的矩阵, 其每一行全1的长度至少要w个, 因此, 可以从第i行往上依次检查可以构成多宽的
        - 复杂度: O(nm^2)
    - 思路2: #单调栈
        - 在思路1中, 向上可以构成的矩形宽度呈现递减趋势, 而我们需要每次进行递归吗?
        - 答案是没必要, 用单调栈进行优化. 结论: 这里存储的是单调信息是递减的矩形宽度, 但为了统计数量, 我们还需要高度信息, 因此单调栈存储的单元为 `(宽, 高)`.
        - 具体而言, 维护一个递增栈. 在考虑当前行时, 假如底边宽为 wi, 而栈顶的最大矩形为 (w,h), 若 w>wi, 则上面更宽的部分没有作用了, 直接弹出; 这部分和底边可以匹配的高度累计为 h+1.
        - 细节: 如何统计数量? **记录栈内矩形总面积**.
    - [官答](https://leetcode.cn/problems/count-submatrices-with-all-ones/solution/tong-ji-quan-1-zi-ju-xing-by-leetcode-solution/)
- 1505. 最多 K 次交换相邻数位后得到的最小整数 #hard #题型 #star
    - 给定一个字符串形式的整数, 每次可以交换两个相邻位, 问k步操作之内最多可以得到最小的数字. 限制: 数字长度 3e5
    - 提示: 从高到低选择最小的数字, 可以贪心选择最近的还没被用到的数字
    - 思路1: #贪心 #树状数字
        - 按照提示的方式贪心选择第1,2,...位, 每次从k次操作范围内选择最近的最小数字, 将其移动到最前面. (注意, 这样的操作次数是最优的)
        - 问题是, 经过前置操作后, 原本的位置发生了变化, 如何计算新的位置? 假设结果数字前i的位用到的数字在原本字符串中的位置是 [a1,a2,...ai], 而此次选择前置的数字的原本位置是idx, 它在经过之前操作后的位置在 `newidx = idx + sum(ai>idx)` 也即在idx之后前置的元素对于其位置发生了影响; 它需要被移动到 i+1 位, 消耗操作 `newidx - (i+1)` 次.
            - 需要的操作: **单点修改, 区间查询**, 可以通过 #树状数组 来实现.
        - 如何快速找到最近的最小数字? 我们对于0..9的位置进行索引, 用掉就pop, 每次从0到9查询是否还有剩余.
    - 具体见 [官答](https://leetcode.cn/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/solution/zui-duo-k-ci-jiao-huan-xiang-lin-shu-wei-hou-de-da/)


### 197

T3是 Dijkstra WA了一次, 正好跟着官答总结一下; T4居然考虑最优化/梯度下降, 值得总结!

- 1514. 概率最大的路径 #medium #题型
    - 等价于, 经典的「单源最短路径路径」, 在带权图上求 (s,e) 之间的最短距离.
    - 思路1: #Dijkstra 算法
        - 回顾 Dijkstra算法的核心思想: 1) 将节点分成两类: 「未确定节点」和「已确定节点」; 2) (「松弛」过程) 每次从「未确定节点」中取一个与起点距离最短的点，将它归类为「已确定节点」，并用它「更新」从起点到其他所有「未确定节点」的距离。直到所有点都被归类为「已确定节点」。
        - 细节: 1) 如何找到「未确定节点」中最小距离点? 例如可以用最小堆实现. 2) 如何分离两类节点? 一种方式是用 `visited` 字典标记已确定节点; 另一种方式是, 用一个 `minDist` 记录当前的距离, 更新过程中只有当v的距离比minDist小时才更新, 入栈. 实验下来两种方式没有复杂度上的区别.
        - [官答](https://leetcode.cn/problems/path-with-maximum-probability/solution/gai-lu-zui-da-de-lu-jing-by-leetcode-solution/)
- 1515. 服务中心的最佳位置 #hard #题型 #最优化
    - 给定一组点, 寻找一个点, 使其到这些点的距离只和最小. 限制: 数量 50, 范围 [0,100], 京都要求 1e-5
    - 提示: 这个点就是 [几何中位数](https://en.wikipedia.org/wiki/Geometric_median) 注意没有解析解
    - 思路0: 一种作弊的方法是直接调用 `scipy.optimize.minimize`
    - 思路1: #梯度下降
        - 注意, 我们的目标是 `f(xc,yc) = sum{ dist((xc,yc), (xi,yi)) } = sum{ sqrt((xc-xi)^2 + (yc-yi)^2) }` 这里的距离为欧氏距离.
        - 该函数为凸函数, 因此可以用梯度下降法求解局部最小值即为全局解.
        - 求梯度, `df/dxc = sum{ (xc-xi)/sqrt((xc-xi)^2 + (yc-yi)^2) }`
        - 更新公式: `xc = xc - learning_rate * df/dxc`, 对于y同样.
        - 技巧: 本题中用了 **学习率衰减** 来加快收敛. 将初始学习率设置为1并设置衰减为1e-3. 实验发现 设置得太大会导致收敛过快, 可能精度不够, 例如 1e-2; 太小则收敛过慢, 可能会超时, 例如 1e-5.
    - 思路2: #爬山 法 利用了是凸函数的性质
        - 由于我们的目标是搜索凸函数的极值, 不会出现崎岖的平面. 因此我们可以选择一定的步长分别尝试向四个坐标轴方向移动, 直到收敛.
        - 具体而言, 在每一步, 我们依次查询
        - 总结与梯度下降的区别: 1) GD由于更新方向是正确的, 每轮都发生学习率缩减; 而爬山法的方向是固定的四个备选项, 比较模糊, 何时更新step? 答案是如果每轮没有发生移动, 则缩减step (考虑与坐标轴45度角的, 较长的山脊, 若在移动过程中搜索step可能无法收敛到正确值); 2)GD的终止条件是位置变化小于eps, 而爬山的种植条件是step小于eps (当然其实也就是位置变化).
    - 思路3: #三分查找 同样利用了凸函数性质
        - 核心: 假设当前搜索范围为 [L,R], 我们取三等分点 a,b, 若 `f(a) < f(b)`, 则最小值一定不会在 [b,R] 范围内. 具体证明见官答.
        - 这样, 每次缩减 1/3 的区间, 直到收敛.
        - 注意: 本题中是二维情况, 例如可以外层循环搜索x, 内层循环搜索y.
    - [官答](https://leetcode.cn/problems/best-position-for-a-service-centre/solution/fu-wu-zhong-xin-de-zui-jia-wei-zhi-by-leetcode-sol/)

    -

### 198

T3 也是 hard, 一开始还理解错题目了...虽然本来的问题也很难就是了... T4考了AND的运算性质, 也比较少见.

- 1520. 最多的不重叠子字符串 #hard #题型 #细节
    - 给定一个字符串s, 要求返回一组不重叠子串, 其中每一个子串, 其包含的字符需要是在s中出现的全部. 要求返回的数组长度最大; 若有多个相同长度的, 则返回总长度最小的. e.g. "abbaccd" -> ["d","bb","cc"]. 注意 "abab" -> ["abab"].
    - 限制: ch均为小写; 长度 1e5
    - 思路0: 理解错题目为「给定一个字符串s, 要求返回一组不重叠子串, 其中每一个子串都包含s中全部的某一字符」. 也即 "abab" -> ["aba"].
        - 将错就错, 但也花了好久写了个 #DP
        - 对于每一个字符, 其在s中出现的位置区间是 [si,ei]. 假设我们对于其end排序.
        - 记 `f(idx,i)` 表示在 s[:idx] 中, 仅考虑前i种(根据end排序)字符, 可以得到的不重叠子串有多少.
            - 递推: `f(idx,i) = max{ f(ei-1,i-1) + 1, f(idx,i-1) }`
    - 思路1: 拓展成符合要求的子串, 然后 #贪心
        - 对于s中出现的每一个字符, 我们将其对应的区间进行拓展, 使其成为合法的子串.
            - 问题定义: 每一个字符出现的位置是一个span, 现在要对于span中包含的其他字符进行拓展. 这个问题其实很乱.
            - 答案中用了更为「暴力」的解法: 直接 `while j<=r` 遍历这一区间, 若出现新的字符则更新l,r指针. (这样复杂度似乎无法保证?)
        - 这样, 问题就转化为: 「给定一组线段, 要求得到一组数量最多的不重叠线段, 数量相同时要求长度更小」.
            - 注意, 在本题中, 线段之间不会出现部分重叠 (可能会嵌套). 因此可以用 #贪心 来放置. 具体为「右端点, 线段长度」 #双关键字排序. 见官答.
            - 除了贪心: 更为直觉的思路是, 在发生嵌套的线段中去除较长的那些线段即可, 但不如贪心直接排序好实现.
    - [官答](https://leetcode.cn/problems/maximum-number-of-non-overlapping-substrings/solution/zui-duo-de-bu-zhong-die-zi-zi-fu-chuan-by-leetcode/)
- 1521. 找到最接近目标值的函数值 #hard #math #位运算 #题型
    - 给定一个arr, 要求其子数组中, 元素 and 的结果与target的最小差值.
    - 限制: 数组长度 1e5; 元素大小 C=1e6
    - 提示: 对于 [l...r] 的and结果, 假设我们固定r, 则有结论: 1) 随着l的减小, and的结果变小; 2) 因为要求是连续的区间, 因此以r结尾的and结果数量有限, 最多为 logC 个.
    - 思路1: 维护每一个右端点可能得到的and结果集合
        - 根据提示, 可以顺序遍历上述右端点r, 用一个集合 valid 记录所有可能的and结果. 注意这一set的大小较小.
        - 转移: 对于r+1, 其和可能的l匹配的and结果只有 `{ v&num for v in valid, num }`
        - 复杂度: `O(n logC)`
        - see [official](https://leetcode.cn/problems/find-a-value-of-a-mysterious-function-closest-to-target/solution/zhao-dao-zui-jie-jin-mu-biao-zhi-de-han-shu-zhi-by/)


### 199

- 1530. 好叶子节点对的数量 #medium #边界 #题型
    - 给定一棵二叉树, 问所有叶子结点对中, 距离小于等于一定阈值的组有多少个. 限制: 节点数量 2^10, 距离限制 100
    - 思路1: 采用 #DFS, 对与每一个节点, 匹配左右孩子分别包含的叶子节点的深度.
        - 注意: 特殊情况是, 如何判断当前传入的节点是叶子?
- 1531. 压缩字符串 II #hard #DP #题型 较为复杂, 主要是代码细节较多.
    - 「行程长度编码」是对于字符串中连续(超过一次)出现的字符进行压缩表示; 现给定一个字符串以及可以删去的字符数量, 要求删去若干字符之后, 行程长度编码最小. 限制: 字符串长度 100
    - 提示: 注意, 我们对于连续的字符进行压缩表示, 对于一组 `(ck,dk)`, 我们的表示代价与数量dk的关系是: `cost = 1/2/3/4` 其中dk分别取 `[1], [2...9], [10...99], [100]`.
    - 思路1: #DP #细节
        - 记 `f(i,j)` 为前i个字符删去j个后的最小压缩长度.
        - 转移: #分类 考虑. 1) i删去, 则有 `f(i,j) = f(i-1,j-1)`; 2) 保留i, 此时我们考虑最后的那一组 `(ci,di)`, 它们是哪些坐标中的字符串呢?
            - 假设删除后保留di个相同字符 ci, 直觉可知我们保留i往前最近的di个该字符即可. 具体证明见官答. 假设从i开始往左的第di个相同字符的位置是idxi, 则需要删除 i-idxi+1-ci 个字符
            - 因此, 有转移 `f(i,j) = min{ cost(ci,di) + f(idxi-1, j-(i-idxi+1-ci)) }`
    - [官答](https://leetcode.cn/problems/string-compression-ii/solution/ya-suo-zi-fu-chuan-ii-by-leetcode-solution/)


### 200

T3也做的比较少了.

- 1536. 排布二进制网格的最少交换次数 #medium #题型 #冒泡
    - 通过相邻行交换将一个01方针变为下三角阵. 问最少交换次数. 限制: 矩阵长 200.
    - 思路0: 一开始想, 每一行对于最后0的数量有约束, 例如最后只有1个零的行只能放在最后两排. 因此对于每一行中后缀零的数量计数, 然后转为逆序. 但实际上, 最后并不需要逆序! 因为题目的要求只需要满足下三角即可.
    - 思路1: 更简单的思路是 #贪心. 从上往下来找第一个满足第i行的, 将其交换到第i行即可. (类似 #冒泡 排序). 这样, 复杂度为 O(n^2)
        - 细节: 如何找到贪心的交换行? 直接模拟冒泡排序即可, 注意下面代码的写法 (并不复杂)
        - 见 [official](https://leetcode.cn/problems/minimum-swaps-to-arrange-a-binary-grid/solution/pai-bu-er-jin-zhi-wang-ge-de-zui-shao-jiao-huan-ci/).
- 1537. 最大得分 #hard
    - 有两个严格递增的序列AB, 我们要得到一个从左到右的序列, 对于AB中共同出现的数字位置可以进行「交叉」. 路径的得分为所有元素之和, 注意相等元素只记一次, 问最大的分. 限制: 长度 1e5
    - 思路1: 最两个序列, 找到所有的交叉点, 对于每两个点之间的段落取较大值.
    - 思路2: 用两个值来记录AB序列中到目前为止的最大值. #双指针 进行遍历, 遇到交叉点的时候两个值发生交互. 如何维护双指针? 尽量保持指向的值相等. 见 [官答](https://leetcode.cn/problems/get-the-maximum-score/solution/zui-da-de-fen-by-leetcode-solution/).


## 周赛 201-249

### 201

- 1546. 和为目标值且不重叠的非空子数组的最大数目 #medium #题型 #贪心
    - 给定一个数组 (有正有负), 要求找到最多的 **不重叠子数组, 要求这些子数字的和为target**.
    - 思路1: #贪心 每次尽量考左选择数组
        - 原因: 「对于某个满足条件的子数组，如果其右端点是所有满足条件的子数组的右端点中最小的那一个，则该子数组一定会被选择」 见[官答](https://leetcode.cn/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/solution/he-wei-mu-biao-zhi-de-zui-da-shu-mu-bu-zhong-die-f/)
        - 因此, 每次在左侧子数组中尝试匹配, 利用哈希表来记录 #前缀和 即可
- 1547. 切棍子的最小成本 #hard #题型
    - 对于一个长n的棍子, 需要在m个整数点进行切割, 每次切割的代价为当前切割棍子的长度. 问最小代价.
    - 限制: n 1e6; m 100
    - 思路1: #DP 采用 #记忆化 形式
        - 记 `f(i,j)` 为ij两个割点的子段切割的最小代价. 则有 `f(i,j) = cost[i,j] + min(f(i,k) + f(k,j))`. 边界: j=i+1
        - 复杂度: 状态空间 O(m^2), 转移 m, 因此 `O(m^3)`

#### 202

T3居然没想到二分, 果然很久没遇到了...T4想得太多了, 直接intuitive+记忆化的话, 可以很快猜出来... 题解 bravo!

- 1552. 两球之间的磁力 #medium #二分
    - 一数轴上有n个位置, 求放m个球, 要求任意相邻球之间的最小距离最大化 (也即「平均放置」).
    - 限制: m,n 1e5, 位置限制 p 1e9.
    - 思路1: #二分
        - 提示: 如何检查间距x是否可以达到? 注意, 可以贪心放置: 尽量将占据的位置放在左侧. 证明: 若有另一种放置方案, 其不会优于这种.
        - 因此, 可以在O(n)的时间内检查; 搜索范围为p, 因此复杂度为 O(n logp)
- 1553. 吃掉 N 个橘子的最少天数 #hard #题型
    - 有n个橘子, 每次可以选择: 1) 吃一个; 2) 若可以被2整除, 吃1/2个; 3) 若可以被3整除, 吃2/3个. 问最少吃完的天数. 限制: n 2e9
    - 注意: 比如 n=10, 则 10-9-3-1-0 的方案要优于 10-5-4-3-1-0.
    - 思路1: 采用 #记忆化 搜索
        - 直觉: 对于一个数字, 最多进行两次-1操作, 然后进行/2或/3操作.
        - 证明: 见官答, 核心思想是, 对于-1操作和/2 (或/3操作而言), 先进行后者一定是更优的.
        - 因此, 采用 #记忆化 搜索, 对于一个数字探索 `min{ 1+x%2+f(x//2), 1+x%3+f(x//3) }`
        - 复杂度说明:
            - 注意到, 若没有记忆化操作, 则复杂度为 `T(n) = T(n/2) + T(n/3) + O(1)`; 我们设 `T(n) = O(n^t)`, 代入, 然后两边同除 `O(n^t)`, 可以算出来 `t~0.788`, 还是会超时!!
            - 然而, 事实上这里有很多重复的计算. 利用这个论述: 对于正整数, 我们有结论 `⌊⌊n/x⌋/y⌋=⌊n/(xy)⌋=⌊⌊n/y⌋/x⌋`
            - 因此, 在本问题中, 只有 `i = ⌊n / 2^x3^y⌋` 的数才会被计算, 这里x/y的数量都是对数级别的, 因子整体复杂度控制在 `O(log^2(n))` 级别!!
    - 思路2: 将上述过程建模为图上的 #最短路 问题
        - 还是思路1, 我们仅考虑其中 `i = ⌊n / 2^x3^y⌋` 的节点, 边权定义为转移成本, 例如 `x` 转移到 `x//2` 的成本为 `1+x%2`. 这样, 就变为从n到1的最短路搜索问题.
        - 细节: 图应该包含哪些节点? 我们一开始不需要预先找到所有的点, 从n开始往下搜索即可, 动态加入节点之间的边即可. 可以用 #Dijkstra 求解.
        - 复杂度: `O(log^2(n) loglogn)`, 因为边/节点的数量还是 `O(log^2(n))`, 过程中需要维护一个queue.
    - 思路3: #启发式 搜索 #题型
        - 对于思路2进行改进, 采用启发式搜索.
        - 回顾: 启发函数的 **「可接受」（admissible heuristic）** (到终点的代价估计小于真实, 乐观的) 和 **「一致」（consistent heuristic）** (任意两点间的启发距离小于真实距离).
        - 说明: 1) 若为可接受的, 则一个节点可能被拓展多次, 因为我们计算的不一定是真实的最短路径. 2) 一致性蕴含了可接受, 并且此时每个节点只会被拓展一次 (直接找到了最短路径)
        - 可以证明, 在本题中, 一个一致的启发函数为 `H(x) = ceil(x/3) + 1`, 当x=0时取值为0.
    - [官答](https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/solution/chi-diao-n-ge-ju-zi-de-zui-shao-tian-shu-by-leetco/)

### 203

- 1562. 查找大小为 M 的最新分组 #medium #题型 #并查集
    - 给定一个排列表示按照一定顺序将某些位置从0变为1. 要求记录这一过程中数字1所组成的序列的各个长度(两侧为0). 问这一序列中, 长度为m的全1序列最后出现的时刻.
    - 思路1: 采用 #并查集 来记录相邻元素的连接关系, 并记录每一个组的大小.
        - 在模拟这一排列的操作的过程中, 用一个全局 szCnt 记录当前所有组的大小计数.
- 1563. 石子游戏 V #hard
    - 有一系列的石子, A每次将其分成左右两部分, B丢弃总和较大的那部分, A得到剩余部分的分数. 然后A再次划分剩余部分... 问A能得到的最大分数.
    - 限制: 石子数量 500
    - 思路1: DP 需要用到 #前缀和
        - 记 `f(l,r)` 表示A从该子数组得到的最大分数. 边界l==r. 否则 `f(l,r) = max{ s[l:i]+f(l,i), s[j:r]+f(j:r) }` 其中i/j的划分依据是左右两则的分数和更小者.
        - 复杂度: 注意状态转移的复杂度为n, 因此总体复杂度为 `O(n^3)` 用Python写会超时! #TLE
    - 思路2: 对于上述DP过程优化 #hardhard
        - 观察上面的递推 `f(l,r) = max{ s[l:i]+f(l,i), s[j:r]+f(j:r) }`. 这里i/j的范围由约束, **取左还是右半部分的依据是左右两侧的分数和哪个更小**. 我们不妨记 `maxl(l,r) = max{ s[l:i]+f(l,i) }; maxr(l,r) = max{ s[j:r]+f(j:r) }`.
        - 这样, 假设l/r的「均衡分割点」为i0, 则 `f(l,r) = max{ maxl(l,i0)+maxr(i0+2,r) }` (这里「均衡」的定义见官答, 参见下面的代码, 还有边界条件).
        - 另外, 这里 maxl,maxr 的表达式中还包含f, 因此需要按照一定的顺序来计算. 下面双重循环中, 外层l从左到右, 内层r从右到左, 在此过程中维护分割点.
        - 复杂度: 这样f的计算就是O(1), 而分割点的维护平均也是O(1), 因此整体 `O(n^2)` [官答](https://leetcode.cn/problems/stone-game-v/solution/shi-zi-you-xi-v-by-leetcode-solution/)


### 204

两道hard的一次, 并且前面的两道题也都不简单... T3优雅的方法要计算 #割点, Orz.

- 1567. 乘积为正数的最长子数组长度 #medium #题型
    - 问一个数组中, 子数组的乘积为正数的最大长度
    - 思路0: 尝试用几个变量来记录历史位置, 但写得乌漆麻枣... 放弃
    - 思路1: #DP 用两个数组 `neg[i], pos[i]` 记录当前位置结束的正/负序列最长分别是多少
        - 转移: 1) 遇到0, 都重置; 2) 遇到正数, `pos[i] = pos[i-1]+1` 若上一个负数不为0, 则 `neg[i] = neg[i-1]+1`; 3) 遇到负数, `neg[i] = pos[i-1]+1` 若上一个负数不为0, 则 `pos[i] = neg[i-1]+1`
        - see [official](https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/solution/cheng-ji-wei-zheng-shu-de-zui-chang-zi-shu-zu-ch-3/)
- 1568. 使陆地分离的最少天数 #hard see [SCC]
- 1569. 将子数组重新排序得到同一个二叉查找树的方案数 #hard #题型
    - 给定一个元素互不相同的数组, 顺序插入可以形成一个二叉查找树. 问有多少种数组可以形成一样的二叉查找树?
    - 限制: 长度 1000; 对结果取模.
    - 思路1: #组合计数
        - 不考虑左右子树内部的方式, 假设左右子树的大小分别为 ln, rn. 对于一个节点来说, 到达顺序是无所谓的. 因此 `f[node] = comb(ln+rn, rn) * f[left]*f[right]`. 递归求解.
        - 细节: 注意到递归函数需要 (组合数, 返回包含节点数). 边界: 若node为空, 则返回 (1, 0)
        - 复杂度: 1) 这里涉及到comb的计算. 预处理递推计算的复杂度为 `O(n^2)`; 2) 建立二叉树的平均复杂度为 `O(n logn)`, 但特殊情况下为 `O(n^2)`, 及退化为链式结构; 3) 递归求解的复杂度为 `O(n)`.
    - 思路2: 可以将上面的部分都优化到 O(n) 左右
        - 首先是建树的过程: 上述讨论是对于一般的数组而言, 这里的特殊条件是数组数字构成一个排列 (离散化了). 这样, 我们可以保证对于 x 和 x+1, x-1 节点之间存在依赖关系 (根据在数组中的前后关系讨论). 这样, 我们逆序遍历数组, 并用 #并查集 来记录联通关系, 可以在 `O(n a(n))` 的时间内完成.
        - 然后是组合数的计算. 需要利用 #乘法逆元. 可的组合数计算公式 `comb(n,k) = n! / k!(n-k)! = fac[n] * facInv[k] * facInv[n-k] (mod m)`.
            - 根据 #裴蜀定理 和 #费马小定理, 这里的 `fac[i] = i! mod m; facInf[i] = (i!)^(m-2) mod m` 这样, 预处理的复杂度为 O(n logm), 对数项来自 快速乘方操作
            - 实际上可以进一步优化到 O(n), 见答案
        - [official](https://leetcode.cn/problems/number-of-ways-to-reorder-array-to-get-same-bst/solution/jiang-zi-shu-zu-zhong-xin-pai-xu-de-dao-tong-yi-2/)

### 205

- 1579. 保证图可完全遍历 #hard #题型 #并查集
    - 有一个无向图有三种类型的边, 类型1仅能由A通过, 类型2仅能由B通过, 类型3均可. 已有了一组边的情况下, 问要保障A,B均能从图上某点到达任意一点的情况下 (联通图), 最多可以删除多少条边
    - 提示: #贪心 可知, 一定尽量保留类型3的边.
    - 思路1: 从空集开始加入边; 先加入类型3的边 (作为AB公共可用的); 然而对于AB分别加入类型1/2的边.
        - 如何记录联通性? #并查集
        - 如何判断只剩下了一个联通分量? 并查集需要记录组数.

### 206

这场的四道题都很有水准

- 1582. 二进制矩阵中的特殊位置 #easy 找到一个01矩阵中, 「某个1是该行和该列中唯一的1」条件的元素数量
- 1583. 统计不开心的朋友 #medium #读题
    - 题目好难读Orz... 有偶数个人两两配对. 一个人之对其他人有偏好性排序, 对于x来说, 假如有某个匹配u, 在配对 `(x,y), (u,v)` 的情况下, 有 `x_u > x_v and u_x > u_v`, 则x是不开心的. 现给定一个匹配, 问不开心的人数.
    - 思路1: 枚举. 注意虽然存在一定的对称关系, 但令x不开心的对象u可能有多个, 因此需要分别判断. 复杂度: O(n^2)
- 1584. 连接所有点的最小费用 #medium #题型 可以有更巧妙的 #hard 解法
    - 平面上有一组点, 问将所有点都联通所需的最小距离和. 也即, 求 #最小生成树.
    - 思路1: 经典的 #Kruskal 算法. 对于所有的边排序, 从小到大遍历, 若 **当前边连接了两个联通分支**, 则将其加入.
        - 这样, 每次联通一个分支(这个分支和其他分支的最小距离)的代价是最小的, 因此最优.
        - 为了维护联通性, 用一个 #并查集 来记录.
        - 复杂度: O(n^2 logn)
    - 思路2: #Prim 算法. 一开始想到的, 但懒得实现了. 基本思路是: 随机选一个点进行初始化; 从当前树结构的相邻节点中选择代价最小的边连接, 直到构成生成树. see [here](https://leetcode.cn/problems/min-cost-to-connect-all-points/solution/prim-and-kruskal-by-yexiso-c500/)
    - 思路3: 建图优化的 Kruskal #hard
        - 基本思想是, 思路1的复杂度高是因为边过多 (全联通图). 这里利用了一个intuition将每个点连接的边的数量限制到8, 从而将复杂度降为 `O(n logn)`
        - intuition: 对于一个点x, 哪些匹配点与其的边会出现在最小生成树中? 将这个点x的四周分成8个45度角的空间, 则在每个区间中最多有一个点与x的边会出现在最小生成树中. 这是因为, 三角形的最长边不可能出现在生成树中.
        - 如何找到区间内的距离最小的点? 以P1区间内的点为力, 相较于基准点 (x,y), 该区间内的点满足 `x1>=x; y1-x1>=y-x`, 我们的目标是要找到该区间内的 x1+y1 最小值.
            - 我们按照横坐标从大到小加入, 这样之前加入的点满足第一个条件; 用树状数组记录每个点的 y+x 的最小值信息, 每次在条件二所在的范围内查询最小值. (对于y-x进行离散化操作)
            - 对于其他区间, 可以巧妙的利用 #坐标变换 转到P1中.
        - 具体见 [官答](https://leetcode.cn/problems/min-cost-to-connect-all-points/solution/lian-jie-suo-you-dian-de-zui-xiao-fei-yo-kcx7/) 太复杂了.
- 1585. 检查字符串是否可以通过排序子字符串得到另一个字符串 #hard #题型 #冒泡排序
    - 对于一个字符串, 每次可以对于某一子字符串进行排序操作. 问能否经过若干操作变为目标字符串.
    - 限制: 字符串长度 1e5; 所有元素为 0-9
    - 思路0:
        - intuition: 画出例子中从s变为t的位置变化关系. 猜测对于s中某一字符迁移到t中的某一位置, 与其发生交叉的数字都要比它大.
        - 问题变为, 如何检查「交叉」? 一开始想从s变为到t来考虑, 结果想不明白, 放弃
    - 思路1: #冒泡排序
        - 证明了题目中的操作类似冒泡排序, 并且只需要长为2的相邻元素排序即可.
        - 那么, 如何检查是否合法? 我们遍历t, 对于当前的元素, 需要s中目标位置之前的元素都比它大 (去掉之前已经用过的元素). 注意到, 题目中的字符数量仅为10, 我们用一个 defaultdict(deque) 记录每个数字出现的位置. 对于t中当前数字x, 需要判断0...x-1的剩余数字中是否有index比x的首个位置更小的. 用完了x之后 popleft 即可. 具体见 [官答](https://leetcode.cn/problems/check-if-string-is-transformable-with-substring-sort-operations/solution/jian-cha-zi-fu-chuan-shi-fou-ke-yi-tong-guo-pai-2/)
        - 复杂度: O(C n) 这里的C为字符集的大小.
    - 总结: 上面的intuition其实挺正确的. 但没有根据字符集的数量较小这一特点记录想下去, 有点可惜.

### 207

T2居然想了好久, 因为很久没有写暴力回溯的代码了吧... T3也是有趣的题型; T4可以建模为更为优雅的图问题 (带权边覆盖问题), 不过用了更为暴力的DP求解, 也写了好久久久...

- 1593. 拆分字符串使唯一子字符串的数目最大 #medium
    - 给定一个字符串, 要求拆分成若干不同的子字符串, 要求拆分数量最大. 限制: 长度 16
    - 思路1: 暴力搜索即可, 用一个全局列表/字典记录当前分割, 采用 #回溯 的方式写.
- 1594. 矩阵的最大非负积 #题型
    - 给定一个grid, 问从左上角到右下角的所有路径中, 最大的非负积是多少?
    - 提示: 应该存储的信息不是「能取到的最大正数/最小负数是多少」, 而应该是以当前点结束的路径值的范围.
    - 思路1: 用DP存储路径中的最大和最小值 (注意, 不是大于/小于零的部分).
        - 这是因为, 假设长为l-1的路径可以取到的范围 `[mn,mx]`, 若当前数值x为正, 则不管该区间范围是正是负, 新的范围总是 `[x*mn, x*mx]`, 反之亦然.
        - 见 [官答](https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/solution/ju-zhen-de-zui-da-fei-fu-ji-by-leetcode-solution/)
- 1595. 连通两组点的最小成本 #hard #interest #题型
    - 有两组点, 其中 size1>=size2. 两组点之间两两可以连接, 有不同的代价. 要求每个点至少与另一组的一个点连接. 问最小连接代价. 限制: 点数量 12
    - 提示:
        - 题目是矩阵的形式给了两组点的连接cost. 那就索性用矩阵的角度: 问题等价于从矩阵中选若干点, 要求每一行/每一列至少选择了一个.
    - 思路1: #状压
        - 采用 #DP #子集枚举 求解. 记 `f(i,mask)` 表示选择了前i行, 已选列的状压表示为mask情况下的最小代价.
            - 注意, mask更大反而有可能得到更小的解 `f(i-1, mask) > f(i-1, mask|1<<j)`.
        - 递推需要考虑两种情况
            - 情况1, 第一组中第i个点占用掉第二组中某些点: 子集枚举取最小值 `min{ sum(cost[i,sub]) + f(i-1, mask\sub) }`. 由于第i行至少要选一个, 这里的sub不为空集/全集.
            - 情况2, 第一组中第i个点和同组至少另外一个点 有共同的第二组中的邻居. 此时不发生独占, 显然前i-1个点已经是的组2中mask点都满足条件了. 因此第i个点只需要需要随便连接一个点即可 `f(i-1,mask) + min{ cost[i,subset(mask)] }`, 这里的subset直接取所有大小为1的子集即可.
        - 复杂度: 外层for循环 Om, 每一次进行子集枚举 O3^n, 对于mask计算代价需要 On, 因此总体复杂度 `O(mn 3^n)`.
        - #TLE: 一开始计算代价的 `m2cost(i,mask)` 没有 #记忆化 结果超时了.
    - 思路2: 拓展
        - 当最小带权边覆盖问题的权值均为非负数时，可以转换成最大带权匹配问题，后者有多项式时间复杂度的解法（例如 KM 算法、最小费用流等）
        - see [zero](https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/solution/kai-kai-yan-jie-zhuan-huan-cheng-zui-da-dai-quan-p/)


### 208

读题+手速 场.

### 209

两道hard的一次... T2考差了二叉树的深度, 用BFS即可, 不过还是WA了; T3之前写过了; T4事实上可以通过找规则得到DP, 但自己一开始没想明白, 实际上就是格雷码.

- 1609. 奇偶树 #medium #题型 BFS遍历二叉树
    - 给定一棵二叉树, 判断其是否满足: 从上往下分别是0,1,2...层; 偶数层数字都是奇数, 并且从左往右严格递增; 奇数层相反.
    - 思路: 利用 BFS 遍历二叉树, 判断每一层的数字是否满足条件.
- 1610. 可见点的最大数目 #hard #极角
    - 你在location有一个角度为angle的视角, 现在给定一组points, 问通过该视角最多可以看到多少点?
    - 限制: 不考虑重叠, 边界上的点可见 (若点在location则永远可见)
    - 思路1: #双指针 先计算所有点的角度, 排序, 然后用双指针来遍历.
        - 要注意: 这里的遍历过程是一个「环」而非数组, 要注意边界情况! 下面用了 `j<=n-1 and angles[j]-angles[i]<=angle` 和 `j>n-1 and 360-angles[i]+angles[j%n]<=angle` 两个条件来判断从角度i出发, j是否在其逆时针angle范围内.
        - 复杂度: 排序 O(n log(n))
    - 思路2: #二分 查找边界
        - 也是先对于角度排序, 然后对a[i] 而非查找 a[i]+angle 的边界在哪里.
        - 技巧: 对于「环」的问题, 官答中给出的技巧是将angles数组每个加360之后拼接到原数组后面, 构成一个长2n的递增数组.
        - 复杂度: 相较于双指针遍历复杂度 O(n), 对于每个位置进行二分复杂度 O(n log(n))
    - 另外, 需要注意 #极角 的计算. 利用atan计算, 注意y=0时是没有定义的; 另外atan的取值范围为180度, 需要根据x,y的正负来另外判断.
- 1611. 使整数变为 0 的最少操作次数 #hard
    - 给定一个二进制数, 可以进行两种操作: 1) 翻转最低1位的上一位; 2) 翻转最后一位. 问最少需要多少次操作才能得到0.
    - 思路1: #找规律 #DP
        - 提示: 由于两种操作都是可逆的, 因此等价于将0变为目标值n
        - 手动计算得到 1, 10, 100,... 的过程, 可知要得到这些数字分别需要 1,3,7.. = 2^x-1 步 (或者是下面的递归形式 `2*f(n>>1) + 1`)
        - 并且, 这些数字都是最高位相同的数字中最后才取到的. 例如100, 需要经过 10; 110,111,101,100 得到. 我们已知了100的步数, 怎么求110? 可知110->100 等价于100->110, 也即从0变为10.
        - 总结: 用 #记忆化 搜索的形式. 1) 若 `n.bit_count()==1` 则按照上式计算; 2) 否则, 等于 `f(1<<mxbit) - f(n-(1<<mxbit))` 这里的 `1<<mxbit` 是最高位.
        - 参见 [here](https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/solution/gen-zhao-ti-shi-zhao-gui-lu-kan-liao-bie-ren-de-ge/)
    - 思路1.1: 再给出「正向」从n变为0的 #记忆化 DP方案
        - 每次, 我们要消除最高位第i位的1, 易知需要变为 `110...0` 的形式, 也即要将此高位变为1; 而要得到上述形式, 则要将 i-2...0 都变为0, 递归问题.
        - 因此, 有递归 `f[n] = f[1^(x-1)] + f[n - 1^x] + 1` 其中第一项可以直接算出来, 第二项是递归问题.
        - 见 [here](https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/solution/hua-shan-yi-tiao-dao-wo-men-di-gui-zhao-zou-by-luc/)
    - 思路1: 本质上是 #格雷码 参见 [here](https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/solution/xiang-jie-ge-lei-ma-by-simpleson/)
        - 总结: **二进制 - 格雷码 的转换规则为**: 从二进制编码到格雷码, 对于任意位 i, 相应变为 `gray[i] = bin[i]^bin[i+1]`; 解码, 从左到右, 第一位1不变, 剩余位 `bin[i] = gray[i]^bin[i+1]` (例如 `bin(1111)=gray(1000)`)
        - 化简: 由于编码规则 `num^(num>>1)=gray`. 也即 `decode(gray)^((decode(gray)>>1)=gray`, 因此有 `decode(gray)=gray^((decode(gray)>>1)`. 而根据解码规则, 显然右移操作和解码操作可交换

### 210

T4是很少见的 #遍历子树 的题目, 有点难Orz.

- 1617. 统计子树中城市之间最大距离 #hard #题型 #树
    - n个城市之间的联通关系恰好构成一棵树. 要求返回这棵树的子树中, 节点之间最大距离(直径)分别为 1...n-1 的数量.
    - 限制 n<=15
    - 思路1: 子集遍历, 对于每一个子集检查是否为子树及其直径.
        - 复杂度: 2^n * n
        - 如何 **查询一棵树上的直径**? 采用 #树形 DP
            - 任取一个点作为root, 在遍历孩子的过程中记录经过这个点的 `max_depth, max_dist`. 采用递归的形式计算. 假设当前值为 `max_depth, max_dist`, 遍历下一个孩子节点返回了 `mdepth, mdist`, 进行更新: `max_depth = max(max_depth, mdepth+1), max_dist = max(max_dist, mdist, max_depth+mdepth+1)`.
    - 思路2: 与其用上面的形式来找所有可能的子集/树, 我们一开始就固定树的结构 (单向图). 然后, 对于每一个树节点, 我们统计 **经过该节点的子树的所有统计结果(子问题)**. 注意到, 因为我们一开始固定了树结构, 所以不会产生重复计数, 所以答案就是子问题之和.
        - 如何在上面的 #树形 DP 的框架下实现结果的统计? 用 `count{dist:cnt}` 表示当前遍历中的结果, `subcount` 表示下一个孩子节点的统计结果, 对于这两个结果进行交叉即可.
        - [here](https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/solution/python3-shu-xing-dp-by-simpleson/)

### 211

居然被T2折磨了半天, 事实证明是自己想多了, 直接暴力也可以过 (没想明白状态空间); T3之前应该做过类似的 #双指标 排序的题, 结果这次还是疯狂打补丁剑走偏锋, 还是没想明白.

- 1625. 执行操作后字典序最小的字符串 #meduim #interest 放在了第二题, 但很有意思.
    - 给定一个长度为偶数字符串s, 每个字符为0...9, 可以进行任意次数的两个操作: 1) 对于所有奇数元素+a (保留个位数); 2) 将s向右 #轮转 b长度. 要求可能得到的最小字典序结果.
    - 限制: 长度 100
    - 提示: 显然可以将原数组元素 按照奇偶性分成两组. 然后操作1仅对于某一组生效.
        - 另外, 注意数组长度n和可轮转步长b决定了哪些位置的元素可以被放在首位.
        - 由于字符串长为偶数, 若b也为偶数, 则两个组的奇偶性将永远不变, 操作1仅能对于奇数组操作; 否则, 两数组都可进行操作性.
    - 思路1: 遍历所有可放在首位的元素, 分别对于两组进行取最小值操作.
        - 具体而言, 可以轮转到首位的元素集合为idxSet, 然后对于所有可能的位置, 可以从该位置分成两组 arr1, arr2 (根据 `[arr[(sidx+i)%n] for i in range(0/1,n,2)]` 划分). 然后分别对两子序列利用操作1取最小值 (注意当b为偶数时, arr1无法进行此操作). 这样就可以得到以sidx开头的最小字典序.
        - 复杂度: idxSet 大小最大 n, 利用操作1取最小的复杂度为 `O(10*n)`, 因此总的复杂度为 `O(10*n^2)`
    - 思路2: #暴力 美学, 直接DFS找到所有可能的结果
        - 实际上, 本题所有可能的结果只有 O(n * 10^2) 种, 第一项为以某元素开始, 第二项为所有可能的序列. 因此直接暴力DFS即可.
- 1626. 无矛盾的最佳球队 #medium #题型
    - 有一组球员 (score, age), 若两名球员中, 年龄较小的那个分数较大, 则产生矛盾. 要求在所有球员中组成分数和最大的球队.
    - 限制: n 1e3; age 1e3; score 1e6.
    - 思路1: 将年龄和分数连续化. 然后按照年龄进行排序.
        - 记 f(a,s) 表示由年龄最大为a的球员, 分数最大为s组成的无冲突球队的最大分数.
        - 错误记录: 一开始遍历所有球员, 但这样有问题, 因为有些 f(a,s) 可能为空.
        - 补丁: 稠密遍历年龄和分数. 则有 `f(a,s) = max(f(a',s') + s*multi)`, 其中multi是分数为s并且年龄为a的球员数量. 这里的遍历对象满足 `a' <= a, s' <= s`, 也即整个矩阵的最大值.
        - 下面的实现改成了一维DP进行压缩.
        - 复杂度: 理论上也是 O(n^2), 但要比下面的慢很多.
    - 思路2: #双指标 排序
        - 直接对于球员按照 (age,score) 二级排序. #DP 定义为 `f(i)` 表示以第i个球员为终点的最大分数和. 这样, 可以 **保证第i个球员为此组中的分数最大值**.
        - 则有更新 `f(i) = max{ f(j) + score[i] }` 这里的j满足 `j<i and score[j] <= score[i]`. 由于相同年龄的球员按照分数排序, 因此不会有少记录的情况.
        - 复杂度: O(n^2)
- 1627. 带阈值的图连通性 #hard
    - 有编号为 1...n 的节点. 两个节点相连的条件为, x,y 的gcd大于阈值. 对于每一个查询, 返回两点是否相连.
    - 思路1: 查询联通性采用 #并查集. 由于节点编号有序, 对于 g in threshold...n, 每次遍历 range(g, n+1, g) 这些节点, 将其相连. 这样的复杂度为 #调和级数 `n+n/2+n/3... = O(n logn)`.

### 212

T4 因为一个粗心导致了复杂度爆表, 耐下心打了两个补丁居然过了. 在乱写之前还是要注意复杂度, 值得反思.

- 1631. 最小体力消耗路径 见「并查集」
- 1632. 矩阵转换后的秩 #hard #反思
    - 输出矩阵中所有位置元素对应的秩. 秩的定义为: 从1开始, 尽可能小, 同行/同列的两元素p,q, 若 `p<q` 则 `rank(p)<rank(q)`.
    - 限制: 矩阵 500*500
    - 思路0: 对于所有元素排序, 从小到大确定秩. 遍历过程中维护行/列约束. #TLE 补救回来了
        - 补丁: 注意这样有问题: **相同值的关联元素之间存在依赖关系**. 例如同行的两个相同元素 (i,j) 但是两个位置在列上的rank不同, 则两个元素的秩应该都取较大的那个rank.
            - 因此, 对于同值元素根据依赖关系「分组」, 同组元素的rank取最大值. 如何分组? 根据行列依赖, 构建 #并查集 来记录.
        - 补丁1: 结果TLE了, 这里的原因在于, 一开始分组(连边)的时候, 我通过遍历所有行/列来找到找到连接关系, 这样复杂度就是 `((m+n) * |nodes|) = O((m+n) * (mn))` 超时.
            - 参考 [here](https://leetcode.cn/problems/rank-transform-of-a-matrix/solution/python-bing-cha-ji-tuo-bu-pai-xu-by-qin-lv6kx/) 同更为简单的方式分组: 建立 `row2idx, col2idx` 记录该行/列的第一个值为x的点, 对于同值点 (r,c) 只需要与该点连接即可.
        - 这样, 时间复杂度 O(mn logmn) 就是排序时间.
    - 思路1: 总结一些上面记录, 补充更 #优雅 的一份代码. 总体就是用了 并查集 + 拓扑排序
        - 重新来看这一问题, 每个元素仅依赖于同行/列中的次小元素 (和同值元素), 若没有同值元素就是简单的 #拓扑排序. 特殊情况是, 同值元素所带来的依赖关系, **具有依赖关系的同值元素可以作为一个节点**, 我们用 #并查集 来记录组关系.


### 213

四道题都挺有意思的, T4居然真的应该用排列数来求解, 和「0060. 第k个排列」还不太一样, 果然应该勇敢想一想.

- 1640. 能否连接形成数组 #easy
    - 能否将一个数组列表通过一定的顺序拼接为另一个数组. 已知数组中元素各不相同
- 1641. 统计字典序元音字符串的数目 #medium
    - 计算长度为n并且仅由aeiou组成并且其中字符出现顺序按照字典序排列的字符串的数目.
    - 提示: 从5个元音字母只选择k个字母, 按照特定顺序排列的方式有 `comb(5, k)` 种. 这k个字符组成长度为n的字符串, 显然, 第一个字母是固定的, 其他的k-1的字符第一次出现的位置可以在剩余slot上选择, 方式有 `comb(n-1, k-1)` 种.
- 1642. 可以到达的最远建筑 #medium
    - 有一排房子, 你要利用一定数量的「砖块」和「梯子」到达尽可能最远. 若 `h[i+1]<=h[i]` 可以直接过. 否则, 可以选择使用一架梯子或者 `h[i+1]-h[i]` 块砖块.
    - 思路: #贪心 将l个梯子用在高度差最大的位置上. 为此, 遍历过程中, 优先用梯子, 用最小堆保存. 然后遇到更大的高度差时, 将堆中最小的换成砖块.
- 1643. 第 K 条最小指令 #hard
    - 需要从(0,0)到达(row, column), 最短路径可以由长度为 row+column 的 `HV` 指令构成 (向右/向下). 问所有指令中字典序第k小的指令.
    - 问题等价于, 给定一定数量的0/1, 问他们构成的长为n的序列中第k小的.
    - 限制: n<=15
    - 思路0: #组合 计数.
        - 考虑最高位在某一位置时, 可以有多少种序列. 例如, 有2个1的情况下, 从小到大依次为 11; 101,110; 1001,1010,1100;... 可见, 对于长度为l的包含x个1的序列, 一共有 `comb(l-1, x-1)` 种.
        - 因此, 递归求解 `f(x, k)` 来求 **包括x个1的第k小元素中, 序列的最高位**. 为此, 用一个acc记录用长为 l=1,2,3... 的序列可构成的包含x个1的序列的个数, 当首次出现 `acc >= k` 时, 说明第k大的元素长度为l, 然后递归 `f(x-1, k-acc)`. 边界: x=0.
    - 思路1: 优先确定高位 + 组合计数
        - 上面的解法比较直观, 但不太「优雅」. 实际上, 我们可以直接从最高位往下填: 对于idx位, 我们要求包含x个1的第k小的元素, 假设填0则剩余元素最多有 `o = comb(x-1,k-1)` 种可能. 因此我们每次比较 o,k 的大小关系即可: 若 `o>=k` 则在idx位填0否则填1.
        - from [zero](https://leetcode.cn/problems/kth-smallest-instructions/solution/di-k-tiao-zui-xiao-zhi-ling-by-zerotrac2/)
        - 复杂度: `O((h+v) * h)` 因为序列长度为 `h+v`, 而计算 `comb(x,h)` 的复杂度 h. 我们可以通过递推式 `c[n][k]=c[n-1][k-1]+c[n-1][k]` 求解组合数.
    - 关联: 0060. 第k个排列

### 214

- 1649. 通过指令创建有序数组 #hard
    - 需要一个DS满足: 1. 添加一个元素x; 2. 给定元素x查询DS中在 [1...x-1] 范围的数量; 3. 查询 [x+1...UB] 范围的数量. 见 [zero](https://leetcode.cn/problems/create-sorted-array-through-instructions/solution/tong-guo-zhi-ling-chuang-jian-you-xu-shu-zu-by-zer/)
    - 因此, 可以通过 **线段树、树状数组、平衡树** 等方式来解决.
    - 思路1: 直接调用了 SortedList.
    - 关联: 「0327. 区间和的个数」


### 215

T3有意思; T4对于一个很常见的问题建模, 但实际上却是复杂度爆炸. 抄了一个很复杂的DP, 算是学习学习思路吧.

- 1658. 将 x 减到 0 的最小操作数 #medium #题型
    - 给定一个整数x, 可以从数组两端选择数组, 求两端之和为x的最小数字数量.
    - 提示: 可以等价转换为, 求和为 `sum-x` 的子数组
    - 思路1: 简单起见, 计算acc之后每次 #二分 搜索对应的差值. 复杂度 O(n logn)
    - 思路2: 可以 #双指针 从两侧计算, 也可以利用提示 #滑动窗口. 复杂度 O(n)
- 1659. 最大化网格幸福感 #hard 非常复杂的DP, 不必掌握
    - 给一个 (m,n) 网格, 有 in,ex 个内向/外向的人可选择. score定义为: 内向的人初始120, 每一个邻居-30; 外向的人初始40, 每一个邻居+20. 不必填入所有人, 要求 score最大.
    - 限制: m,n [1,5]; in,ex [0,6]
    - 思路1: 暴力按行 #DP, 用 #预处理 进行加速. DP转移需要用 #记忆化 搜索求解.
        - 数量级较小, 考虑采用 #状压 进行记录. 0/1/2 分别记录三种情况.
        - 记 `f(maskB,row, inL,exL)` 表示当前row行, 上一行为maskB, 内外向剩余人数分别为 inL,exL 时的最大score. 则有转移 `f(maskB,row, inL,exL) = max_mask{ f(mask,row+1, inL-cntIn,exL-cntIn) + score_inner(mask) + score_outer(mask, maskB) }`
            - 其中 cntIn, cntIn 为当前mask中内外向人的数量; `score_inner, score_outer` 分别计算当前行的分数, 以及相邻行的分数.
        - 复杂度: 状态数 `3^n*n*6*6`, 每次转移 `3^n`, 因此总时间复杂度 `O(3^2n *n *6*6)`
        - see [zero](https://leetcode.cn/problems/maximize-grid-happiness/solution/zui-da-hua-wang-ge-xing-fu-gan-by-zerotrac2/)
    - 思路2: 拓展解法, 叫做 #轮廓线动态规划 见zero


### 216

题型都比较新颖. 难度都不大, 但T3写的很脏, T4的理论证明比较难.

- 1663. 具有给定数值的最小字符串 #medium #题型
    - 16个字母分别赋值 1...26, 现在要求构造长为n所有值之和为k的最小字符串.
    - 思路: 先全填a, 然后从后往前尽量变为z
- 1664. 生成平衡数组的方案数 #medium #题型
    - 给定一个数组, 可以删除任意idx位置的元素. 问删除之后, 奇偶位置元素和相等的情况数. (注意右侧的奇偶性发生了变化)
    - 思路1: 分别暴力求出奇偶位置的前缀和, 然后翻转位置i后面的奇偶性来验证.
    - 思路2: 采用 #交替 #前缀和
        - 注意, **交易前缀和天然可以记录奇偶位置元素和的差值**.
        - 这样, 对于索引i, `dp[i-1]` 表示左边奇偶元素的差值, `dp[n]-dp[i]` 表示右边奇偶元素的差值. **去除位置i之后, 右边元素的奇偶性翻转, 因此 `dp[n]-dp[i]` 恰好表示右边奇偶元素的差值的相反数**. 因此, 判断条件为 `dp[i-1]==dp[n]-dp[i]`.
        - [here](https://leetcode.cn/problems/ways-to-make-a-fair-array/solution/shuang-bai-zheng-fu-jiao-ti-qian-zhui-he-by-letian/)
- 1665. 完成所有任务的最少初始能量 #hard 但实际上不难
    - 每一项任务 (actual, minimum) 需要在有至少minimum点能量的情况下才能做, 但实际消耗actual. 现给定一组任务, 问开始需要的最少能量.
    - 思路1: 排序之后 #贪心
        - 注意到, 若没有minimum的限制, 则答案就是actual之和. 因为有了两者的差值, 导致最后可能剩余一些能量. 因为实际消耗的能量就是 `sum(actual)` 因此实际上产生影响的就是 `minimum-actual`. 直接对于该差值从大到小排序, 累积每次需要增加的能量即可.
    - 思路2: 理论的不等式推导见 [zero](https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/solution/wan-cheng-suo-you-ren-wu-de-zui-shao-chu-shi-neng-/)

### 217

T3要求记录区间, 应该直接想到差分数组的... T4的思路也很难想到, 官答中转化为滑动窗口的想法也很赞!

- 1673. 找出最具竞争力的子序列 #medium #题型
    - 从长度为k的子序列中找到字典序最小的.
    - 思路: 采用 #最小堆. 如何保证最后剩余的堆大小至少为k? 对于长n的给定序列, 位置i往后的长度为n-i, 因此堆剩余的大小至少为 `k-(n-i)`
- 1674. 使数组互补的最少操作次数 #medium #题型 #差分数组
    - 给定一个长为偶数的数组, 每次操作可以使得任一数字变为 [1...limit] 中的一个数, 要求最少操作, 使得对称元素之和都是同一个数. 这里有一个重要限制是数组内的所有元素都 <= limit.
    - 限制: n,limit 1e5
    - 提示
        - 考虑可取值的范围, 目标值在 [2...2*limit] 区间内.
        - 而对于一组数 (a,b) 而言, **最多修改2次**. 什么情况下可以减少修改次数? 可知在 [mn+1...mx+limit] 范围内只需修改一次, 其中特殊点 sum(a,b) 则不需要修改.
    - 思路1: 利用 #差分数组 来记录区间信息
        - 根据提示, 我们可以暴力遍历所有可取范围, 但检查数对是否可行, 总体复杂度为 O(limit * n) 会超时.
        - 因此, 用差分数组来记录区间信息. 简单起见对于每组数字我们仅考虑 `[mn+1...mx+limit]` 这里范围, 并用 cnt 来记录不需要修改次数 (最多反向减一下即可).
        - 这样, 差分数组累加结果acc记录了该范围内只需要进行一次(或零次)修改即可的数组数量, 而其他数组的修改次数需要为2次. 因此, 答案就是 `[n] - acc - cnt` 的最小值. 第一项是默认全部数组修改2次, 第二项减去只需要修改一次的部分, 第三项减去不需要修改的数组.
        - 见 [zero](https://leetcode.cn/problems/minimum-moves-to-make-array-complementary/solution/shi-shu-zu-hu-bu-de-zui-shao-cao-zuo-ci-shu-by-zer/)
    - 总结: 转弯有点多, 想到差分数组是关键.
- 1675. 数组的最小偏移量 #hard
    - 数组的「偏移量」定义为其两个元素的最大差值. 现给定一个数组, 可以对其中的元素进行操作: 若为偶数可以/2, 对于奇数可以*2. 要求最少偏移量.
    - 限制: 数组长度 5e4, 元素大小 1e9
    - 思路1: 注意奇数最多只能 `*2` 一次, 但偶数可能可以多次`/2`. 先将所有所有奇数 `*2` 转为全偶数的情况. 然后用 #有序数组 来维护, 每次的差值为 mx-mn, 然后对于最大值/2放回数组. 注意若最大值为奇数, 其不可能变小了, 终止!
        - 复杂度: O(n logMAX)
        - see [zero](https://leetcode.cn/problems/minimize-deviation-in-array/solution/shu-zu-de-zui-xiao-pian-yi-liang-by-zerotrac2/)
    - 关联: 「0632. 最小区间」

关联

- 0632. 最小区间 #hard
    - 给定k个递增数组, 要求一个最小的区间, 满足对于数组至少包含其中一个元素. 「最小区间」的定义: 范围最小, 范围相等的话数字较小.
    - 限制: 数组数量 k 3500, 数组长度 n 50, 元素范围 [-1e5, 1e5]
    - 思路1: 维护一个 #有序数组 sl, 包含k个数组中的当前最大元素, 答案维护sl的最大差值.
        - 优化: 这里用到了高级的有序数组, 是否有更为简单的DS? [官答](https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/solution/zui-xiao-qu-jian-by-leetcode-solution/) 从小到大遍历, 维护当前关注的一个 #最小堆, 只用一个maxValue记录当前的最大值. DS更简单.
        - 复杂度: `O(nk logk)`, 所有数字的数量为 nk, 每次堆操作 logk.
    - 思路2: 记所有元素的范围为 [mn,mx], 我们在这一范围内 #滑动窗口 来解决, 参见「0076. 最小覆盖子串」.
        - 具体而言, 用一个cnt记录当前窗口内的数字所覆盖的数组 (辅助哈希表 `{num:arrsContaining[]}` 每个数字所出现的递增数组). 在滑动窗口的过程中检查是否包含所有递增数组.
        - 复杂度: `O(nk + |V|)`, 前者是滑动窗口时所有数字只会用到2次, 后者是数组数值范围.
    - 关联: 1675. 数组的最小偏移量

### 218

- 1680. 连接连续二进制数字 #medium
    - 技巧: 如何判断是2的整数次幂?
        - 一种方式是计算 `i & (i-1) == 0`, 参见 [zero](https://leetcode.cn/problems/concatenation-of-consecutive-binary-numbers/solution/lian-jie-lian-xu-er-jin-zhi-shu-zi-by-ze-t40j/)
- 1681. 最小不兼容性 #hard
    - 将数组nums分成 **大小相等的** k组, 要求每组的数字都不相同. score定义为所有组最大最小差值的和, 要求score最小.
    - 限制: 数组长度 n 16
    - 思路0: 没有看到分组大小相同的限制, #error 记录
        - 记 `f(i,mask)` 表示将mask分成前i个组, 当前score最小值. 则有递归 `f(i,mask) = min{ f(i-1,sub) + s(mask\sub) }` 其中sub为所有符合条件的子集.
        - 子集遍历: `sub = {mask & (sub-1)}`
        - 复杂度: O(k 3^n) 这样显然会超时
    - 思路1: #状压 #子集遍历
        - 事实上, 于之前遍历子数组不同的是, 这里限制了分组大小相同, 因此仅需要遍历所有符合条件的分组即可.
        - 如何做? 每组大小为size, 则我们可以遍历所有大小为size的整数倍的组. 则递推公式 `f[mask] = min{ f[mask\sub] + s(sub) }` 其中mask的大小为size整数倍, sub为所有大小为k的mask的子集.
        - see [zero](https://leetcode.cn/problems/minimum-incompatibility/solution/zui-xiao-bu-jian-rong-xing-by-zerotrac2-rwje/)
        - 在具体的实现上, 还可以直接通过 #DFS 来解决, see [here](https://leetcode.cn/problems/minimum-incompatibility/solution/python-zhuang-ya-dfs-by-qin-qi-shu-hua-2-lwff/)

### 219

- 1690. 石子游戏 VII #medium
    - 有一排石子表示不同的分数, AB轮流选择从左右两侧取石子, 得到的分数为剩余石子的分数之和. 可知A总会获胜. 会两者都在最优决策下分数差值.
    - 提示: AB两人是「对称」的, 因此对于 stones[i...j], 我们可以用 f[i,j] 表示最优分数即可
    - 思路1: 推导分数递归关系, 采用 #DP
        - 根据上述f的定义, 考虑递推式: `f[i,j] = max{ s[i,j-1] - f[i,j-1], s[i+1,j] - f[i+1,j] }` 分表表示取左右石子的情况. 边界: i==j 时分数为0.
        - 复杂度: O(n^2)
- 1691. 堆叠长方体的最大高度 #hard
    - 有一组长方体 `(w,l,h)` 要进行堆叠. 当i的三个长度都小于j时, 可以将其叠在上面. 问最大堆叠高度. 长方体可以旋转.
    - 限制: 数量 100.
    - 提示: 根据提示可以推测, 最优的方案时把高度为度用最长的一组. 证明: 假设有一种最优排列每个块表示为 `(wi,li,hi)`, 我们对于这些纬度按照从小到大顺序重排列得到 `(wi',lj',hi')`, 可以证明对于任意的 i,j, 重排列后的三元组仍然符合要求. 而重排列之后的高度显然不会减少.
        - 核心证明: 对于任意一组 `(wi,li,hi)<(wj,lj,hj)` 都可以证明重排列之后也是成立的. 任取一种情况, 不妨假设i的内部顺序为 `hi<wi<li`, j的顺序为 `lj<hj<wj`. 则重排列之后, `hi<li<lj, wi<li <lj<hj, li<lj<wj`. 因此调换之后的三元组也成立
    - 思路1: 根据上述提示, 可以确定长方体的方向. 然后 #DP 来求 f[i] 表示第i个长方体作为底的最大高度
        - 则有递推关系 `f[i] = max{ f[j] } + hi` 其中j是所有满足可堆叠条件 `(wi,li,hi)>(wj,lj,hj)` 的长方体.
        - 如何保证顺序? 可以对于 (w,l,h) 进行排序. 也可以 (w+l,h) 等. 只需要「保证枚举关系的拓扑性即可」.
        - 见 [zero](https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/solution/dui-die-chang-fang-ti-de-zui-da-gao-du-b-qzgy/)

### 220

中规中矩, 难度不大.

- 1695. 删除子数组的最大得分 #medium #题型
    - 给定一个数组, 求其 (连续) 子数组中, 和最大值.
    - 思路: #双指针.
- 1696. 跳跃游戏 VI #medium
    - 从左到右, 每次最多跳k步, 每个位置有一定分数, 要求最大分数.
    - 限制: 长度, k 1e5
    - 思路1:
        - 注意到, 直接使用DP的复杂度不够的. 而由于可调到某一位置的必然是前面的k个位置, 每次取其中最大的即可.
        - 为此, 用一个 #最大堆 来维护 (score, idx) 信息, 后者用来判断是否可达
- 1697. 检查边长度限制的路径是否存在 #hard
    - 一张图, 节点之间可能有多跳权重不等的边. 给一组查询 (p,q,limit) 判断两点之间是否有一条权重都严格小于limit的路径.
    - 限制: 节点, 边数量 1e5; 查询数量 1e5
    - 思路: 利用 #并查集 表示连通性, 对于权重排序, 根据查询的限制逐步加边.

### 221

T3, T4 都是做过的... T2也TLE了一回... 质量很高的一期.

- 1705. 吃苹果的最大数目 #medium #题型
    - 有一棵苹果树, 第i天长出 apples[i] 个苹果, 它们在 days[i] 后腐烂. 你每天最多吃一个, 问最多能吃几颗.
    - 限制: 天数i 2e4, 苹果和腐烂天数 2e4
    - 思路0: 暴力 #TLE
        - 一开始的贪心策略是, 从后往前遍历, 对于每一颗苹果, 尽量在最晚的时间吃. 但这样的复杂度为 O(n^2), 超时了.
    - 思路1: 也是 #贪心, 用一个 #最小堆 记录所有苹果的腐烂日期, 每次选择腐烂日期最近的苹果吃 (数量 -1)
        - 堆元素: `(day, cnt)`. 注意需要分n天之内树上长苹果, 和n天之外剩余的苹果两部分.
- 1706. 球会落何处
    - 用一个grid表示该位置挡板的方向 (`/\`), 从最上边的每一个位置放小球, 返回小球最后落在的位置, 若无法掉出来 (挡板呈现V字形) 则返回 -1.
    - 提示: 注意球无法掉下来的条件: 1) 出现V字形或者 2) 到达边界无法再往边界方向.
        - 参见 daily2202 写的js版本
- 1707. 与数组中元素的最大异或值 #hard #字典树
    - 参见 trie, 这里自己重新写一遍
    - 思路: 离线查询. 根据查询动态插入字典树

### 222

又是质量很高的一次周赛. T3的二分边界问题搞了好久好久... T4的等价转换太赞了!

- 1712. 将数组分成三个子数组的方案数 #medium #题型 #反思
    - 要将一个数组分成三部分, 使得三部分的和依次满足 a<=b<=c, 求分割数.
    - 思路: 利用 #前缀和 加速, 用 #二分 搜索.
        - 假设数组和为 s, 给定a, 则a+b需要满足 2*a<=a+b<=(s+a)/2
        - 注意: #debug 这里需要明确左右边界. 假设数组分成 [0...l], [l+1...m], [m...n-1] 三部分, 都要求非空.
            - 则在遍历数组的过程中 (左部分 l), 我们查询的 **中间部分的 m指针的搜索范围为 `[l+1...n-2]`**
        - 参见 [灵神](https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/solution/golang-jian-ji-xie-fa-by-endlesscheng-xaad/)
    - 总结: 推导很简单, 但实际上 #边界 分析搞了半天. 值得 #反思
- 1713. 得到子序列的最少操作次数 #hard #转化 #题型
    - 问题等价于, 找到 s,t 两数组之间的最长公共子序列. 注意原本s中的所有整数互不相同.
    - 限制: 两者长度 1e5
    - 思路0: 计算 #最长公共子序列 的基本方案是 DP, 但这里的复杂度不够.
    - 思路1: 利用这里某一「序列s中的元素互不相同」的性质, 可以将s中的元素值重新赋值为 0,1,2..., 然后t序列替换为这些重标的值. 则, 问题等价于在t中找到最长递增子序列.
        - 解法: 用一个数组 dp[i] 记录长度为i的子序列的结尾最小数字. 在遍历t的过程中, 若元素大于 dp[-1] 则拓展, 否则二分查找, 更新最小数字. 复杂度: `O(n logn)`
        - 参见 「0300. 最长递增子序列」, 见 [官答](https://leetcode.cn/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/)
        - [本题官答](https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/solution/de-dao-zi-xu-lie-de-zui-shao-cao-zuo-ci-hefgl/)

### 223

前三题做起来还可以, T4之前做了5289, 但重新看到居然还是没有思路... 另外对于Python时间卡得有些过分了, 还好看到灵神的题解, 学到了一些优化方法 (虽然具体工作中可能没啥用...)

- 1723. 完成所有工作的最短时间 #hard #题型 #Python #优化
    - 给定一组数组, 要求分成k组, 使得组内的数字之和的最大值最小化
    - 限制: k, 数组长度 <=12
    - 思路1: 同「5289. 公平分发饼干」, 但时间要求更为苛刻. 采用 #子集遍历 #状态压缩 #DP
        - `f[i][mask]` 表示给前i个工人分配, 并且已分配的工作是mask情况下的最优值.
        - 递推: `f[i+1][mask] = min{ max{sum(sub), f[i][mask\sub]} }` 也即经典的子集遍历问题 (可以通过 `sub = (sub-1)&mask` 来实现).
        - 复杂度: 子集遍历的复杂度为 O(3^n), 因此总复杂度为 O(n 3^n)
        - 思路是这样的, 但此题卡时间非常紧, 下面来说 [灵神](https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/solution/by-endlesscheng-d2oa/) 的优化
    - 优化: 1) 首先, 相较于 `sub = (sub-1)&mask` 的子集遍历方式, 在全局预计算好每一个mask的所有子集形式; 2) 把 `min` 和 `max` 拆开，改为手写，避免额外的函数调用开销
    - 思路2: #二分 查找 + #回溯 + #剪枝
        - 对于一个数字, 通过DFS来判定是否可行. 但暴力回溯的复杂度高达 O(k^n), 因此采取了一系列的剪枝策略.
            - 优先分配工作量大的工作. 因为「更容易」找到解.
            - 顺序给工人分配. 因为工人之间没有差异.
            - 在遍历过程中, 假如任务i分配给j恰好使得j的工作量达到limit (没有浪费), 若递归函数还返回了false, 则可以直接返回false不必继续遍历.
        - 参见 [官答](https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/solution/wan-cheng-suo-you-gong-zuo-de-zui-duan-s-hrhu/)

### 224

这次的难度好高! 猫和老鼠只有22个人[做出来](https://leetcode.cn/contest/weekly-contest-224/ranking/). T3也很有意思, 关联两道相关题.

- 1727. 重新排列后的最大子矩阵 #medium #题型
    - 有一个0/1矩阵, 可以对于列进行重排列. 问可能得到的全为1的最大矩阵的大小. 见[图](https://leetcode.cn/problems/largest-submatrix-with-rearrangements/)
    - 限制: 矩阵面积 1e5
    - 关联: 0085. 最大矩形
    - 提示: 这里每一列不变, 可以参考0085进行预处理: 对于某列的i位置, 计算「以其结尾的连续1的长度」.
    - 思路1: #预处理 之后, 排序统计
        - 相较于0085, 这里可以对列进行重排列. 因此, 对于每一个行指标i, 我们可以对预处理的结果进行排序. 自然得到最大的合法矩阵.
- 1728. 猫和老鼠 II 见博弈论

关联

- 0084. 柱状图中最大的矩形 #hard #题型
    - 给定一组数表示一系列柱子的高度, 求其中包含的最大矩形的面积.
    - 限制: 数组长度 1e5
    - 思路1: 采用 #单调栈 来保留每一个柱子作为最大高度可以构成的矩形的底边长度.
        - 具体而言, 维护一个单调栈, 当栈顶元素被pop出来时, 说明 (stack[-2], i) 范围内的柱子都大于栈顶元素的高度, 可以构成面积 `stack[-1] * (i - stack[-2] - 1)` 的矩形.
- 0085. 最大矩形 #hard #题型 #interest
    - 给定一个0/1矩阵, 问其中全1构成的最大矩形的面积. 限制: 长宽 200 [图](https://leetcode.cn/problems/maximal-rectangle/)
    - 提示: 先进行预处理, 对于每一个位置, 记录 **该行中以它结尾的连续1的长度** (0位置对应的数量就是0). 这样, 对于每一列, 就转换成 0084 题.
    - 思路1: 按照上述思路将其转为 0084
        - 说明: 如何想到等价转换? 按照官答的思路, 我们枚举以 (i,j) 点作为右下角的所有矩阵, 这样判断的方式就可以通过上述预处理机制来实现. 从而得到等价转换.
        - 见 [官答](https://leetcode.cn/problems/maximal-rectangle/solution/zui-da-ju-xing-by-leetcode-solution-bjlu/)

### 225

- 1736. 替换隐藏数字得到的最晚时间 #easy #题型
    - 给定一个字符串表示时间, 其中一些位用 `?` 表示未知, 问填充得到最大的时间.
    - 思路1: 纯粹基于规则.
        - [官答](https://leetcode.cn/problems/latest-time-by-replacing-hidden-digits/solution/ti-huan-yin-cang-shu-zi-de-dao-de-zui-wa-0s7r/) 中的逻辑更清楚一点.
- 1737. 满足三条件之一需改变的最少字符数 #medium
    - 给定两个字符串, 每次操作可以修改其中的任一字符为小写字母. 问得到以下三种状态之一, 最少步数. 条件: a的每个字母严格小于b的任意字母; 或者b的每个字母严格大于a的任意字母; 或者a和b都由同一个字母构成.
    - 思路1: #计数, 然后考虑每一种情况.
        - debug: 原本直接 [a,z] 遍历了, 但有问题. 因为是 **严格小于关系**, 因此遍历分割字符x的过程中, 要求一个字符串都小于等于x, 另一个都大于x; 因此, 这里的x的实际范围是 `[a,z)`
- 1738. 找出第 K 大的异或坐标值 #medium #题型
    - 对于一个二维矩阵, 对于每一个 (a,b) 坐标计算的score为, 以 (0,0)和(a,b) 两点确定的矩阵的所有值的异或. 求这些分数中第 K 大的值.
    - 思路1: 采用二维 #前缀和 来存储每个位置的score.
        - 需要注意这里前缀和的计算方式: `pre(i,j)=pre(i-1,j) ^ pre(i,j-1) ^ pre(i-1,j-1) ^ matrix(i,j)`. 利用了 x^x=0 这一性质.
        - 然后要返回第K大的元素, 参见「0215. 数组中的第K个最大元素」.
        - [官答](https://leetcode.cn/problems/find-kth-largest-xor-coordinate-value/solution/zhao-chu-di-k-da-de-yi-huo-zuo-biao-zhi-mgick/)
- 1739. 放置盒子 #hard #interest #题型
    - 在一个房间放置n个正方体盒子. 只有当底部盒子的四个侧面都是墙壁/其他盒子的情况下, 才能在上面堆叠了. 问最少接触地面的盒子的数量. 图见 [题](https://leetcode.cn/problems/building-boxes/)
    - 提示: 最优的堆叠方式正如题目所示.
    - 思路1: #模拟 堆叠过程, #二分
        - 先来看最优堆叠情况下, 底层三角形的边长和体积的关系:
            - 从上到下每一层的边长分别为 1,2,...,n. 每一层面积为 `s[i] = i*(i+1)/2`. 因此, 体积为 `v[n] = sum{ s[1...n] }` (也可以推导出公式).
        - 在给定正方形数量n的情况下, 计算最大的满足 `v[j] <= n`  的边长. 然后在其上添加 `remain = n - v[j]` 个正方体即可.
        - 如何计算需要增加多少个地面元素? 参见下面的演示, 增加关系同样按照三角形面积 s 的方式进行增长. 二分找到最小满足 `remian <= s[j]` 的下标即可.

```sh
# 底边边长为3的最优堆叠体的顶视图
000
00
0
# 底面增加两个, 可以在上面堆一个. 共 3个
00XX
00X
0
# 再增加一个, 可以另外堆叠两个. 共 6个
0XXX
0XX
0X
```

关联

- 215. 数组中的第K个最大元素 #medium #题型 #star
    - 给定一个数组, 要求返回其中第k大的元素.
    - 限制: 数组长度 1e5
    - 思路1: 维护一个大小为k 的 最小 #堆
        - 复杂度: O(n logk)
    - 思路2: #快速选择, 基于 #快速排序
        - 基本思路是, 每次选择一个pivot, 将数组元素按照相较pivot的大小关系分成两边.
        - 具体而言, 需要实现 `partition(arr, l,r)` 在 `arr[l...r]` 中随机选择一个pivot, 并返回其下标.
        - 复杂度: 平均复杂度 `O(n)`, 最坏情况下 `O(n^2)`. 为此, 在选择pivot的时候可以增加 random.
        - 具体见 [官答](https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/)


### 226

- 1743. 从相邻元素对还原数组 #medium #题型
    - 对于原本的长n的各个元素都不同的数组, 只剩下了n-1组相邻元素. 要求根据这些重构原数组 (一种即可).
    - 提示: 由于元素各不相同, 因此很容易判断头尾元素 (仅与一个相连).
- 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？ #medium
    - 题目其实比较简单, 用一个 accumulate 即可. 但写得很烦躁, 因为使用在线编辑的原因吗?
- 1745. 回文串分割 IV #hard
    - 给定一个字符串, 问能否将其分割成三个非空的回文串. 限制: 长度 [3, 2000]
    - 思路1: 遍历两个分割点, 这样就要求在 O(1) 的时间内判断 s[i,j] 是否为回文串. 考虑进行预处理
        - 记 `f[i][j]` 为 `s[i...j]` 是否为回文串. 递推: 1) `s[i]==s[j]` 的话, 递推到 `f[i+1][j-1]`, 否则 False; 2) 边界: i==j 的话, True.

### 227

- 1754. 构造字典序最大的合并字符串 #medium #题型
- 1755. 最接近目标值的子序列和 see subset_half

### 228

- 1761. 一个图中连通三元组的最小度数 #hard
    - 给定一张无向图. 问其中所有的联通三角形中 (两两有边相连), 三元组的「度数」的最小值. 度数的定义是, 该三元组与图上其他部分连接的边的数量.
    - 限制: 节点数 n 400
    - 提示: 一种「暴力」的方式是, 直接枚举所有三元组, 若联通的话, 度数即为 `d[a]+d[b]+d[c]-6`
    - 思路0: 假作聪明地尝试遍历两个点, 然后用集合交集来寻找第三个点. 但复杂度同样为 O(n^3).
    - 思路1: 想多了, 直接 #暴力 枚举三个点, 居然就可以过. 当然可以加一些剪枝策略, 但没必要.
    - 不同做法的用时参见 [submission](https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/submissions/)

### 229

没想到一次写了两个多小时... T3发现了LC平台的一个机制, 就是有时候MLE会显示为TLE, 然后研究cache和gc搞了好久... T4乍一看很难, 但关联基本的子序列最大回文串的题之后就一下子出来了 (并进一步探究了DP采用记忆化搜索的一些问题). 有时间可以看看gc, 参见 [here](https://ebook-python-study.readthedocs.io/zh_CN/latest/python%E8%BF%9B%E9%98%B618%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6GC.html).

- 1770. 执行乘法运算的最大分数 #medium
    - 给定一个长m的分数数组multipliers, 每次从长 n>m 的数组nums头/尾选择一个, 要求每次选择的加权和分数最大.
    - 限制: m 1e3, n 1e5. 元素大小 [-1e3, 1e3]
    - 思路: #DP
        - 记 `f[i][j]` 表示选择前i个后j时的最大分数 (范围 i,j 都是 `0...m`)
        - 递推: `f[i][j] = max{ m[i+j-1]*nums[i-1] + f[i-1][j], m[i+j-1]*nums[-j] + f[i][j-1] }`
        - 边界: i,j 其中一个为0的时候, 计算是固定的.
        - 答案: `max{ f[i][m-i] }`
        - 复杂度: O(m^2)
    - 讨论: 关于 **cache的使用以及maxsize的设置**
        - 问题的起因是下面采用记忆化搜索, 直接用 `@lru_cache(None)` 在LC平台会爆TLE (但实际上应该是MLE). 尝试了下面的三个可以解决: 1) 修改成table dp, 不用多说; 2) 在函数执行的结尾加上 `gc.collect()` 手动清理内存; 3) 设置 `maxsize` 为合适的值.
        - 见提交记录 [submission](https://leetcode.cn/problems/maximum-score-from-performing-multiplication-operations/submissions/) 可以发现maxsize的设置起了一些影响 (居然在2000左右效果最好), 而开太大或者None会导致MLE.
        - 然后在 0516 上进一步测试了不同maxsize的影响, 见 [here](https://leetcode.cn/problems/longest-palindromic-subsequence/submissions/). 结论: 1) maxsize较小时很容易TLE; 2) 存在一个较好的区间, 使得在memory开销有限的情况下用时最短; 3) 设置成None或者很大时, 不会增加太多的用时, 但memory开销显著增加, 就有可能导致本题中出现MLE.
        - 参见 [here](https://leetcode.com/problems/stone-game-vii/discuss/1264544/Python-O(n*n)-dp-solution-how-to-avoid-TLE-explained/970807/) 的讨论.
- 1771. 由子序列构造的最长回文串的长度 #hard #题型 #回文
    - 给定两个字符串 word1, word2, 选择两个非空子序列拼起来, 要求构成最长的回文串.
    - 限制: n 1e3
    - 思路: 完全参考「0516. 最长回文子序列」, 将两个字符串拼起来找最长回文子序列. 只需要在更新过程中判断是否两个字符串都取到了即可.

关联

- 0516. 最长回文子序列 #medium #回文
    - 给定一个长n的字符串, 找到最长回文子序列的长度.
    - 思路: #DP
        - `f[i][j]` 表示 s[i...j] 内的最长长度
        - 递推: 1) 若 s[i]==s[j], 则 `f[i][j] = f[i+1][j-1] + 2`; 2) 否则, `f[i][j] = max(f[i+1][j], f[i][j-1])`
        - 边界: `f[i][i] = 1`.
        - 根据递推公式, 可以「斜」着进行遍历. 根据 d=j-i 从小到大遍历. i,j 需要在合适的范围内.
        - [官答](https://leetcode.cn/problems/longest-palindromic-subsequence/solution/zui-chang-hui-wen-zi-xu-lie-by-leetcode-hcjqp/)


### 230

Orz, T3写了好久好久...

- 1776. 车队 II #hard #题型 #单调栈
    - 有一组车 (position, speed) 相同方向行驶. 当两辆车相遇时, 它们按照较低速度组成「车队」. 问所有车与下一辆车相遇的时间 (不相遇则为 -1).
    - 限制: 数组长度 1e5;  位置,速度 1e6
    - 提示: 一定是速度快的车从后面追上前一辆车.
        - 这题的难点在于, 虽然idx可以追上idx+1车, 但idx+1的速度可能会被更前面的车所「拖慢」, 因此实际上相遇时间是需要计算得失idx和idx+x的相遇所需时
    - 思路0: WA
        - 考虑, **对于速度从小到大处理 (相同速度不考虑), 它一定会追上前一辆更慢的车**.
    - 思路0: 从右往左遍历, WA
        - 从右往左遍历(距离从大到小), 则idx车只能可能和idx+1发生碰撞, 碰撞后速度降为前一辆车. 因此, 非发生碰撞的车的速度一定是递减的. 所以可以用一个「单调递减栈」来维护. (进一步, 根本不需要用栈, 记录当前最慢速度即可.)
        - 但这样是错的, 因为如提示, **idx追上的不一定是idx+1** !
    - 思路1: 用 #单调栈 递增栈, 来记录可能会被追到的车
        - 还是从右往左遍历. 用一个「单调递增栈」进行记录.
        - #分类: 1) 若栈顶速度更快, 追不上, 而idx后面的车一定会被idx拖慢, 所以栈顶元素没用了, pop; 2) 否则, 说明idx可以追上栈顶元素, 但时间怎么算? 我们 计算idx追上栈顶所需的时间, 若该时间小于栈顶元素追上下一车的时间, 则直接利用两者计算; 否则, 我们递归栈内下一个元素, 直到找到满足条件的车. 注意到, 对于不满足要求的, **栈顶元素会在下一辆车追到之前撞上栈内下一个元素, 因此没有用了**, 可以pop. (从而将复杂度从 `O(n^2)` 降为 `O(n)`)
        - 参见 [here](https://leetcode.cn/problems/car-fleet-ii/solution/dan-diao-zhan-xiang-xi-jie-fa-by-2018272-5ff7/)
    - 总结: 初看似乎从右往左用单调递减栈, 但实际上记录更高的速度是没有意义的 (会被前面更慢的所拖累, 永远不会发生碰撞); 反而 **用一个单调递增栈来记录可能发生碰撞的元素**. 对于「idx车可能实际上碰撞的是idx+x」这一难点, 遍历栈内元素的碰撞时间来求解, 利用了上述性质将没必要记录的元素直接pop掉, 从而降低了时间复杂度.
    - 思路2: 相较于上面 O(n) 的单调栈「标准解法」, 这里用 #优先队列 来实现一种更为直观的思路, 复杂度 O(n logn). 更符合我刚开始的想法.
        - 核心: 根据相撞时间维护一个优先队列, 从小到大遍历.
        - 一开始, 假设所有车都与前一辆相撞. 由于我们按照碰撞时间排序, 假设当前x撞到了y, 则之后x不会被碰撞, 排除. 需要「修正」x之前的车的碰撞对象为y.
        - 如何维护x「之前」的车? 我们用一个pre数组, 一开始初始化为邻近的前一辆车, 碰撞时更新 `pre[y] = pre[x]`
        - from [here](https://leetcode.cn/problems/car-fleet-ii/solution/ji-yu-you-xian-dui-lie-de-jie-fa-by-arse-tji2/)

### 231

又是比较难的一次 Orz T3考察了带权图上的UCS, T4难度爆炸... 但是用到的内容没有超纲, 从上从下分析起来非常清楚, 👍

- 1786. 从第一个节点出发到最后一个节点的受限路径数 #medium #题型 #UCS
    - 从1走到节点n, 要求「受限路径」为, 所有经过的节点距离节点n的距离依次减小 (边带权), 问所有受限路径的数量.
    - 限制: 节点, 边 2e4.
    - 思路1: #UCS 即可. 除了记录每一个节点的距离, 还统计每个节点的路径数量
        - 正确性: 路径要求其中的每个点的到点n的距离是严格递减的, 而我们是按照节点距离从小到大反向遍历的, 因此, **我们在拓展节点u的时候, 已经将到u的所有合法路径累加好了**.
        - 用一个 #heap, 每次拓展距离最小的节点; 为了避免重复拓展, 用一个 visited哈希表来记录.
- 1787. 使所有区间的异或结果为零 #hard #异或 #hardhard #题型
    - 给定一个长n的数组和一个数字k, 要求对于数组元素做最少次数的改动, 使得所有长为k的子数组的异或和为0.
    - 限制: n 2000; 数组元素 2^10
    - 提示:
        - 最后得到的数组一定是长度为k的 **循环数组**. 证明: 因为相邻两个长k的数组的异或和都为0.
        - 对于所有二进制长度不超过L的一组数字, 它们的异或和一定不超过 2^L-1.
    - 思路1
        - 由于结果为长k的循环数组, 我们可以将原数组划分为k个部分, 我们仅需要确定这k个部分取的数字是什么. 为此, 我们给每个部分统计出现的数字的数量.
        - 可以 #分类 讨论: 1) 考虑某一组数字全部发生替换. 此时, 对于其他组的数字可以 #贪心 选取数量最多的, 然后将全部替换的数字设置为相应的异或和即可; 2) 所有组的数字都采用组内原本就有的. 此时, 采用如下贪心做法:
            - 记 `f[i][mask]` 表示采用前i个组并且异或和为mask时, **最多可以保留的数量**. (方面起见统计最多可以保留的数量, 答案用n一减即可).
            - 递推: `f[i][mask] = max{ cnt[i][num] + f[i-1][mask ^ num] for num in nums }` 这里假设第i组数字包括nums, 而保留了其中的元素 num. (注意: 正因为我们假设了每组都会设置成其中已有的元素, max遍历的复杂度为 `O(n/k)`)
            - 边界: i=0 时, `f[i][mask] = cnt[i][mask]`
            - 复杂度: 根据提示, 我们mask只需要取异或和可能的最大长度即可, 因此DP数组大小 O(k * 2^L), 每次max为 O(n/k), 因此总体复杂度为 `O(n 2^L)`
        - 见 [灵神](https://leetcode.cn/problems/make-the-xor-of-all-segments-equal-to-zero/solution/fen-lei-tao-lun-tan-xin-dp-by-endlessche-y14r/). 相较于 [官答](https://leetcode.cn/problems/make-the-xor-of-all-segments-equal-to-zero/solution/shi-suo-you-qu-jian-de-yi-huo-jie-guo-we-uds2/) 更为清晰.
    - 总结: 灵神的题解真的精彩. 相较于官答, 这里通过分类讨论, 清除地将「仅考虑第i组已有的数字」这种情况分离出来 (从而将max复杂度从 n 下降为 n/k), 理解起来更为直观.


### 232

T3 简单推导一下公式即可; T4又是单调栈求边界.

- 1792. 最大平均通过率 #medium #数学
    - 有一组班级, 每个班的通过率为考试通过人数/总人数. 然后额外有 extraStudents个学生可以保证通过, 将他们分配到各个班级中, 使得整体的平均通过率最大.
    - 思路1: 计算加入一个可通过学生的「收益」, 利用最大堆维护, 每次加入收益最大的班级即可.
        - 假设通过/全部人数为 `a/b`, 则新加一人后变为 `(a+1)/(b+1)`, 通过率差值 `(a-b)/a(a+1) = d/a(a+1)` 其中d表示这个班的未通过人数, 固定; a是班级总人数, 浮动.
        - 因此, 每次选取这一差值最大的班级即可; 可采用 #最大堆 实现.
- 1793. 好子数组的最大分数 #hard
    - 定义子数组的score为, 数组中的最小值*数组长度. 现给定一个数组和一个下标k, 要求找到包含下标k的子数组的最大score.
    - 思路1: 找到idx作为最小值的左右边界. 然后依次遍历区间范围包括所给k的那些区间即可. 参见 [zerotrac](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/solution/hao-zi-shu-zu-de-zui-da-fen-shu-by-zerot-537w/)
        - 另外 [here](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/solution/python-dan-diao-zhan-by-qin-qi-shu-hua-2-69cs/) 指出使用单调递增栈, 不需要记录左右边界: 因为, 1) 「当前索引为i且栈中值被弹出时，当前值作为最小值的区间就是 `[栈中上一个下标 + 1，i - 1]`」; 2) 此外, 对于遍历结束栈内剩余元素, 其区间就是 `[栈中上一个下标 + 1，n-1]`.
    - 思路2: #双指针 因为坐标k必须出现在结果区间中, 可以从k开始 (将其作为最小值mn) 向两边搜索. 然后依次将最小值mn减小以拓展边界, 在此过程中计算score即可. 这一方案适用性相对窄一些.
        - 见 [here](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/solution/c-shuang-zhi-zhen-tan-xin-zui-jian-ji-zu-b3vf/)


### 233

这周的水准好高! T2 题目巨长; T3用了二分; T4好难Orz, 标准解法应该是字典树, 但还是比较难想到. 然后看评论区 #神仙打架 😂

- 1801. 积压订单中的订单总数 #medium #题型 #模拟
    - 按照时间顺序有一批订单. 每个时间包含了一组订单 `(price, amount, type=0/1)` 订单类型 0/1表示买/卖, amount个订单可以分开来处理. 订单有「积压」也即等待处理的情况. 在每一个时间, 若新来的订单为采购, 并且积压的销售订单中有小于该价格的, 则按照价格从小到大购买; 反之亦然. 问最后积压的订单数量.
    - 限制: 数组长度 1e5; price, amount 1e9; 对结果取模.
    - 思路1: 利用两个 #有序数组 分别记录「积压」的销售/购买订单. 然后按照顺序匹配订单即可. (当然, 也可以用 #堆 来处理)
    - 总结: 本题其实模拟了按照时间顺序的一个「市场」, buyer想要最低价格, seller想要最高价格. 然后按照时序依次匹配的过程.
- 1802. 有界数组中指定下标处的最大值 #medium
    - 要求构造一个符合条件的数组 nums: 1) 长度为n, 所有元素为正数; 2) 相邻元素差值最多为1; 3) 所有元素之和不超过 maxSum; 4) 在 index 的位置的元素最大. 要求返回合法的数组中, index 位置元素的最大值.
    - 限制: n, maxSum [1, 1e9];
    - 思路1: #二分
        - 显然, 构造的数组是一个在index处有一个「山峰」的结构.
        - 在给定index位置高度的情况, 容易计算整个数组最小和为多少. 因此可以用二分来搜索.
- 1803. 统计异或值在范围内的数对有多少 #hard #字典树 #题型
    - 给定一个长n的数组, 要求对于所有 (i,j) 的数对, 其XOR值在 `[low, high]` 范围内的数量.
    - 限制: 数组长度和元素大小 2e4;
    - 思路1: 采用 #字典树
        - 我们顺序的进行 查询、插入操作.
        - 对于某一位置的元素x, 题目要求另一个匹配数字的异或满足 `x^y` 在limit范围内的数量. 对于这样的区间问题, 我们拆解为「`x^y` 的值小于等于limit的数量」, 这样 `ans = query(high) - query(low-1)`. 如何统计这一数量? 利用字典树.
            - 具体而言, 我们用函数 `query(value, limit)` 来查询查询树中与 value异或的结果 <= limit 的数量. 我们从高位遍历, 分别记两个位bit是 `a = (v>>i)&1; b = (limit>>i)&1`. #分类 讨论: 1) 若b=0, 则异或结果的该位只能也为0, 字典树的遍历bit和a相同; 2) 若b=1, 则异或结果位若为0, 则显然小于, 该子树下的数字都成立 (直接加到答案中); 对于另一个分支, 我们继续遍历.
            - 总之: 由于在每种情况下我们仅需要递归一个路径, **我们在遍历过程中仅需要记录一个与 limit^value 相应的一条路径即可**. 因此, 查询复杂度为 `O(height)`.
        - 复杂度: O(n log(n)), 第二项为查询树的高度.
        - 总结: #字典树 可以做什么? 检索某一序列是否出现过; 统计出现次数. 而在本题中, 需要统计「**字典树中与value的异或值小于等于limit的数量**」, 这可以通过一定的修改得到.
    - 思路2: 利用numpy 进行暴力搜索. see [here](https://leetcode.com/problems/count-pairs-with-xor-in-a-range/discuss/1119721/Python-NumPy-bruteforce-O(N2)/)
    - 思路3: 神仙思路, 用了 #快速沃尔什变换 [here](https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/solution/kuai-su-wo-er-shi-bian-huan-onlognqiu-xi-fidb/)
        - 但其实复杂度也是 O(n log(n))

### 234

- 1806. 还原排列的最少操作步数 #medium
    - 原本的长尾偶数的排列为 perm = 0,1,...n-1. 现每次进行操作: `f(i) = perm[i/2] if i%2==0 else perm[(i-2)/2 + n/2]` 问经过多少次操作后被还原.
    - 限制: 长度 [2, 1000]
    - 思路1: #归纳 #猜想.
        - 可知, 在每一步中, 将原数组的前一半扩充到偶数位上, 后一半扩充到奇数位上.
        - 画出一步中每个位置的变化情况, 可见 0/n-1 位不变, 其他位置发生「轮转」.
        - 因此 #猜想: 其他位的轮转次数相同, 因此仅考虑其中一个即可. 定义轮转函数 f, 例如当 n=6, idx=1, 这个数字在操作中依次变为 1,2,4,3,1... 因此答案为 4.
    - 思路2: 更为数学的 #证明
        - 除了0/n-1位置保持不变之外, 其他位置的变换关系可以统一写成 `f(i)≡2i mod(n-1)`, 因此有 `f^k(i) ≡ 2^k i mod(n-1)`
        - 为了还原, 需要满足 `2^k i mod(n-1) = i mod(n-1)` (可以看到与i无关)
- 1807. 替换字符串中的括号内容 #medium
    - 字符串中以 `(key)` 的形式存储着一些待替换的key, 将这些替换为所给的 dict元素.
    - 思路1: #模拟 遍历, 用一个变量记录本阶段的开始idx, 遇到 "()" 两个符号的时候进行替换. 注意最后加一个 `(`哨兵.
- 1808. 好因子的最大数目 #hard
    - 问题等价于: 给定一个数字 n, 可以拆分成若干个数字 (相加 =n), 要求这些数字之积最大.
    - 限制: 所给数字 1e9
    - 提示: 拆分出来的数字中不会出现大于等于4的. 这是因为, `2(x-2)>=x` 在 `x>=4` 时恒成立.
    - 思路1: 根据公式计算拆分结果, 然后用 #快速幂 计算.
        - 根据提示, 可知最后拆分的结果一定只包含 2,3. 进一步可知: 数字2出现的次数不会超过两次: 因为若出现3次, 将其替换为两个3是更好的选择.
        - 综上: 计算 `a,b = divmod(n, 3)` 若余数 b==1, 说明3的数量为 a-1 (要进行拆分).
    - 复杂度: 操作次数是常数时间的, 快速幂的复杂度为 O(log n).
    - 关联: 「0343. 整数拆分」 see [官答](https://leetcode.cn/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/)


### 235

T4有点意思, 这个复杂度的计算需要掌握!!

- 1818. 绝对差值和 #medium
    - 给两个长度为n的数组, 最多可以用nums1中的i元素替换nums1中另一位置的元素, 目标要求 abs(nums2-nums1) 之和最小化.
    - 思路1: 先将原数组的绝对差值和算出来, 再减去「通过最多可以减小的绝对值」大小即可.
        - 为了计算最多可以减小的绝对差值, 先对nums1排序, 然而对于目标值muns2的每一个位置, 在排序结果中 #二分 找到最接近的元素, 并且原本相应位置的绝对差比较, 看减小了多少.
- 1819. 序列中不同最大公约数的数目 #hard #题型 #gcd #公约数
    - 给定一个数组, 对于其所有的子序列 (不要求连续), 问所有子序列的公约数一共有多少中不同的数字.
    - 约束: 数组长度 1e5; 数组大小 C 2e5
    - 提示: **数组中存在gcd为g的子序列, 等价于, 数组中所有g的倍数的gcd为g**. 证明: 否则, 它们的最大公因数一定大于g.
    - 思路1: 因此, 对于每一个可能的公因子 1...C, 从数组中找出其所有倍数, 计算其gcd即可.
        - 复杂度: 每个g最多的倍数有 `C/1,C/2,...C/C`, 之和渐进为 `ClogC`. 对于gcd, 利用 #辗转相除 法复杂度为 O(logC). 因此整体 `O(C log^2C)`
        - 事实上, 这个复杂度可以进一步缩紧. 用到的是: **计算m个数字的公约数的复杂度不是 `m logC`, 而是 `m + 2logC`, 也即计算两个数共因子的复杂度logC可以从线性系数中拿出来. 原因在于, 在计算m个数共约数的过程中数字在不断变小. 具体见 [zero](https://leetcode.cn/problems/number-of-different-subsequences-gcds/solution/xu-lie-zhong-bu-tong-zui-da-gong-yue-shu-lrka/) 的评论.
    - 关联: 「AtCoder Beginner Contest 191 F」

关联

- F - GCD or MIN
    - 给定n个数字, 每次操作可以选其中两个数组, 然后用 gcd(i,j) 或 min(i,j) 进行替换. 问进行 n-1 操作后剩余的那个数字有多少种可能.
    - 限制: n 2000; 数组范围 C 1e9
    - 提示: 问题等价于, 找到小于等于 mn = min(nums) 的, nums子序列的最大公因数.
        - 这是因为: 1) 最终结果必然小于等于最小值, 并且一定是某一子序列的 #公因子; 2) 并且我们可以构造操作序列得到该数
    - 思路0: 参考「1819. 序列中不同最大公约数的数目」, 遍历 1...mn, 然后检查是否满足. 这样遍历的复杂度就是 O(C) 了肯定超时
        - 改进: 先找出所有的公因子, 然后依次判断; 也 TLE 了
    - 思路0.2: 对于每一个数字, 找出其所有的因子, 然后判断该因子是否成立
        - 如何判断因子g是否可以取到? 遍历nums, 对于其中所有g的倍数取gcd, 若可以得到g则成立.
        - 超时了, 复杂度分析略. 超时的例子是 `many_divisors`.
    - 思路1: 我们用一个哈希表 t 来存储当前存在的因子.
        - 遍历nums, 对于每一个因子g, {g: minPoss} 来记录遍历nums中g的倍数的过程中, 通过计算gcd可以可到的最小值.
        - 遍历结束后, 统计哈希表中 g==minPoss 的个数即可.
        - 复杂度: 遍历nums O(n); 每个数的因子最多为 O(d(C)); 每次计算gcd O(logC); 因此总体复杂度 `O(n d(c) log(c))`. 这里的d函数表示小于C的数字中最多的因子数. 已知 `d(10^9)=1344`
        - 见 [官答](https://atcoder.jp/contests/abc191/editorial/727)

### 236

T2讲到了约瑟夫环; T3建模了游戏中常见的一个问题, 用DP实现; T4实现了一种非常现实的应用问题. 这一次的题目质量很高.

- 1823. 找出游戏的获胜者 #medium #题型 #约瑟夫环
    - n个玩家围成一圈, 从1开始编号; 在剩余人数超过一人的情况下, 顺时针数第k个人出局. 问最后剩余的人是谁.
    - 限制: 进阶要求 O(n) 的算法
    - 思路1: 暴力模拟, 每次找到出局的人, 环的长度-1. 因此需要pop数组的中间元素, 复杂度 O(nk)
    - 思路2: #推导 #公式. 实际上该问题正是 #约瑟夫环 [wiki](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)
        - 方便起见, 下面编号按照从0开始.
        - 记 `f(n, k)` 表示「长为n的环, 从0开始顺时针, 每次第k个人出局」这样的设置下, 最后剩余的人的编号.
        - 分类: 1) 若n=1, 则 `f(n, k) = 0`; 2) 否则, 本轮出局的人为 `x' = (k-1)%n`, 然后, 记 `x = f(n-1, k)` 表示子问题最后剩余的人. 它们之间的关系有: 由于本轮出局 x', 则子问题中编号为0的在本轮中的编号为 `x'+1`, 因此原问题最终的胜利者编号为 `f(x,n) = (x'+1 + f(n-1, k)) %n = (f(x-1,n)+k) % n`.
        - 当然, 得到上述推导公式之后, #递归 形式可以展开为 #迭代.
[官答](https://leetcode.cn/problems/find-the-winner-of-the-circular-game/solution/zhao-chu-you-xi-de-huo-sheng-zhe-by-leet-w2jd/)
- 1824. 最少侧跳次数 #medium #化简
    - 有三条跑道, 上面各有一些石头. 要从起点跑到终点, 仅能进行侧跳 (在相同的距离处, 从跑道i跳到跑道j). 要求最少侧跳次数.
    - 限制: 每个距离最多有一个石子; 距离 5e5
    - 思路1: #DP
        - 记 `f[d][i]` 表示到达距离d处的跑道i的最少侧跳次数.
        - 则有递推: 若i有障碍物, 则无法到达记为inf; 否则, `f[d+1][i] = min(f[d][i], f[d][j]*{f[d+1][j]!=j} + 1}` 这里的第二项表示从j跑道跳过来, 要求j报道的d+1处没有石子.
        - 化简: 注意到, 对于相同距离无障碍的跑道, **f[d] 之间的差距最大为1**. 将DP数组压缩为1维的情况下, 先将有障碍的位置置为inf, 然后记数组最小值为mn, 则对于非障碍位置有 `f[d+1][i] = min(f[d][i], mx+1)`
- 1825. 求出 MK 平均值 #hard #题型
    - 给定两个参数 m,k 的情况下, 处理流数据的 MK平均值: 取最后的m个元素, 除去最大最小k个元素, 计算剩余 m-2k 个元素的平均值.
    - 要求实现对于流数据的处理DS. 操作包括: 添加一个元素; 计算平均值.
    - 限制: m 1e5; 操作次数 1e5
    - 思路1:
        - 考虑实际情况, 用一个大小为m的 #环形数组 latestM 来存储最近的m个数据. 并且动态更新数组和
        - 1.0:[这个方案不行, 因为无法记录当前元素是否在最大最小的k个数中] 如何维护最大最小的k个元素? 用两个有序数组来存储即可: 例如对于最大的k个元素, 若新元素 num>kLargest[0], 则pop第一个元素然后将num加入.
        - 1.1: 那就用 #有序数组 直接记录最近的m个元素, 然后动态维护 sum(sl[:]) 和 sum(sl[k:-k])
            - 也即, 根据每次插入/删除的位置来 #分类 讨论. 例如, 当插入第idx个数字. 我们在有序列表中找到该数字的位置 idxNew, 则: 1) 若 `idxNew<k` 则 k-1...m-k-1 部分会发生右移, 因此 midSum += sl[k-1]-sl[m-k-1]; 2) 若 `k<=idxOld<m-k`, 则 `midSum += num-sl[m-k-1`; 3) 否则, 对于midSum不影响. (一开始还要删除第idx-m个数字, 思路一致.)
        - 见 [here](https://leetcode.cn/problems/finding-mk-average/solution/by-981377660lmt-5hhm/)
    - 总结: 本题的设置符合实际应用场景需求; 在试错的过程中逐步推导出所需记录的数据结构的过程很有意思.

### 237

T3 在243次周赛中出现了升级版, 之前写过了, 也比较简单; T4利用了异或和与操作的分配关系, 也不算难.

- 1834. 单线程 CPU
- 1835. 所有数对按位与结果的异或和 #medium #异或
    - 给定两个长度为 m,n 数组, 通过两两组合区AND操作, 得到一个长度为 mn 的数组, 返回该数组所有元素依次 XOR 的结果.
    - 思路1: 笨方法 #推导 异或和与运算之间的结合律
        - 最后的结果为 `XOR_i{ ai&b1 ^ ai&b2 ^ ... ^ ai&bm }`, 对于任意一个ai而言, 内部要求其与arr2中的所有元素取AND之后再依次异或.
            - 那么? ai的每一位会保留多少次? (奇数次的异或结果保留, 偶数次则消失). 显然, **保留的次数 = bj该位为1**. 因此, 可以先对所有的bj取 XOR, 然后将结果与ai取AND.
            - 简言之, 我们证明了 `a&b ^ a&c = a & (b^c)`
        - 因此, 上式变为 `XOR_i{ ai & XOR_j{bj} }`. 复杂度为 O(m+n)
    - 思路2: 事实上, 我们可以再次利用上述定理, 进一步化为 `XOR_i{ai} & XOR_J{bj}` 参见 [here](https://leetcode.cn/problems/find-xor-sum-of-all-pairs-bitwise-and/solution/yi-xing-python-by-r4c12-p4bv/)
        - [官答](https://leetcode.cn/problems/find-xor-sum-of-all-pairs-bitwise-and/solution/find-xor-sum-of-all-pairs-bitwise-and-by-sok6/).

### 238

T2的难度偏高, 花的时间挺多的; T3采用了和T2类似的双指针解法; T4基本思路没问题, 但一开始没有想到在两个方向上预计算高度限制, 如果真在打比赛的话估计做不出来. 不过看了一下, 那次也才117个AK? 感觉难度没有那么高来着.

- 1838. 最高频元素的频数 #medium #题型
    - 给定一个数组, 每次操作可以给其中一个数字+1, 在操作数k的限制下, 要求最后的数组中, 相同大小的数量最大.
    - 限制: 数组长度 1e5, 数字大小 1e5
    - 思路1: 先对于数组排序, 计算 #前缀和 之后 #二分
        - 先对于数组排序, 这样, 我们需要填充更低的「阶梯」来得到更高的位置. 考虑对于每个位置可以往前前中多少个阶梯.
        - 对于每一个idx, 我们检查在操作次数k的限制下, 最多可以向前填充多少个数字 (排序之后的数组). 为了快速计算是否可行, 通过前缀和来加速. 利用二分搜索来在 O(log n) 时间内得到结果.
        - 复杂度: O(n logn)
        - 图示见 [here](https://leetcode.cn/problems/frequency-of-the-most-frequent-element/solution/1838-zui-gao-pin-yuan-su-de-pin-shu-shua-ub57/)
    - 思路2: 其实差不错, 只不过上面的二分可以替换为 #双指针
        - see [官答](https://leetcode.cn/problems/frequency-of-the-most-frequent-element/solution/zui-gao-pin-yuan-su-de-pin-shu-by-leetco-q5g9/)
- 1839. 所有元音按顺序排布的最长子字符串 #medium
    - 给定一个仅包含元音字母的字符串, 在所有的子字符串 (连续) 中, 找到符合要求的的最长长度. 要求: 1) 按照顺序排列 (aeiou); 2) 五个元音都包含.
    - 思路1: #双指针 模拟
        - 在遍历l边界的过程中, 判断是否符合条件, 用一个r指针来记录满足条件的最左边 (必然指向第一个元音a).
    - 思路2: #状态机
        - 将五个元音看成是一些状态, 其中a是起始状态u是目标状态, 再用x表示非法状态. 定义出合法的转移; 并在该过程中维护当前长度.
        - 见 [官答](https://leetcode.cn/problems/longest-substring-of-all-vowels-in-order/solution/suo-you-yuan-yin-an-shun-xu-pai-bu-de-zu-9wqg/)
- 1840. 最高建筑高度 #hard
    - 给定一个街道, 建筑高度有限制: 相邻建筑之间的高度差最多为1. 现在给定一组限制的情况下, 问最高可以有多少.
    - 限制: 街道长度 1e9; 限制数量 1e5
    - 思路1: 对于限制排序之后, 两两处理可能达到的最大高度.
        - 若相邻两个限制的高度分别为 a,b (并假设 `a<b`), 1) 若距离d足够的情况下, 先上升在下降, 则最大高度h需要满足 `d >= 2(h-b)+(b-a)`, 也即 `h <= 1/2 * (h+b+a)`; 2) 若d仅支持上升 (也即 d=b-a), 则最大高度为 b.
        - 补丁:
            - 上述的问题在于, 有些限制是无法达到的; **因为若前面升的太高, 后面无法下降到限制高度**. 考虑在遍历过程中需要更新上一个位置可以达到的最大高度, 但还是不对.
            - 参考官答, 在遍历之前, 先 **从左往右从右往左** 对于高度限制进行递推更新: 通过预先的计算, 使得所有的高度限制都是可达的.
        - 总结: 关键在于通过两个方向的遍历, 来计算每个限制点的最大高度.
        - 见 [官答](https://leetcode.cn/problems/maximum-building-height/solution/zui-gao-jian-zhu-gao-du-by-leetcode-solu-axbb/)

### 239

Orz 又是好难的一次周赛, 看了结果AK的只有132人. T3揉合了两个题型在里面, 值得复习; T4的两个大神的思路都挺难想到的.

- 1849. 将字符串拆分为递减的连续值 #medium
    - 给定一个字符串, 问能否将其拆分成递减, 并且相邻元素正好 -1 的部分. 例子: "0090089" 可以拆成 ["0090", "089"]
    - 限制: 长度 20
    - 思路1: 暴力 #DFS
        - 函数签名 `dfs(idx=0, last=None)`
    - 思路2: 实际上仅需要枚举第一个数字, 然后遍历验证是否符合要求即可
        - 复杂度: O(n^2)
- 1850. 邻位交换的最小次数 #medium #题型 #逆序对
    - 给定一个数字排列(数字可重复), 想要得到比它大的第k个排列, 问最少需要 **相邻交换** 多少次.
    - 限制: 长度 1e3
    - 思路1: 先用 nextPermutation 得到目标结果, 然后 #贪心 计算需要交换多少次.
        - nextPermutation 参见「0031. 下一个排列」
        - 如何将 num0 通过相邻元素交换变为 numk? 下面介绍一种贪心的计算方法:
            - 依次遍历初始序列num0的每一个位置i, 若 `num0[i]==numk[i]`, 则不需要交换; 否则, 从左往右找到第一个 num0[j]=numk[i] 的位置, 将其移动到i (发生 j-i 次交换)
        - 我们通过 #逆序对 来进行考察. 将目标的结果重新标号为 `1,2,...,n` (并且可以假设所有数字不同) 这样, 目标序列的逆序数就为 0.
            - 考虑交换 i,i+1: 若 `nums[i]>nums[i+1]` 则逆序数 -1, 若 `nums[i]<nums[i+1]` 则逆序数 +1
            - 每次操作最多使得逆序数-1, 而我们上述算法的每次操作都是满足逆序数减少的.
        - see [官答](https://leetcode.cn/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/solution/lin-wei-jiao-huan-de-zui-xiao-ci-shu-by-xerp9/)
- 1851. 包含每个查询的最小区间 #hard
    - 有一组区间 [left, right], 然后对于每一个查询位置idx, 要求返回包含idx的区间中的长度最小值.
    - 限制: 区间数量n, 查询数量q 1e5; 数值 1e7.
    - 思路1: #离线 算法. 将区间和查询点都看成一系列的 #事件, 然后排序
        - 对于区间左右端点和查询点, 看成是三类事件. 我们对于这些事件根据事件进行排序
        - 然后在遍历过程中, 我们用一个数据结构来 **动态维护当前范围内的合法区间的长度**: 1) 遇到左端点就插入该区间长度; 2) 遇到查询点, 就是该DS中返回最小值; 3) 遇到右端点就从DS中删除该区间的长度. 由此可见, 支持上述插入、删除、查询最小值的数据结构是 #有序集合, 可以调用 #SortedList.
        - 细节: 时间点相同时如何排序? 由于区间是必区间, 显然按照左、查询、右的顺序来处理.
        - 另外, 官答中定义了一个Event类表示事件, 当然自己实现的时候没有必要.
        - see [官答](https://leetcode.cn/problems/minimum-interval-to-include-each-query/solution/bao-han-mei-ge-cha-xun-de-zui-xiao-qu-ji-e21j/)
    - 思路2: 按区间长度排序+ #离线 询问+ #并查集 #TODO
        - 以区间为主体，回答在该区间内的询问。
        - 首先, 对于区间长度和查询的时间进行排序. 然后, 一次回复每个区间内的查询. 那么, 如何避免重复呢?
        - 答案是 **采用并查集来维护**. 具体而言, 对于已经回答过的查询i, 我们将其指向下一个查询i+1. 这样, 当我们回复 [l,r] 这一区间内的查询的时候, 每次都更新 `i = find(i + 1)` 即可 (我们回复了位置i的查询之后, 查找下一个可能还没有回复的位置)
        - 复杂度: 排序 `O(n log n + q log(q))`; 在遍历区间的过程中, 每次需要找到开始位置l, 采用 #二分 查找的复杂度`O(log q)`, 这样算下来的复杂度为 `O(n*log(q))`. 注意这里没有算遍历 [l,r] 的过程中, 因为从整体来看, 每个节点被访问一次后就会往后指, 因此整体复杂度为 O(q).
        - from [灵神](https://leetcode.cn/problems/minimum-interval-to-include-each-query/solution/an-qu-jian-chang-du-pai-xu-chi-xian-bing-6jzs/)

### 240

T3 T4 居然都是做过的题... 算是复习总结了一下.

- 1856. 子数组最小乘积的最大值 #medium
    - 定义一个子数组的score: 为数组元素和 * 最小元素. 现给定一个数组, 要求返回最大的score.
    - 思路1: #单调栈 #前缀和 类似 0907 寻找左右边界; 子数组和可以通过前缀和求得.
        - 通过单调栈来计算每一个元素作为最小值的左右边界
    - 思路2: 在代码层面, 除了用两次单调栈来得到所有边界, 实际上只需要一个单调栈即可同时求出
        - 具体来说, 若在遍历位置i的过程中, 假如遵循的是 `nums[s[-1]] >= nums[i]`, 则对于每一个栈顶元素来说, 其下一个更小元素为位置i; 而对于while循环后将i入栈, 则此时的栈顶元素 j 是左侧第一个满足大于等于 nums[i] 的元素.
        - 注意, 这里求的 right是严格小于 nums[i] 的元素位置, 而left则是小于等于 nums[i] 的元素位置. 但 **这不影响结果, 因为左右边界中总有一个得到了最长的数组**.
    - 关联: 「2281. 巫师的总力量和」
- 1857. 有向图中最大颜色值 #hard #题型 #DAG #拓扑排序 #DP
    - 给定一张图 (可认定为是 DAG), 每个节点有一个颜色. 对于每一条路径, 定义其值为相同颜色数量的最大值. 要求计算图上路径的最大值.
    - 若图上出现环, 则返回 -1.
    - 思路1: #拓扑排序
        - 状态转移: 如何记录路径上的(最大)节点数量? 对于每个节点, 用一个数组记录以该节点终止的所有路径上, 各个颜色的最大值.
        - 更新公式: 对于 (u,v) 边, 其每一个颜色的更新值为 `colorNode[u][color] + (color==colors[v])` 也即上一个邻居点的值, 加上是否为v的颜色.
        - 如何判断是否有环? 拓扑排序是否遍历了所有节点

### 241

T3第一次TLE有点蠢, T4的排列没有学过完全想不到, 但本来应该就是用DP来解的, 但是递推公式好难Orz, 这里的核心在于想到「可以将 `1,2,...k-1,k+1,...n` 重新标号为 `1...n-1`」.

- 1863. 找出所有子集的异或总和再求和 #easy
    - 对于一个数组, 求其所有子集的异或值的和.
    - 限制: 长度 12以内
    - 思路: #暴力 搜索. 对于每个数字模拟是否取
- 1864. 构成交替字符串需要的最小交换次数 #medium
    - 要求将01数字经过若干次操作变为「交替数组」, 操作为交换任意两个位置的数字.
    - 限制: 1e4
    - 思路1: #分类 讨论, 然后模拟
        - 根据数组长度判断: 若为偶数, 并且两个字符数量相同, 则分别尝试0/1开头; 若为奇数并且0/1的数量相差1, 则按照大的那一个开头. 否则不成立.
    - 关联: 「1888. 使二进制字符串字符交替的最少反转次数」
- 1865. 找出和为指定值的下标对 #medium
    - 要求实现一个类, 初始化 nums1, nums2. 实现: 1) 将一个正数加到 `nums2[idx]`; 2) 统计满足 `nums1[i] + nums2[j]` 等于指定值的下标对 (i, j) 数目
    - 限制: nums1 长度 m 1e3, 数据范围 1e9; nums2 长度 n 1e5, 数据范围 1e5. 操作次数1000次.
    - 思路0: 直接用一个 #哈希表 记录两数组 (i,j) 匹配的和的数量 #TLE
        - 复杂度: 初始化的时候为 O(mn), 每次增加一个值的复杂度为 O(m), 因此总体复杂度为 `O(m (n+K))`, 其中K为操作数量. 所以是初始化超时了?
    - 思路1: 直接用两个 #哈希表 来记录量数组的取值, 然后每次查询的时候遍历 num1, 求目标值的补即可.
        - 复杂度: 初始化 O(m+n), 每次查询 `O(m)`
    - 总结: 放在第三题可能导致自己想多了. 思路0没有考虑初始化两两匹配的复杂度, 思路1实际上是更容易想到的.
- 1866. 恰有 K 根木棍可以看到的排列数目 #hard
    - 对于1...n的所有排列, 问其中能从左侧正好看到k根木棍 (能看到要求没有遮挡) 的排列数目.
    - 限制: n 1e3
    - 思路1: #DP
        - 形式: `f[i][j]` 表示用 1...i 进行排列, 能够看到 j 个的排列数量.
        - 递归: 若能够看到第i个位置, 则其一定高为i, 在剩余的 i-1 根中可以看到 j-1 个, 也即 `f[i-1][j-1]`; 否则, 其为 1...i-1 中的某一个数字, 剩余的 i-1 个中可以看到 j根; 注意, 假设位置i的数字为k, **由于能否看到仅依赖于相对大小关系, 我们可以直接将它们看成是 1...i-1**, 因此, 等价于 `f[i-1][j]`.
        - 综上, 有 `f[i][j] = f[i-1][j-1] + (i-1) * f[i-1][j]`
        - 约束: 0<j<=i. 因此边界情况 `f[i][0] = 0`. 但由于 `f[1][1] = f[0][0]+0` 要等于1, 我们初始化 `f[0][0]=1`
        - 复杂度: O(nk)
    - 思路2: 建模为 #排列 问题.
        - 对于可见的k个木棍, 将其和后面不可见的看成一个整体, 则n个数字被划分成了k组, 并且 **每组中的第一个数字正是其中最大的那个数, 其他数字任意排列** (注意到, 这恰好是一个 [圆排列](https://baike.baidu.com/item/%E5%BE%AA%E7%8E%AF%E6%8E%92%E5%88%97/3081193), 数量等于 `(len-1)!`); 而不同组之间的顺序是固定的, 因为要求从小到大.
        - 综上, 问题转化为: 将n个数字分成k组, 对每个组求「循环排列数」 —— 恰好是「把n个元素排列成k个非空圆圈（循环排列）的方法数目」这一[第一类斯特灵数](https://zh.wikipedia.org/wiki/%E6%96%AF%E7%89%B9%E7%81%B5%E6%95%B0) 的直观理解.
        - 在具体的递推公式上, 完全和思路1一致, 只不过在理解上更深了一层.
        - 见 [灵神](https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/solution/zhuan-huan-cheng-di-yi-lei-si-te-lin-shu-2y1k/).

### 242

- 1870. 准时到达的列车最小时速 #medium
    - 有一组路, 路口只能在整点出发, 要求在hour范围内到达, 问最少能够到达的速度是多少.
    - 限制: 答案 1e7 以内的整数.
    - 思路1: 标准的 #二分 题目. 需要注意的是要根据题意来判断边界条件.
- 1871. 跳跃游戏 VII #medium
    - 有01的路径s, 要求从开头跳到最后, 每次只能跳 `[minJump, maxJump]` 的距离并且只能跳到值为0的位置. 问能否跳到最后.
    - 思路1: #二分
        - 用一个有序数组记录所有可达的0位置. 在顺序遍历s中可跳点的过程中, 要求「判断 `[idx-maxJump, idx-minJump]` 范围内是否有可达点」, 这可以通过两次二分查找得到.
        - 复杂度: O(n log(n))
    - 思路2: 官答给出的是用 #DP 然后用 #前缀和 优化
        - 针对遍历过程中判断某一范围内是否有可达点这一问题, 用一个DP数组来记录信息. 问题是顺序判断的复杂度为 O(maxJump-minJump) = O(n), 如何优化?
        - 答案是利用前缀和.
        - see [官答](https://leetcode.cn/problems/jump-game-vii/solution/tiao-yue-you-xi-vii-by-leetcode-solution-rsyv/)
- 1872. 石子游戏 VIII #hard #interest #博弈
    - 有一排数量n的石子, 每个石子有一定的分数, AB轮流从左侧拿多于一颗石子, 然后分数累计为自己的分数, 然后将一个等价值的石子放回去. 两者都想 **最大化自己与对方的分数差** (也即, A想最大化 scoreA-scoreB, B则想最小化). 问都在最优策略下, scoreA-scoreB 的值.
    - 限制: 数量 1e5
    - 提示:
        - 可以考虑 #前缀和. 问题等价于, AB轮流取下标 (每一个下标要比上一个更大, 并且第一个要求>0) 获得分数
    - 思路1: 采用 #DP
        - 表示: 记 f[i] 为A在选择 [i,n) 范围内下标时可以取得的最大分差.
        - 递推: 两种情况: 1) 若A没选第i个石子, 则有 `f[i] = f[i+1]`; 2) 若选了i (拿到 acc[i] 分), 则对于B来说, **他要从 [i+1,n) 范围内选择, 使得分差最小, 正好等于 `-f[i+1]`**, 因此有 `f[i] = acc[i]-f[i+1]`. 因此有: `f[i] = max{ f[i+1], acc[i]-f[i+1] }`.
        - 因此, 从后往前 #逆序 DP即可, 最后的答案即为 f[1]
        - [官答](https://leetcode.cn/problems/stone-game-viii/solution/shi-zi-you-xi-viii-by-leetcode-solution-e8dx/)
        - 说明: 这里的情况2比较tricky, [灵神](https://leetcode.cn/problems/stone-game-viii/solution/zai-qian-zhui-he-shang-dao-xu-dp-by-endl-jxqs/) 的解答中分别给出了AB两人的递推公式, **因为两者形式一致所以可以合并到一起**, 这样思考更顺.
    - 总结: 在思考的时候有点被例子带歪; 考虑到用前缀和后最tricky的地方在于想到情况2的公式, 这里可以借鉴灵神的思路, 更容易想到一点.


### 243

今天不太在状态. T3 一开始因为自己傻X的变量重复命名WA调试了好久; T4 则第一次遇到了卡浮点数精度的题目 (虽然一开始的DP也没想出来就放弃了).

- 1882. 使用服务器处理任务 #medium 关联 1834
    - 有一组tasks, 每个所需的时间为 tasks[i]. 还有一组servers, 每个的权重为servers[i]. 任务按照第 0,1,2,... 的顺序到达, 每次从空闲的服务器中选择权重最小的来处理. 问每个任务被分配到的服务器的编号.
    - 思路1: 用两个 #最小堆 分别记录空闲的机器 (根据服务器权重) 和正在运行/busy的机器 (根据结束时间排序)
        - 关键是如何处理时刻t没有空余机器的情况?
      官答中给的思路是, 顺序遍历tasks! 在遍历过程中 (用一个for循环), 维护一个全局的ts变量, 记录下一个空闲机器的时间 (定义了一个release函数释放释放在ts及其之前结束的机器); 若当前任务到达时没有idle机器, 则设置ts为最近的一个结束时间.
      自己一开始的想法: 用一个队列tasksQue 记录待处理的任务. 和上面的区别在于, 遍历tasks之后可能有任务没有进行处理, 最后需要再处理tasksQue中剩余的任务. 稍微复杂一点.
        - 复杂度: 在顺序处理n个任务的时候, 我们需要将ts之前结束的机器释放, 但注意到会执行任务的机器一共只有n个, 因此复杂度最多为 `O(n log(n))`. 这是粗糙的分析, 详见 [官答](https://leetcode.cn/problems/process-tasks-using-servers/solution/process-tasks-using-servers-by-leetcode-rot1m/)
- 1883. 准时抵达会议现场的最小跳过休息次数 #hard
    - 你需要在时间限制hoursBefore前经过n条路到达会场, 你的速度给定, 每条路的长度不同; 走完一条路之后, 一般情况下需要休息到整数时刻走下一条路. 在路口你可以选择「跳过」操作直接走下一条路. 问为了在时间限制内到达最少需要多少次跳过操作?
    - 限制: n 1e3; 每条路长度 1e5, 速度 1e6, hoursBefore 1e7
    - 思路1 #DP
        - 表示: `f[i][j]` 表示通过前i条路, 最多用j次跳过的最短时间. 结果范围 f[n] 中时间小于 hoursBefore 最小的j即可.
        - 递推: `f[i][j] = min{ ceil(f[i-1][j]+dist[i]/speed), f[i-1][j-1]+dist[i]/speed }` 第一项表示已经用满了j次机会, 因此需要上取整; 第二项表示这次使用跳过.
        - 关于 **浮点数**: 注意浮点数的运算是有精度的, 例如在Python中 `ceil(8.0 + 1.0 / 3 + 1.0 / 3 + 1.0 / 3)` 因为误差会, 加法的结果会比9大一点, 最后得到了错误的取整结果10. 错误的用例: 路段长度都是 100000 速度 75000, 每次的浮点数都是 1/3左右, 所以会有误差.
            - 在本题中, 为了避免这一问题, 可以在加法操作后减去一个不影响的数值EPS, 从而避免由于精度带来的误差. 例如, 这里路径长度为整数, 而速度最大为 1e6 量级, 因此实际计算的时间的最小量级在 1e-6 以内, 我们可以取 EPS=1e-7.
            - 参见[官答](https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/solution/minimum-skips-to-arrive-at-meeting-on-ti-dp7v/)
        - 除了上述技巧, 还可以 **将浮点数运算转为整数**, 从而避免上述问题.
            - 也即, 用 `f[i][j]` 表示对应的时间内人没有阻碍可以跑的距离. 则有递推 `f[i][j] = min{ ceil((f[i-1][j]+dist[i])/speed) * speed, f[i-1][j-1]+dist[i] }` 这里的第一项需要取整之后再乘以速度转为距离单位, 变为整数.
            - see [灵神](https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/solution/jiang-dp-mu-biao-gai-wei-zui-xiao-hua-fe-kg1k/)
    - 总结: 这是第一次遇到卡浮点数运算精度的题, 分析比较简单, 但很有意思!

关联

- 1834. 单线程 CPU #medium
    - 给定一组tasks, 每个任务是开始时间和需要运行的时间. 现在只有一个CPU, 会选择任务队列中运行时间最短的那一个执行. 问CPU处理的任务顺序
    - 约束: 任务数量 1e5; 任务时间 1e9
    - 提示: 维护一个 #最小堆 记录当前待运行的任务
    - 思路1: 如何维护其他还没进入等待队列的任务? 可以对开始时间进行排序.
        - 具体而言, 可以用一个指针来记录已入对的任务数量. 如下.
        - 在写的时候用的是 pop(0) 发现超时了, 因为要注意Python中这一操作的复杂度为 O(N)!
    - 思路2: 除了进行 #排序, 也可以还是用 #堆 来实现「取出ts时刻之前的task」这一任务.
    - 细节: 如何实现对于所有任务进行遍历执行?
    - 总结: 尽量少使用 `pop(0)` 操作, 其复杂度为 O(N) !! 可以用 `deque` 替代

### 244

- 1886. 判断矩阵经轮转后是否一致 #easy
    - 给定两个方阵, 判断经过旋转后是否一致.
    - 思路1: 分别计算每种旋转的坐标变换公式 (推了好久Orz), 如下. 例如顺时针90度变换, 坐标从 (i,j) 变为 `(j, n-1-i)`. 具体可以参见 0048 的[官答](https://leetcode.cn/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/)
    - 思路2: 看了官答的解法, 还真就原地旋转了三次, 更为粗暴.
- 1887. 使数组元素相等的减少操作次数 #medium
    - 定义了一种操作, 问将数组最终变为所有元素相等的操作次数. 直接推公式就行
- 1888. 使二进制字符串字符交替的最少反转次数 #medium
    - 对于一个01字符串, 可以采取两种操作: 1) 将第一个字符移到最后; 2) 反转任意一位. 问要将某一字符串变为「交替」的操作序列中, 类型2操作的最小次数.
    - 思路1: #分析 归纳不同的类别. 具体需要分别计算 #前缀 和 #后缀, 然后匹配.
        - 提示: 1) 可以将所有的操作1安排在操作2后面; 2) 操作1起作用的情况, 只可能是操作2之后变为 `101|10` 这种; 注意到, 此时字符串一定是奇数长度, 并在某一位置前后出现了两个连续的比特. 并且, 在上例中, 左侧是以1结尾的交替串, 右侧是以1开头的交替串 (都是0也可).
        - 因此, 我们考虑将字符串转为 1) 0101或1010; 2) 转为上述情况 (仅当长度为奇数) 这写情况中, 所需的翻转步骤最小的.
        - 为此, 可以 `pre[i][0/1]` 表示将前i位变为以 0/1 结尾的交替串所需的翻转数. 则有递推: `pre[i][0] = pre[i-1][1] + (s[i]==1)`; `pre[i][1] = pre[i-1][0] + (s[i]==0)`;
        - 同样, 用后缀 `suf[j][0/1]` 表示将j位之后的串变为以 0/1 开头的交替串所需翻转数. 递推 `suf[j][0] = suf[j+1][1] + (s[j]==1)`; `suf[j][1] = suf[j+1][0] + (suf[j]==0)`;
        - see [官答](https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/solution/shi-er-jin-zhi-zi-fu-chuan-zi-fu-jiao-ti-i52p/) 思路很清晰.
        - 灵神给出了一个类似的, 更fancy的, 也更难理解的 [方法](https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/solution/cong-qian-wang-hou-pi-pei-cong-hou-wang-uiq6a/).
    - 思路2: 利用 #滑动窗口
        - 提示: 由于最后的结果只有01/10序列两种情况, 因此假如变为某一类型需要x次翻转, 则变为另一种类型需要 n-x 次翻转.
        - 按照思路1的分析, 主要考虑的是奇数时从哪个位置分成左右两段? 注意到, 若将左半部分接到右边是合法的. 因此, 我们double字符串 (从而避免边界判断), 然后用 #滑动窗口 扫描每一种情况需要翻转的次数.
        - 具体看 [here](https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/solution/minimum-number-of-flips-by-ikaruga-lu32/) 的图更为直观.
    - 总结: 上面 `101|10` 这种情况叫做「循环同构」; 思路1虽然复杂但其实是更容易想到的; 思路2更为巧妙但其实绕了很多弯.
- 1889. 装包裹的最小浪费空间 #hard
    - 需要将n个物品装到包裹中, 一个包裹只能装一个体积更小的物品; 对于一组固定大小的包裹, 定义score为所有包裹浪费的空间之和; 现在要从m个供应商中选一组提供包裹, 使得score最小.
    - 限制: m,n 1e5; 每个供应商提供的不同尺寸的包裹数量 1e5
    - 思路1: 排序 之后 #二分计算. 用到 #前缀和 加速计算
        - 思路比较简单: 就是先分别对于物品和提供的包裹体积排序, 然后依次二分找到该体积的包裹对应了哪一部分的物品, 利用前缀和加速计算.
        - 复杂度: $O(n \log n+l \log l+l \log n)$ 这里的l为所有供应商提供的箱子的数量之和, 参见 [官答](https://leetcode.cn/problems/minimum-space-wasted-from-packaging/solution/zhuang-bao-guo-de-zui-xiao-lang-fei-kong-90lk/#comment).

### 245

居然栽在了T2, 写了个复杂的fancy函数结果超时了, 应该先分析一下复杂度的, 可能最近二分写得比较少; T4思维量确实比较大, 但整体看下来思路还是很清楚的, 非常有趣!

- 1898. 可移除字符的最大数目 #medium #题型
    - 给定两个字符串 s,p, 其中p为s的子序列; 另外有一个下标序列removable 表示s中的一些位置, 要找到最大的k使得从s中删除 `removable[:k]` 后, p仍然为s的子序列.
    - 约束: s,p 1e5; removable 中的坐标互不相同.
    - 思路0: 从左往右检查删除 removable[i] 后是否满足. #模拟 #超时
        - 用一个 pIdxs 列表记录当前p中的每一个字符在s中的匹配位置(最靠左的匹配方式), 用removed集合来记录已经删除的坐标. 每删除一个s中的字符(从左往右遍历removable)后, 检查删除的是否在pIdxs, 若在的话, 从所在的位置 pidx 开始重新匹配.
        - 写了一个很fancy的 `search(pidx, idx)` 函数表示新增了removed之后, 需要从pidx和idx出发重新开始匹配, 能否成功.
        - 这样, 每次重新检查的复杂度为 O(n), 因此极端情况的整体复杂度是 O(n^2) 会超时!!!
    - 思路1: #二分 搜索
        - 忘记了一种最简单的方法 orz. 本题中, 现在答案的取值范围为 [0...len(removable)], 因此可以用二分搜索来求解.
        - 复杂度: `O(n log(len(removable))) = O(n log(n))`
- 1899. 合并若干三元组以形成目标三元组
- 1900. 最佳运动员的比拼回合 #hard #interest #题型
    - 有 1...n 个运动员顺序排列. 在竞标赛的执行过程中, 前第i为和后第i位对决二进一 (若n为计数则中间的人轮空晋级). 假设除了两个特殊的选手 firstPlayer < secondPlayer 特别强之外, 其他人的水平都相近. 其他人相互对决时胜负均可. 问两个特殊选手对决出现的最早和最晚轮次.
    - 限制: 2 <= n <= 28
    - 思路1: #分类讨论 来简化分析; #DP; 并利用 #记忆化搜索
        - 不妨令 `F(n, f,s)` 表示数量为n个, 我们关心的两个人分别在f,s位置时的最少轮次, 用 G(n, f,s) 表示最大轮次.
        - 下面讨论 F的递推关系, G是完全类似的. 首先, 可以假设 f<s, 不满足的话交换即可. 在下面的讨论中, 记中间位置为 `half = (n+1)//2`
        - 另外, 可以使得 f<half, 不满足的话对于两个运动员 **取对称位置** `n+1-s, n+1-f` 即可. 下面分类:
        - 若 s<=half, 此时, 记经过一个轮次后, f前面保留的人的数量和f,s之间保留的人的数量为 i,j, 则它们分别可取 `[0...f-1], [0...s-f-1]`, 而两个人下一轮次的位置为 i+1, i+j+2. 于是有转移方程 `F(n,f,s) = min{ F(half, i+1, i+j+2) } + 1` 这里的ij取上述范围.
        - 若 s>half. 记s对称位置为 `s'=n+1-s`, 则根据 f, s' 的位置关系进行分类:
            - 若 `s'==f`, 则直接结束 F(n,f,s) = 1
            - 另外的情况下, 我们仍可以统一为 f<s': 若出现f>s'的情况, 类似上面的分析我们同样将两者取对称位置即可.
            - 总之, 有 `0<=f<s'<half`. 这样, f前面和f,s'之间保留的人的数量 i,j 分别可取 `[0...f-1], [0...s'-f-1]`; s'一定被s击败; s'...s 最中间的 n-2*s' 个人一定保留 `mid = (n-2*s'+1)//2` 个, 因此有转移方程 `F(n,f,s) = min{ F(half, i+1, i+j+mid+2) } + 1`
        - 代码: 在具体实现上, 如何完成这样的DP? 在Python中可以简单用 #记忆化搜索 来送上至下进行计算.
        - 细节: 对于两次「取对称位置」操作的条件? 第一个是 `s>f>=half`; 第二种情况是 `n+1-s==s'<f`, 于是有 `f+s>n+1`, 注意到这对于第一种情况也是成立的. 于是可以合并为同一个判断 `f+s > n+1`.
        - 复杂度: DP有三个维度, 每次枚举的复杂度为 O(n^2), 但我们注意到, 递推过程中数组长度n是指数下降的, 因此实际复杂度为 `O(n^4 log(n))`.
    - 详见[官答](https://leetcode.cn/problems/the-earliest-and-latest-rounds-where-players-compete/solution/zui-jia-yun-dong-yuan-de-bi-pin-hui-he-b-lhuo/), 图文并茂.


### 246

T3简单的BFS没想出来简洁的写法, 而是写了个复杂的并查集, 有点可惜; T4居然也标记为medium, 大概是思路比较朴素没有用什么fancy的技巧.

- 1904. 你完成的完整对局数 #medium #题型
    - 一个完整的棋局时长15分钟, 都是整点, 也即 HH:00, HH:15, HH:30, HH:45 之间的. 现在给定开始结束时间, 问其中包含多少个完整时间.
    - 思路1: 转为 #整数 #取整.
        - 小时的权重为60转为整数, 然后除以15算差值, 注意分别上下取整.
        - 注意边界: "00:47" "00:57" 这种情况可能产生 -1, 需要特别判断为 0.
- 1905. 统计子岛屿 #medium #题型
    - 有两个大小为 (m,n) 的0/1 grid表示地图, 1相连的部分表示岛屿. 对于B中的某个岛屿, 若其所有点都在A的某个岛屿上, 则称其为A的子岛屿. 现要求返回B的所有子岛屿的个数.
    - 限制: m,n 500;
    - 提示: 注意到, 只需要求出B中的所有岛屿 (联通分量), 检查该岛屿覆盖的点在A上是否均为陆地即可.
    - 思路1: 利用 #并查集 得到B中所有的岛屿
        - 一开始不知道怎么求所有的岛屿, 写了个并查集, 比较繁琐.
        - 注意到, 并查集「并查集」也可以实现返回当前某集合/联通分量的大小. (但这里还是要遍历所有的节点)
    - 思路2: 直接用 #BFS 得到B中所有的岛屿
        - 参见 题中的 [官答](https://leetcode.cn/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/)
        - 注意: 关键是, 在遍历已经搜索到的点的值原地修改为0即可, 从而避免重复.
    - 复杂度: 均为 O(MN)
- 1906. 查询差绝对值的最小值 #medium #题型
    - 定义查询为: 给定 [start, end], 返回这一子数组中元素的「差绝对值的最小值」 注意如果范围内所有元素都相同, 则返回-1 (也即不能为0). 现给定一个数组和一组查询, 返回所有查询的结果.
    - 限制: 数组长度 1e5, 查询数量 2e4; 数组中每个元素范围 [1,100]
    - 思路1: #前缀和
        - 注意, 这里元素的范围较小 (100) , 考虑用前缀和记录每一个前缀中所包含的元素数量
        - 这样, 对于任意的区间 (i,j) 都可以在O(100)的时间内查询出其中包含的元素数量. 对于每个查询计算即可.
        - 复杂度: (n+q)100
    - 拓展: [这里](https://codeforces.com/problemset/problem/765/F) 将元素范围拓展到了 1e9, 只能采用离线方案了.

关联

- 0200. 岛屿数量 #medium
    - 给定一张土地, 相互邻接的土地构成岛屿, 问图上的岛屿数量. 等价于, 联通分量的数量.
    - 思路1: 直接 #BFS
        - 注意: 为了避免重复, 可以直接到grid上修改, 将访问过的点置为0.
    - 思路2: #并查集
        - [官答](https://leetcode.cn/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/) 给出了采用并查集, 得到联通分量数量的方法.

### 247

这一期的题目都挺有意思的, T3字符串前缀和可以看看灵神总结的类似题; T4的题目描述太好玩了, 也是有意思的题型.

- 1914. 循环轮转矩阵 #medium
    - 给定一个 (M,N) 大小的矩阵, 从外到内分成一圈一圈的圆周, 要求把每个元素沿着圆周转动k步.
    - 限制: M,N <= 50; k <= 1e9
    - 思路: 简单计算公式
        - 实现一个函数 `f(m,n,i)`, 计算「对于长宽为 (m,n) 的环的第i个位置的元素坐标」.
        - 然后从外到内移动每一层上的所有元素即可
- 1915. 最美子字符串的数目 #medium #题型 #前缀和
    - 定义「美子串」为: 字符串中, 字符的数量为奇数的字符最多出现一个. 现给定一个字符串, 求其所有的连续子串中「美子串」的数量.
    - 约束: 字符串长度 1e5, 字符只包含 a-j 10种.
    - 思路1: 枚举 #前缀和 #状压
        - 利用字符种类最多只有10个的限制, 可以用一个长度为10的二进制数表示这些数字的奇偶状态. 例如 aba 所对应 `...010` 表示b出现了奇数次
        - 对于当前枚举的位置j, 假设其前缀和为s[j], 若对于位置对 (i,j) 而言,
            - 若 `s[i]==s[j]`, 则说明 `word[i+1:j+1]` 这一子串中所有的字符都出现了偶数次.
            - 若 `s[i]^s[j]` 的结果仅包含一个非零位, 说明 `word[i+1:j+1]` 范围内有仅有一个字符出现了奇数次.
        - 因此, 我们在遍历字符串计算前缀和的过程中, 用一个计数器记录之前前缀和出现次数, 按照上面的规则累计即可.
        - 注意: 空字符串的前缀和定义为0
        - 复杂度: O(n)
        - from [灵神](https://leetcode.cn/problems/number-of-wonderful-substrings/solution/qian-zhui-he-chang-jian-ji-qiao-by-endle-t57t/)
    - 总结: 对于 (i,j) 对匹配计数的问题, 这里需要遍历的过程中直接进行累计计算, 而不是遍历完得到完整的cnt再处理. 这是两种不同的思路, 需要加强前一种方式的思维.
- 1916. 统计为蚁群构筑房间的不同顺序 #hard #题型
    - 归纳为, 给定一个树, 从根节点出发从上往下不断增加节点, 只有当父节点已有的时候才能构造孩子节点. 问有多少种构造方式.
    - 限制: 节点数量 1e5, 对于结果取模
    - 思路1: #DFS
        - 归纳过程: 对于某一节点, 假设有两个孩子节点
            - 先不考虑孩子节点内部的顺(看作是唯一的), 若两孩子的size分别为s1,s2, 这两棵子树构造过程中需要保证内部的顺序一致, 因此共有 comb(s1+s2, s2) 种构造方式.
            - 一般地, 对于一组孩子, 若其孩子包含节点数量为childSizes, 则构造方法共有 `ans' = prod{ comb(s[...i], childSizes[i]) }`, 其中s[...i]是前缀和.
            - 再考虑每个孩子内部的顺序分别为nums, 则构造方法共有 `ans = ans' * prod{nums}` 种
        - 按照上述公式, DFS 即可. 注意DFS函数需要返回当前节点的构造方法数和子树大小两个值.

### 248

T3应该快速想到 #快速幂 的, T4考察了 字符串哈希以及为了避免碰撞所需的MOD的选择问题.

- 1921. 消灭怪物的最大数量 #medium #题型
    - 题目设置很有意思(类似植物大战僵尸): 对于长度n的一个列表, 每一行有一个距离 dist[i] 的怪物以速度 speed[i] 移动, 每次可以选择一行击毙敌人. 问最多可以坚持多长时间.
    - 约束: 数组长度 1e5
    - 思路1: #模拟
        - 题目其实比较简单, 关键是需要注意边界情况.
- 1922. 统计好数字的数目 #medium #快速幂
    - 问满足一定条件的数字的个数. 总而言之, 计算公式为 5^(ceil(n/2)) * 4^(floor(n/2))
    - 约束: 数字范围为 1e15, 对结果取模
    - 思路1: 利用 #快速幂 计算
        - 对于这么大的数字, 可知算法必然是要求在 O(log(n)) 级别的
    - 总结: 注意数字范围那么大, 应该马上联想到快速幂的.
- 1923. 最长公共子路径 #hard
    - 给定n个长度至多为n的序列, 问这些序列的最长公共子数组. 相较于 「0718 题」, 从2个数组变为n个.
    - 约束: n <= 1e5, 所有数组的长度之和L <= 1e5
    - 思路1: #字符串哈希 + #二分
        - 思路和0718一样, 不过这里检查长度k是否满足的时候, 需要依次比较所有数组所包含的哈希值集合之交集是否非空.
        - 复杂度: O(L * log(n)) 其中计算所有哈希值需要 L, 二分搜索的范围为 `[0, min(len_i)]` 即所有数组的最小长度.
        - 关于参数的选择: 官答中的分析很赞!
            - #生日悖论: 若随机选择 23个人则两个人生日相同的概率大于 50%. 一般而言, 从 N个数字中随机选择K个, 当 K=O(log(N)) 时, 出现重复(碰撞)的概率很大.
            - 本题中, 所有长度为k的子串的数量级在 `L=O(1e5)` 级别, 因此选择的模应该远大于 1e10 级别.
                - 因此, 答案中选择 (10**9+7) * (10**9+9) 将两个大质数相乘.
                - Python中不用考虑大数字的问题, 在其他语言中, 可以分别求这两个数字的模, 都不想相等时才认为子串不同.
            - 另外, 关于base的选择: 可能的公共子串的长度在 1e5 级别, 题目中随机选取了 `[1e6, 1e7]` 范围内的随机数, 发现确实比较容易过 (而 1e5 以下的冲突概率较大).
    - 总结: 在 Rabin-Karp 算法的基础上, 更多考察了 base, mod 的选择问题, 通过 #生日悖论 理论计算了所需的mod.
    - [官答](https://leetcode.cn/problems/longest-common-subpath/solution/zui-chang-gong-gong-zi-lu-jing-by-leetco-ypip/)

补充题型

- 0718. 最长重复子数组 #medium #题型 Rabin-Karp
    - 给定两个数组, 求出最长公共子数组的长度.
    - 限制: 两数组长度都小于 1e3
    - 思路0: #暴力 方法. 枚举所有的 (i,j) 开始匹配位置, 尝试匹配. 注意这样的时间复杂度为 O(n^3) 会超时!
    - 思路1: 用 #DP 进行优化
        - 注意, 思路0中哪里出现了重复比较? 在尝试匹配 (i,j), (i-1, j-1), (i-2, j-2)... 的过程中, 都会比较 nums[i:] 和 nums[j:]
        - 实际上, 我们可以避免这样的重复. 记 `f[i][j]` 表示nums[i:] 和 nums[j:]的最大匹配长度, 则仅当 nums1[i]==nums2[j] 时有 `f[i][j] = f[i-1][j-1] + 1`, 否则为0.
        - 这样, 时间复杂度为 O(MN)
    - 思路2: #字符串哈希 + #二分
        - 考虑子问题: 判断两数组是否有长度为k的公共子数组. 可以采用 Rabin-Karp 计算字符串哈希, 若两字符串有相同哈希值则认为有 (当然有几率发生碰撞).
        - 滚动计算哈希值: 可以采用 #滑动窗口 的策略
            - 有递推公式: `hash(s[i+1:i+1+len]) = (hash(i:i+len) - base^(len-1)*s[i]) * base + s[i+len]`
        - 复杂度: O((M+N) log(min(M,N)))
    - 思路3: #滑动窗口
        - 题解2中说的很好: 「想象两把尺子，错开之后比较相同的部分，找最长相同的串就好了」; 很符合实际拿到两个纸质列表的直观解法.
        - 复杂度: O((M+N) min(M,N))
    - 总结: 从复杂度上来说, 还是字符串哈希是最快的, 因为没有尝试进行两字符串之间的比较.
    - [官答](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/solution/wu-li-jie-fa-by-stg-2/)

### 249

T3 一开始没有看清楚约束条件, 其实注意到约束想到状压DP就比较简单了; T4 是少见的二叉搜索树题型, 关键是想清楚构造的唯一性. 这次是两道hard.

- 1931. 用三种不同颜色为网格涂色 #hard
    - 给定一个 (m,n) 的网格, 用三种颜色涂, 要求相邻的颜色不同, 问有多少种方案.
    - 约束: 1 <= m <= 5, 1 <= n <= 1000
    - 思路1: #状压 #DP
        - 重点是grid的维度一比较小: 这样我们可以枚举所有的涂色可能性. 这样, 再遍历每一行的过程中, 仅需要考虑和上一行每一列的相邻颜色不同即可.
        - 考虑状压: 0,1,2 表示三种颜色, 则我们可以用 [0, 3^m) 范围内的数字表示每一行的涂色情况.
        - 用 `f[i][mask]` 表示遍历到第i行, 并且最后一行的颜色为mask的涂色方案数.
        - 状态转移: `f[i+1][mask] = sum{ f[i][mask2] }` 这里要求 mask, mask2 所对应的行涂色都是合法的, 并且两者同一列的颜色都不同.
        - 预处理: 可以预先计算所有合法的行涂色方案 validLines; 并且计算合法的相邻行 transMap, 其中 transMap[mask] 是所有合法的相邻行列表.
- 1932. 合并多棵二叉搜索树 #hard #二叉搜索树 #树 #题型
    - 给定n棵(合法的) 二叉搜索树,  每棵树最多两层 (也即最多root+left+right三个节点), 按照下面的方式进行合并, 问能否经过n-1 合并后成为一个合法的二叉搜索树.
    - 合并方式为: 找到 (i,j) 对, 满足第j棵树的root值等于第i棵树的leave节点的值, 然后将这个节子节点替换为第j棵树, 并且整棵二叉搜索树仍然是合法的.
    - 约束: 所给的n棵树的根节点值唯一
    - 提示: **构造的唯一性**
        - 最重要的一点观察: 根据上述规则最终得到的结果是唯一的.
        - 题目保障了所有跟节点的值是唯一的, 我们可以知道, 若某一个树不是最终的root, 那么它对应的合并节点是唯一的.
            - 反证法: 设该树的根值为x, 若有两个叶子节点的值均为x, 这棵树只能合并到其中一个叶子节点上, 那么最终还会有两个值相同的节点, 与最终得到一棵二叉搜索树矛盾.
        - 进一步有: 所有叶子节点的值也是唯一的 (因为最终二叉搜索树的节点值唯一, 而合并过程中最多只能消去一个叶子节点).
        - 这样, 构造就是唯一的. 遍历所有跟节点和叶节点, 我们可以找到那个唯一的跟节点 (其值不出现在叶节点的值中), 而其他树都可以与某一个叶子节点唯一对应起来.
    - 思路1: 从上往下遍历
        - 关键是要找到某一节点的值的范围约束. 如果不按照特定顺序进行合并, 则较难维护叶子节点的range.
        - 而根据构造的唯一性, 我们可以从跟节点出发, 这样, 我们在遍历过程中可以维护新增节点的范围约束
            - 例如, 假设当前节点node的范围约束为 `range = (l, r)`, 我们在根节点中找到 node.val 所对应的那一棵树 replaceNode(由于我们的构造顺序, 其最多root+left+right三个节点), 我们很容易检查是否满足条件
            - 然后, 更新replaceNode的叶子节点的 range.
        - 综上, 我们维护一个queue记录从跟节点出发的树中所包含的所有叶节点, 遍历过程中, 将会发生合并的根节点替换该叶节点, 然后将新加入节点的叶节点加入queue. 最后, 若今剩下唯一的合法二叉搜索树, 则构造成功.
    - 思路2: 直接 #中序遍历
        - 官答给出了一种更妙的思路: **既然构造是唯一的, 并且我们可以按照从上往下的顺序来合并, 那么直接中序遍历即可.**
        - 这样, 相较于思路1, 我们可以简化节点范围约束的检查: 因为中序遍历天然要求节点的值递增, 我们仅需要维护一个全局的 prev 变量, 记录上一个节点的值即可.
        - [官答](https://leetcode.cn/problems/merge-bsts-to-create-single-bst/solution/he-bing-duo-ke-er-cha-sou-suo-shu-by-lee-m42t/)



### 250

- 1935. 可以输入的最大单词数
- 1936. 新增的最少台阶数
- 1937. 扣分后的最大得分 #medium
    - 给定一个grid形式的矩阵, 每行选取一个位置的元素, 累计所有分数; 对于相邻的 i, i+1 行, 需要扣除 `abs(c_i - c_i+1)`, 也即相邻行所选两列的位置差值. 要求最大分数
    - 约束: grid大小 1e5
    - 思路1: #DP
        - 考虑每多一行 row 造成的分数变化? 对于每一列的数字, 都是 `dp[i] = max(dp[j] + row[i] + abs(i-j))` (这里左侧dp是上一行的值).
        - 也即, 当前行本身的值的大小不会影响j的取值. 上一行的值造成的变化是可以计算的.
        - 因此, 递归过程中: 每次都 1) 计算上一行的分数影响; 2) 加上当前行每一列的元素值.
        - 具体而言, 例如上一行的最大值为 `[2,7,4]`, 则下一行每个位置的最优剩余分数为 `[6,7,6]`. 可以看到是较大元素向左右传播. 因此左右两边分别进行一次遍历, 去较大即可.
        - see [here](https://leetcode.cn/problems/maximum-number-of-points-with-cost/solution/kou-fen-hou-de-zui-da-de-fen-by-leetcode-60zl/)

## 周赛 251-300

### 251

- 1945. 字符串转化后的各位数字之和
- 1946. 子字符串突变后可能得到的最大整数
- 1947. 最大兼容性评分和 #medium
    - 给定m个学生和m个老师, 两两匹配, 要求最大匹配分数和. 定义分数: 对于学生和老师的长度为n的0/1选择题, 分数为他们相同选项的数量.
    - 约束: m,n < 8
    - 思路1: 预先计算匹配矩阵. 然后DFS遍历所有可能的匹配情况
        - 建模为「二分图匹配问题」. 要求遍历他们之间的匹配方式.
        - 为了避免重复, 以idx 顺序遍历所有的学生; 维护一个remains集合记录所有未匹配的老师.
        - 这样, DFS的复杂度为 8x7x...x1. 时间上 `math.perm(8)=40320` 是够的.
        - 除了采用DFS的形式之外, [官答](https://leetcode.cn/problems/maximum-compatibility-score-sum/solution/zui-da-jian-rong-xing-ping-fen-he-by-lee-be2l/) 借用 0031 的思路得到所有的排列, 避免了递归, 形式上更为清晰.
    - 思路2: #状态压缩 #DP
        - 也是顺序给学生分配老师. 用一个0/1 mask数字记录老师的匹配情况. f[mask] 表示
        - 递归公式: `f[mask]= max{f[mask\i]+g[c-1][i]}` 表示 c-1 转移到 c. 这里的 `mask\i` 表示将mask的第i位从1变为0.
        - 答案为 `f[2^m - 1]`
        - see 官答
- 1948. 删除系统中的重复文件夹 #hard
    - 背景很有意思: 对于一棵目录树, 若两个节点所包含的目录结构(文件夹名字)相同, 则认为它们是重复的. 给定一棵目录树, 要求检测删除所有重复节点.
    - 约束: 目录树的节点数量 2e4, 路径最大深度 500, 文件夹名称不超过 10个字符.
    - 思路1: #字典树 + #括号表示法 + 哈希表
        - 如何检测两棵子树结构相同? 对于树结构序列化为字符串, 判断两个字符串是否相同. (采用后续遍历DFS)
        - 如何保证子节点之间的顺序? 利用Trie存储子节点, 对于key排序.
        - 如何删除重复节点? 用一个哈希表存储节点表示到节点的映射, 将 1:n 映射的节点删除.
        - [官答](https://leetcode.cn/problems/delete-duplicate-folders-in-system/solution/shan-chu-xi-tong-zhong-de-zhong-fu-wen-j-ic32/)
        - 复杂度: 见答案中的分析.

### 252

- 1952. 三除数
- 1953. 你可以工作的最大周数
- 1954. 收集足够苹果的最小花园周长
- 1955. 统计特殊子序列的数目 #hard #题型
    - 满足条件的子序列为 [0,...,0,1,...1,2,..,2] 形式的, 也即由若干个0,1,2 组成的递增序列. 现给定一个序列, 要求返回其中满足条件的子序列的数目.
    - 约束: 数组长度 1e5, 对于结果取MOD.
    - 除了DP思路之外, 一开始试图利用前缀和计算前后的0/2的组合数量, 然后枚举中间的1, 但是需要考虑首尾分别用的是哪个位置的1, 两两匹配似乎复杂度过高.
    - 思路1: #DP
        - 考虑转移过程: 当遇到一个2时增加多少计数? 两种情况: [0,1,2]序列后添加一个2, 或者 [0,1]序列后添加2. 也即 `count012 = 2*count012 + count01`
        - 进一步, 如何统计在该位置之前有多少01序列? 当遇到一个1时, 递推公式 `count01 = 2*count01 + count0`
        - 最后, 到某一位置的0序列数量有多少? 递推 `count0 = 2*count0 + 1`
        - 总结: 在遍历序列过程中, 维护三个变量 (三元素DP), 当遇到 0/1/2 时分别对对应元素进行更新.
        - [here](https://leetcode.cn/problems/count-number-of-special-subsequences/solution/dong-tai-gui-hua-by-endlesscheng-4onu/)

### 253

- 1961. 检查字符串是否为数组前缀
- 1962. 移除石子使总数最小
- 1963. 使字符串平衡的最小交换次数 #medium #括号 #题型
    - 对于一个长度为2n的左右括号序列, 左右数量相等; 问最少进行多少次i,j位置元素交换, 使左右括号序列平衡.
    - 思路1: #贪心
        - [灵神](https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/solution/go-tan-xin-by-endlesscheng-7h9n/) 的思路太清晰了!
        - 简言之, 每一次遇到左括号不够的情况, 我们都需要尽量靠右 (贪心) 拿一个左括号和当前右括号进行交换
        - 但实际上 **我们不需要真正进行这次交换**, 因为我们并不关心拿到的左括号的位置 —— 它不会影响我们的结果
        - 具体到代码上, 我们用count统计剩余未匹配的左括号数量. 当遇到右括号并且count==0时, 另count, ans均+1.
    - 思路2: 观察 + #归纳
        - 比较数学/玄学, 见 [官答](https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/solution/shi-zi-fu-chuan-ping-heng-de-zui-xiao-ji-f7ye/)
- 1964. 找出到每个位置为止最长的有效障碍赛跑路线 #hard #DP
    - 问题定义: 给定一个序列, 对于其中的每一个值, 计算以其结尾的递增序列的最大长度
    - 思路1: #线段树
        - 我们用一个哈希表记录num结尾的递增序列的最大长度
        - 这样, 对于每一个元素, 我们需要查询「小于等于当前元素的数字中, 长度最大的那一个」. 因此可以用线段树来解决
    - 思路2: #DP
        - 基本和 0300 「最长递增子序列」完全一致.
        - 核心是: dp[i] 记录长度为 i+1 的序列中, 结尾元素的最小值


### 254

- 1967. 作为子字符串出现在单词中的字符串数目
- 1968. 构造元素不等于两相邻元素平均值的数组
- 1969. 数组元素的最小非零乘积 #medium
    - 给定一个位数p, 对于从1到(2^p)-1一共 `(2^p)-1` 个数字, 我们可以对其中的两个数字进行同位交换的操作(不允许使得数字变为0); 要求最后所有数字的乘积最小
    - 同位交换操作: 例如 x = 1101 且 y = 0011, 我们交换右起第二位后得到 x = 1111 和 y = 0001
    - 约束: p最大到60
    - 思路1: 观察 #归纳 #快速幂
        - 观察p=3时的情况, 事实上我们比较容易有猜想, 公式也容易得到 $\left(2^{p}-1\right) \cdot\left(2^{p}-2\right)^{2^{p-1}-1}$ .
        - 注意到, 在 `(2^p)-1` 个数字中, 每一位上出现1的个数为 `2^(p-1) - 1` 次.
        - 要让乘积尽可能小, 猜想是尽可能将1集中到大数字上. 因此, 分配这些1到各个位上, 可以得到 `(2^(p-1))-1` 个 11..110, `(2^(p-1))-1` 个 00..001, 还有一个 11..111 (因为多了一个最低位1)
        - 证明见 [灵神](https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/solution/tan-xin-ji-qi-shu-xue-zheng-ming-by-endl-uumv/)
    - 快速幂: `2^p` 可能非常大, 如果直接用 `x**n` 会超时, 应该采用Python的快速幂函数 `pow(x,n,MOD)`. 参见 0050 题.
- 1970. 你能穿过矩阵的最后一天 #hard #题型 #可达性
    - 对于一个 (row, col) 的gird, 目标是从第一行的任意位置到达最后一行的任意位置. 最开始所有单元都是陆地, 给定一个序列, 每一天会淹没一块陆地, 要求能达到最后一行的最大天数.
    - 思路1: 反向 #BFS
        - 我们从最后的状态反向往前推: 哪一天可以找到一条路径了, 就找到了答案.
        - 如何避免重复的路径搜索? 用visited记录已经访问的节点. 同时用一个set来记录可以抵达的被淹没节点 —— 这样, 当某一天刚被淹没的单元出现在set中时, 我们即可将它加回queue中继续搜索.
        - 总结: 本题是可达性判断的变种, 还挺有意思的.
    - 思路2: #二分搜索
        - 官答给出的一种解法, 复杂度 `r*c* log(r*c)`, 其中对数项为二分.
    - 思路3: #并查集
        - 也是从后往前考虑: 如果最后一行和第一行属于同一个集合, 则存在路径.
        - 为此, 定义两个超级节点, 分别连接第一行和最后一行的所有单元. 在从后往前的过程中, 每新增一块陆地, 就将其和相邻陆地连接, 然后检查这两个超级节点是否连接.
    - [here](https://leetcode.cn/problems/last-day-where-you-can-still-cross/solution/ni-neng-chuan-guo-ju-zhen-de-zui-hou-yi-9j20y/)

### 255

- 1979. 找出数组的最大公约数
- 1980. 找出不同的二进制字符串 #题型 #二进制
    - 注意熟悉二进制字符串与整数 (以及格式化) 的方式
- 1981. 最小化目标值与所选元素的差 #medium
    - 给定一个grid, 可以从每一行选择一个元素, 要求与目标值 target 的绝对差最小.
    - 约束: 行列数量不超过70, 元素大小70, 目标值不超过800
    - 思路1: #DP
        - 从下往下遍历, 我们维护到目前为止的行, 每行选取一个元素, 可以构成的所有数字 (利用set进行去重)
        - 本质上也是动态规划 (背包问题): f[i][j] 表示到第i行为止, 每行选择一个元素, 是否可以得到和 j
        - dp的思路可以枚举j, 也即 $f[i][j]=f[i][j] \vee f[i-1][j-x]$; 而下面代码中的思路则是维护一个set来保存所有出现的j; 两种方式在不同的约束下应该各有好坏.
        - 另外, 注意到下面进行filter操作! 可以有效减小搜索空间. 但要注意最后nums可能为空, 因此需要判断 (或者像官答一样计算一个 minSum)
        - 参见 [here](https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/solution/zui-xiao-hua-mu-biao-zhi-yu-suo-xuan-yua-mlym/)
- 1982. 从子集的和还原数组 #hard #题型 #数学
    - 给定数组的长度n和所有的 2^n 个子集的和, 要求还原原来的数组.
    - 约束: n<=15, 子集和 -1e4~1e4
    - [官答](https://leetcode.cn/problems/find-array-given-subset-sums/solution/cong-zi-ji-de-he-huan-yuan-shu-zu-by-lee-aj8o/)
    - 思路1: #递归 求解, 每次还原一个数字
        - 结论1: 对于所有的子集和排序, 记最小和次小元素为 `x,y`, 则 `x-y, y-x` 之一一定在原数组中.
            - (假如有负数) 考虑次小元素是如何产生的? 要么是少了一个负元素, 要么是多了一个非负元素. (没有负数的情况下, 则一定是 y-x)
        - 提示2: 记差值 `d = y-x` (这样我们知道了 d, -d 之一一定在原数组中). 我们可以将 2^n 个子集和分成两部分 `S,T`, (一一对应) 使得每个 s[i] + d = t[i]
            - 可以采用双指针
            - 这样, 即可递归求解 —— 因为 S,T 之一一定是一个大小为 n-1 的子问题. 但注意到其中一个可能是非法的, 因此两个分支都要进行搜索, 需要DFS尝试回退.
        - 结论3: 事实上, 对于 S,T 的选择, 我们只需要选择包含0 的那一个即可. 这样避免了DFS.
            - 注意到, 一个数组的子集和中一定包含0 (空集).
            - 那么, 如果 S,T都包含0呢? 结论是选择哪一个都行. 例如, 假设原数组A 中包括 d, 而我们选择了 S.
                - 此时, S中的元素为原数组的所有子集和都 -d.
                - 由于 S包含0. 可知原数组中有一个集合O, 使得 `sum(O) - d = 0`.
                - 这样, 我们只需要对 O的元素都取反 O', 原数组A中其他元素不变, 这样变换后的数组B的所有子集和就是S.
                - 证明: 对于S中的任意元素 `s[i] = t[i] - d` 假设 t[i] 由原数组A中, 在O之外的X集合和O之内的Y集合构成. 我们在变换后的数组B中, 选择 `X` 和 `O'\Y`. 这样, 我们正好就是在 t[i] 的基础上减去了所有的O元素 (也即d).

### 256

- 1984. 学生分数的最小差值
- 1985. 找出数组中的第 K 大整数
- 1986. 完成任务的最少工作时间段 #medium
    - 有一组任务, 完成每个任务需要一定的时间. 你每次训练可以工作 `sessionTime` 个小时. 在一个session中, 你可以完成多个任务, 但一个任务不能分割到多个session中. 要求分配任务到不同的session, 使得session总数最小.
    - 限制: 任务数量 1 <= n <= 14; 任务时间 max(tasks[i]) <= sessionTime <= 15
    - 注意, 不能用「尽量选择大的任务」的方法, 例如 [2,2,3,3,3,5], sessionTime=9 的情况下, 这种方案会导致 [5,3], [3,2,2], [2] 而实际答案为 2.
    - [here](https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/solution/wan-cheng-ren-wu-de-zui-shao-gong-zuo-sh-tl0p/)
    - 思路1: #枚举子集 的动态规划 #DP
        - f[mask] 表示mask对应子集所需的最少session.
        - 递归的方式: 显然有 f[mask] = min{f[mask\subset] + 1} 这里的subset要求是子集中元素和不超过 sessionTime 的.
        - 如何 **遍历所有子集**? 有一种经典的方式: 先初始化 `sub = mask`, 然后递归 `sub = (sub - 1) & mask` 即可保证.
        - 如何计算子集和? 为了避免重复, 可以预计算.
        - 时间复杂度: $3^n$. 在递归过程中, 我们需要遍历 mask [1: 2^n], 而每一个mask有多少非零位? 可知包含k个1的二进制表示有 $C^n_k$ 个. 因此复杂度为 $\sum_{k=0}^{n}\left(\begin{array}{l}n \\ k\end{array}\right) 2^{k}$. 正好是 $3^n = (1+2)^n$ 的二次项展开形式.
        - 具体见链接.
    - 思路2: #存储两个值的动态规划
        - 本思路更符合直觉, 复杂度也更低, 但是比较难想清楚.
        - 对于某一mask表示的集合, 我们考虑最后一个加入的元素, 并且 **让之前的session都不再变化**. 这样, 可以用 (segment, currnet) 表示状态. 其中前者表示已用的session数量, 后者表示最后一个session已占用的时间.
        - 转移: `f[mask] = min{trans(f[mask\i], tasks[i])}` 这里的i是枚举了所有mask中包含的元素. trans是对于状态的转移, 比较简单.
        - 复杂度: O(n * 2^n)
- 1987. 不同的好子序列数目 #hard
    - 给定一个二进制字符串, 一定「好子序列」为合法的二进制数(除了0本身之外不包含前导0). 求 **不同** 的好子序列的数目.
    - 例如, binary = "101" 有5个好子序列: ["1", "0", "1", "10", "11", "101"]
    - 约束: 1 <= binary.length <= 10^5
    - 思路1: #倒序 #DP
        - 为了子序列合法, 我们仅考虑「以1开头的不同子序列数量」. 最后若字符串中包含0再 +1 即可
        - 如何得到以1开头的子序列数量? **倒序** 看有多少以0/1结尾的子序列数量!
        - 令 dp[i][0/1] 表示从后往前, 直到第 i 位的字符串中, 有多少以0/1结尾的子序列数量
        - 转移公式: 若 `s[i]==1`, 显然 `dp[i][0] = dp[i+1][0]`, 而 `dp[i][1] = dp[i+1][0] + dp[i+1][1] + 1` 分别表示在原本的基础上加上字符1, 以及单独的一个比特1.
        - from [灵神](https://leetcode.cn/problems/number-of-unique-good-subsequences/solution/jian-ji-xie-fa-by-endlesscheng-bvrx/)
        - [官答](https://leetcode.cn/problems/number-of-unique-good-subsequences/solution/bu-tong-de-hao-zi-xu-lie-shu-mu-by-leetc-ej2n/) 的讨论更复杂些.


### 257

Orz 这次的题目好难

- 1995. 统计特殊四元组 #easy #题型
    - 给定一个数组, 找出其中满足 a,b,c 位置元素之和 = d 位置元素的四元祖的数量 `(a<b<c<d)`
    - 思路1: 暴力枚举.
        - 直接枚举所有的`(a<b<c<d)` 四元祖, 如果满足条件, 则 ans += 1
        - 官答用了for, 我一开始用了dfs, 时间复杂度上应该差不多. 都是 `O(n^4)`
    - 思路2: 用哈希表存储 nums[d] 的频次, `O(n^3)`
        - 在思路1中, 对于每一个 `s = nums[a] + nums[b] + nums[c]`, 我们都需要从 `nums[c+1:n-1]` 中统计 `s` 的频次.
        - 在这里, 我们可以用哈希表来存储 `s` 的频次. 这样可以降低一个量级.
        - 具体而言, 如何依次统计 `nums[c+1:n-1]` 范围内的数字? 可以对 c 从大到小遍历 [n-2...2], 每次将 c+1 假如到Counter中. 对于ab的遍历还是和之前一样, 只需要满足 `a<b<c`
    - 思路3: 用哈希表存储 nums[d]-nums[c] 的频次
        - 将原等式转为 `nums[a] + nums[b] = nums[d] - nums[c]`, 然后遍历 a<b.
        - 关键是如何统计 `nums[d] - nums[c]` 的频次? 同样是对于b从大到小遍历 [n-3...1], 每次b减小1, 我们可以将 `nums[d] - nums[c:=b+1]` 加入Counter, 这里d范围 [b+1:n-1].
        - 这样, 我们从大到小遍历b, 第二层遍历中, a遍历b的左侧, d遍历b的右侧. 总的复杂读为 `O(n^2)`
    - [官答](https://leetcode.cn/problems/count-special-quadruplets/solution/tong-ji-te-shu-si-yuan-zu-by-leetcode-so-50e2/)
- 1996. 游戏中弱角色的数量 #medium #题型 #复杂排序
    - 定义“弱角色”：包括攻击和防御两个属性，两个指标都严格小于另一个角色的角色. 要求返回一组人物中弱角色的数量.
    - 本题需要注意的是只有当两个属性都严格小的情况下才是弱角色. [here](https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/solution/you-xi-zhong-ruo-jiao-se-de-shu-liang-by-3d2g/)
    - 思路1: #排序
        - 首先, 按照攻击X 从大到小排序. 然后, 我们可以维护一个「最大防御值」maxY. 这样若当前遍历角色的防御值小于最大防御值, 则该角色「可能是」弱角色.
        - 需要注意点在于, 对于攻击值相同的角色 `p, q`, 若「最大防御值」刚好是q产生的, 这里不满足严格小的关系. 例如 `[10, 10], [10, 9]` 的情况下第二个不是弱角色.
            - 一种思路对于攻击值相同的元素分为一组, 用上一轮的 maxY来比较, 当一组遍历结束后再更新 maxY.
            - 另一种更优雅的, 可 **进一步对于防御值Y从小到大排序**. 我们仍然维护的 maxY, 此时, 若出现 `y<maxY`, 则这里的 maxY 一定是在上一个轮次 (也即攻击值严格大的角色)产生的.
    - 思路2: #单调栈
        - 思路其实差不多, 区别在于, 思路1是从大到小遍历, 看每个角色是否为弱角色. 而这里时从小到大遍历, 用单调栈保存尚无法判定的角色, 利用出栈操作决定弱角色.
        - 具体而言, 这里先按照 攻击值从小到大, 防御值从大到小排序. 然后用一个单调递减栈保存防御值, 同样可以避免上面提到的问题.
        - 单调栈保存元素防御值. 由于攻击值相同的元素, 防御值从大到小排序, 因此 1. 相同攻击值最大防御值的角色最先入栈, 将此前轮次的弱角色弹出; 2. 元素不会被相同攻击值的(同一轮次)另一个角色所弹出
- 1997. 访问完所有房间的第一天 #medium #DP
    - 有n个房间, 有一个 nextVisit 数组. 你在第一天访问房间0, 按照下面的规则访问下一个房间, 问经过多少天后访问完所有房间.
        - 算上本次访问, 若访问房间i的总次数为奇数, 则下一次访问 `nextVisit[i]` 所指定的房间，其中 `0 <= nextVisit[i] <= i`;
        - 否则, 访问 `(i + 1) mod n` 号房间 (也即下一个房间).
    - 约束: n的长度 1e5. 对于结果取 mod
    - 思路1: #前缀和 优化 #DP
        - 注意到, nextVisit 所能访问的都是i之前的房间, 因此一定是顺序从 0...n 访问房间的.
        - 如何从 i-1 访问到 i? 需要访问两次i-1号房间, 第二次的时候按照规则2 访问下一个房间.
        - 也即, 从第一次访问房间 i, 到从房间i 跳转到 i+1, 需要经历多少天? 核心: 需要依次访问 nextVisit[i]...i-1 号房间.
        - 因此有递推公式 `dp[i] = dp[nextVisit[i]] +...+ dp[i-1] + 2 = cumsum[i] - cumsum[nextVisit[i]] + 2` 这里的2是需要访问两次 i 号房间, cumsum[0] = 0.
        - 因此, 可以依次计算, dp[0]...dp[n-2], 这样第一次访问到最后一个房间的天数是 dp[n-2]+1-1, 这里+1是要跳转到最后一个房间, -1 是因为天数从0开始计算.
        - [here](https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms/solution/qian-zhui-he-you-hua-dp-by-endlesscheng-j10b/)
- 1998. 数组的最大公因数排序 #hard
    - 给定一个数组, 对于任意两个位置 i,j, 若他们存在公共因子 (`gcd(nums[i], nums[j]) > 1`) 则可进行交换. 问数组是否可以按照上述规则进行交换后, 变为递增数组.
    - 约束: 数组长度 3e4, 数字大小 1e5
    - 思路1: 分解 #质因子 的 #并查集
        - 结论: 对于有公共因子的数字之间连边, 可知, 在一个连通分量上, 经过交换操作可以得到任意的数字顺序. 例子:  `[10,5,9,3,15]` 两个因子 3,5 通过 15 连接, 这个数组可以得到任意顺序
        - 因此, 就是并查集的思路. 但是元素之间两两查询的复杂度不够. 因此, 我们引入 prime 数字构成的节点.
        - 这样, 对于一个数字num, 我们得到所有的质因子 factors, 将 num 连到任意质因子上, 然后将 factors[1:n-1] 都连到 factors[0] 上即可.
        - 判断: 最后, 将 nums, sorted(nums) 的每一位比较, 两元素相同则不需要交换; 否则, 查询 x,y 是否在同一集合中, 只有在同一集合中才能交换得到.
        - 下面预先计算的所有可能的质因子, 但实际上可以简化, 见 [here](https://leetcode.cn/problems/gcd-sort-of-an-array/solution/bing-cha-ji-fen-jie-zhi-yin-shu-by-xin-x-ylsz/)

### 258

- 2000. 反转单词前缀
- 2001. 可互换矩形的组数
- 2002. 两个回文子序列长度的最大乘积 #medium
    - 约束: 字符串长度最大为 12
    - 思路1: #暴力 划分, 搜索
        - 对于idx字符而言, 将其划分到 字符串1/2/不使用 3中状态, 每次检查的复杂为子串长度. 因此复杂度为 O(n * 3^n)
        - [灵神](https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/solution/go-bao-sou-by-endlesscheng-ivn0/)
    - 思路2: 状态压缩
        - 先进行状态压缩. 对于每一个子序列计算是否为回文串(及其长度), 复杂度为 O(n * 2^n)
        - 注意, 这里所有回文串的数量最坏情况下是 m = 2^n 量级的.
        - 然后, 可以对于m个回文串两两匹配, 判断是否有重复使用的字符, 但注意最坏情况下是 `m^2 = 4^n` 级别的; 反而更差.
    - 总结: 1. 在本题数量级较小的情况下, 暴力划分是可选的一种方案; 2. 不要无脑想到状态压缩等方案, 应该先进行复杂度的分析.
- 2003. 每棵子树内缺失的最小基因值 #hard #题型 #启发式合并
    - 给定一棵家族树, 每个人的基因都是独特的. 基因值在 [1, 1e5] 区间内. 现在要求家族树上每个人的子树中, 「缺失的最小基因值」. 例如, 若子树包含 `1,2,3,5,6...` 那个就要返回 4
    - 限制: 家族树大小 1e5
    - [here](https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/solution/go-qi-fa-shi-he-bing-by-endlesscheng-kmff/)
    - 思路1: #启发式合并 [OI wiki](https://oi-wiki.org/graph/dsu-on-tree/)
        - 基本的思路是, 在DFS的过程中, 返回子树所含含的数字集合, 遍历所有子节点之后对这些集合求union, 然后计算 `mex`. 计算情况下, 每一个节点都包含 n 个数字, 合并这些子树(并找到mex)的代价是 `O(n)`, 这样, 整体的复杂度 `O(n^2)` 不行
        - 这里 #启发式合并 的意思是, 在选择数组合并的过程中, 尽量选择将小集合合并到大集合中 (类似并查集中启发式选秩更大的作为root). 这样, 大的子节点返回的集合将不会进行合并操作 (只会合并其他小集合)
        - 可以证明这样贪心之后的复杂度是 `O(n log(n))`
        - 另外, 在递归dfs子节点的时候, 利用子节的mex值作为下届, 由此出发, 每次+1来搜索当前节点的mex. 这样可以避免链式的节点都包括 `1,2,...,n-k` 导致搜索需要 O(n) 时间的情况.
    - 思路2: 利用基因值不同的特点
        - 由于要求mex并且基因值的范围在 [1, 1e5], 因此若子树不包含1则答案就是1. 利用基因值都不相同的特点, 我们 **只需要考虑基因值为1的节点往上的祖先节点**.
        - 这样, 我们维护一个全局的 `inSet` 记录子树上所有的基因值. 先找到基因值1的节点x, 在依次遍历其祖先的过程中, 加入祖先所包含的其他子树的数字到 `inSet`, 然后更新mex即可. 并且注意到, 沿着该路径往上的过程中, 节点的mex是递增的.
        - 复杂度: 我们最多遍历一次节点; 并且在尝试mex的过程中也是递增的. 所以总的复杂度是 `O(n)`

### 259

- 2011. 执行操作后的变量值
- 2012. 数组美丽值求和
- 2013. 检测正方形 #medium
    - 要求实现一个类, 可以计算在平面内的轴对齐正方形数量. 实现操作: 1) 在平面上加一个点; 2) 查询, 给定一个位置, 计算其与平面上其他三个点构成正方形的数量.
    - 思路: #枚举 匹配边
        - 主要是查询: 对于给定的位置 (x1, y1), 我们可以将其与同一列中 x2 进行匹配, 这样我们确定了正方形的一条边, 可能的组合直接往左右两侧尝试, 计数即可.
        - 具体实现上, 可以用 `self.x2ys = defaultdict(Counter)` 统计每个单元格被加入的点数.
- 2014. 重复 K 次的最长子序列 #hard
    - 给定一个长度为n的字符串, 对于一个给定的整数 k, 要求从中找到最长的字符串 sub, 使得 sub * k 是原字符串的子串.
    - 约束: 2 <= k <= 2000, 而字符串长度 2 <= n < k * 8
    - 思路1: #枚举排列
        - 注意这里的数据特性: 由于字符串长度小于 `k * 8`, 而我们要的目标串重复度为 k. **因此可能出现的字符最多只有7个**.
        - 因此, 可以枚举所有的目标字符 (从长到短, 根据字典序从大到小), 然后判断是否满足条件即可.
        - Note: 下面第一个是我自己写的, 极为冗长; 第二个是 [here](https://leetcode.cn/problems/longest-subsequence-repeated-k-times/solution/zui-jian-ji-yi-dong-de-fang-fa-li-yong-z-hay1/) 利用了 1) combinations函数; 2) iter+in + all 判断子序列是否包含的神奇用法(替代双指针), 极为优雅.
    - 另外, 手动 #枚举排列 参见 [灵神](https://leetcode.cn/problems/longest-subsequence-repeated-k-times/solution/mei-ju-pai-lie-zi-xu-lie-pi-pei-by-endle-oi2h/) #TODO


### 260

- 2016. 增量元素之间的最大差值
- 2017. 网格游戏
    - 给定一个 2 x n 的网格, 每个格子有一些分数; 两人只能向右或向下从左上角走到右下角. 第一个人的目标是让第二个人剩余可以吃到的分数最小, 求最小分数.
    - 遍历. 注意 **分析边界**
        - 首先分别计算上下两行从右往左和从左往右的累计和, 在前后加两个哨兵简化判断. 因此 up,down 的长度为 n+1
        - 然后, 假设第一个人从第i个位置往下走(从1开始), 则第二人可以得到的分数为 上半部分的 i+1,...,n, 或者下半部分的 1,...,i-1
        - 对应到这里的两个累计和, 分别是 up[i+1], down[i]. 因此更新 `res = min(res, max(up[i+1], down[i]))`
        - 显然遍历范围为 `range(0, n)`
- 2018. 判断单词是否能放入填字游戏内
    - 给定一个网格, 三种情况: ' ' 表示为空, '#' 表示无法仿制, 还可能已经填入字母.
    - 要求判断一个单词是否能放入填字游戏内. 条件: 1. 方向 上下左右都可(可以从右往左); 2. 边界上不能为空或其他字母, 也即只能是 '#' 或者网格的边界; 3. 字母匹配.
    - 重点: **条件和边界判断**
        - 自己的实现比较乱, 定义了一系列的函数, 贵在比较清楚;
        - 然后又抄了 [here](https://leetcode-cn.com/problems/check-if-word-can-be-placed-in-crossword/solution/mei-ju-liang-ge-zhi-jian-de-zi-fu-by-end-pjq1/) 的解法, 思维难度上大了些. 需要注意, go和Python 中, **在循环内部对于循环变量修改是不同的**, Python中修改不会影响结果! 而go中则是可以进行赋值的.
- 2019. 解出数学表达式的学生分数
    - 给一个只有 +* 运算和 0~9 数字的表达式, 对于不同的答案赋予分数. 1. 正确为5, 2. 因为运算顺序导致的错误, 分数为2, 3. 其他0分.
    - 因此, 核心问题是 遍历所有运算顺序, 给出所有可能的结果.
    - 思路一: **分治 + 记忆化**
        - 利用递归实现分治. 结合 lru_cache 实现. 由于这里的所有数字和运算符都是一个字符的, 解析起来非常方便 (表达式长度一定为奇数).
        - 复杂度分析
            - 注意到, 这里随意更换运算顺序, 至少是一个指数级别的复杂度!
        - 例如对于表达式 `"4+8*8+8+8*8+4*4+8*4+8*8+8*8+8"`, 其不同答案的数量可以达到 `86301`; 直接排列组合在 LC上会超时.
            - 题目中给出了限制 0 <= answers[i] <= 1000 (正确答案在1000以下), 因此可以对于两侧给出的答案进行过滤, 这样不同答案的数量最多只有 `141`. —— 剪枝

### 261

- 2027. 转换字符串的最少操作次数
- 2028. 找出缺失的观测数据
- 2029. 石子游戏 IX #medium #博弈论
    - 有一组数字, AB依次取数字, A先手. 胜利条件:
        - 若两人取的数字之和可以被3整除, 则A获胜.
        - 除此之外, 若数字全部被取走A还未获胜, 则B获胜.
    - 一月的每日一题做过了, 但还是debug了挺久. 这里记录更为 naive 的思路
    - 思路: 模拟判断
        - 显然, 可以将数字根据除3的余数分成三类. 能够被3整除的数字可以起到「交换」的作用.
        - 先不考虑整除的数字, 剩余的两类地位是等价的. 例如, 在数字数量足够的情况下, 两人的最优序列形如 `112121...`. 注意到, **B所取的数字都是一样的**. 一下根据数量分类讨论 A 的胜利与否
            - 计两类数字的数量为 cmin, cmax; 方便起见假设1的数量更少
            - 若 cmin=0 (所给的数字数量 >0), 则无论是 cmax=2时B取完数字, 还是 cmax>=3 时A取数字后总和能够被3整除, 均为 False;
            - 若 cmin=1, A取 `1` 之后, B只能取2, 因此 True;
            - 若 cmin=2, AB取完 `112` 之后, B只能取2, 因此 True;
            - 若 cmin<=3, 胜利条件是 `112121...2` 之后, B只能取2, 因此数量条件时 `count[2] >= count[1]`, 也即 cmax>=cmin, 始终成立, 因此 True.
            - 综上所述, 官答给了一个更好的总结: **A的策略始终为取数量较少的那类数字**; 只要cmin>= 均为 True
        - 考虑可以被3整除的数字的影响: 当数量为偶数时不影响; 以下分析数量为奇数时:
            - 这一情况下, 相当于B获得了一次「换手」的机会.
            - 对于 cmin=0,1,2 进行讨论, 易知此时A均为 False;
            - A获胜的条件只可能为 `221021...2` (这里0表示B换手, 可知在哪个位置换手不影响AB所取的数字数量) 之后, B只能取1, 因此数量条件为 `count[2] - count[1] >= 3`. 也即 `cmax-cmin >= 3` 注意允许一次「换手」之后, A的最后策略变为取数量较多的那一类数字.
- 2030. 含特定字母的最小子序列 #单调栈 #hard #题型
    - 给定一个字符串s要求找到一个长度为k的子序列 (不要求连续), 使得: 1) 其中包含至少 repetition 个特定字符 letter; 2) 子序列字典序最小.
    - 关联: 0316. 去除重复字母; 另有基本题型「求长为 k 的字典序最小子序列」
    - 本题的限制包括 1) 子序列长度为 k; 2) 子序列中包含至少 repetition 个特定字符 letter.
    - 思路: 单调栈, 注意判断这些限制条件!
    - 单调栈相关问题思路:
        - 注意空栈 pop 的错误;
        - 限制子序列长度为 k: 1) 在push的时候判断时候超过限制; 2) pop时判断剩余的是否够, 即使 break;
        - 限制栈内元素数量 (比如要求ch的数量至少为repetition): 1) pop的时候检查剩余是否够; 2) 另外需要检查, 若栈内元素不足以放剩余的ch (repetition-countInStack), 则需要push.

### 262

- 2032. 至少在两个数组中出现的值
- 2033. 获取单值网格的最小操作数 #medium #题型
    - 给定一个数组, 每次操作可以对于其中的每个元素加减x, 要求使得所有元素相同的最小操作数.
    - 思路: #中位数
        - 注意, 这里不应该算mean, 而是中位数!!
        - 考虑一个反例: [1,1,1,1,100] 将小元素移动到mean的成本要高于移动较大值.
        - 中位数的逻辑在于, 每修改一次target都会对于所有的元素产生影响: 要么都加x, 要么都减x. 因此要将左右元素数量均衡.
        - from [here](https://leetcode.cn/problems/minimum-operations-to-make-a-uni-value-grid/solution/zhong-wei-shu-by-endlesscheng-p0vj/): 假设要让所有元素均为 y，设小于 y 的元素有 p 个，大于 y 的元素有 q 个.
            - 则 y 每增加一个 x, 都会使得操作数增加 p - q; (或者说, 每减少 x, 都会使得操作数减少 q - p). 因此取最小值的条件是 `p=q`.
- 2034. 股票价格波动 #medium #题型
    - (timestamp, price) 定义股票价格, 进来的timestamp是乱序的. 注意, **价格可能出现错误, 假设后到的是对于该时刻价格的修正**.
    - 要求实现一个类, 有操作
        - int current() 返回股票 最新价格.
            - 这个比较简单, 维护一个最大时间戳即可
        - void update(int timestamp, int price) 在时间点 timestamp 更新股票价格为 price.
            - 实现更新, 主体逻辑
        - int maximum() 返回股票 最高价格 (相应的还有最低价格)
            - 本题的特殊点即在于有修正错误值的操作, 因为需要用一定的数据结构来存储这一信息
    - 每日一题做过了, 这里再记录一下思路:
    - 时间戳到价格的存储肯定用一个map, 关键在于如何实现更新操作?
    - 思路1: #有序集合 为了快速得到最大最小值, 显然可以维护一个有序结构. 注意: **有序集合的插入(更新)和最大最小查询复杂度均为 `O(log(n))`**
        - 官答用了 SortedList. 尝试了用 slice 语法实现更新, 发现 O(n) 的复杂度还是会超时.
    - 思路2: 最大最小的查询, 另外的一种思路自然是 #堆 结构.
        - 这里多了数据可能无效这一限制, 则可以将 (price, timestamp) 当做一个元素, 从堆顶取出元素的时候, 只需要在 priceMap 中查询数据是否仍有效即可.
        - 这样在没有太多错误数据情况下, 查询的时间复杂度为 `O(1)`
    - [here](https://leetcode.cn/problems/stock-price-fluctuation/solution/gu-piao-jie-ge-bo-dong-by-leetcode-solut-rwrb/)
- 2035. 将数组分成两个数组并最小化数组和的差 #hard #题型
    - 将长度为 2n 的数组分成等长的两部分, 要求两个数组和相差最小.
    - 复杂度: n<=15
    - 思路: #折半枚举 +排序+ #二分
        - 这里用的思路是 #折半枚举. 具体而言, 本题需要从 2n个数字从取 n个. 折半枚举的思路是分别从左侧的一半和右侧的一般数组中取 i, n-i 个.
        - 计算复杂度: 直接枚举的复杂度为 `math.comb(2n, n)`; 折半枚举每一边的复杂度为 `O(2**n)`. 例如在 n=15 时差了好几个数量级
        - 用数组(集合)记录在left中取i个数字可能得到的和, 并排序; 然后在右侧枚举取n-i个数字, 两者匹配计算.
        - [here](https://leetcode.cn/problems/partition-array-into-two-arrays-to-minimize-sum-difference/solution/zhe-ban-mei-ju-pai-xu-er-fen-by-endlessc-04fn/)
    - 关联: 1755.最接近目标值的子序列和; 0805.数组的均值分割; 0416.分割等和子集; 0494.目标和 见 [总结](https://leetcode.cn/problems/closest-subsequence-sum/solution/by-mountain-ocean-1s0v/)

### 263

- 2042. 检查句子中的数字是否递增
- 2043. 简易银行系统
- 2044. 统计按位或能得到最大值的子集数目 #medium #题型
    - 给定一组数字, 将它们依次 「按位或」 得到一个最大值 maxNum, 现要求 list 的所有子集中, 这些集合中的元素按位或可以得到该 maxNum 的组合数量.
    - 复杂度: 数组长度 n<=16
    - 思路1: 暴力遍历 #二进制枚举. 时间复杂度: O(2^n * n). 第二个因子n是指需要对于数组元素进行按位或操作.
        - 之前想多了, 考虑到本题的数组长度有限, 暴力枚举所有可能的组合就行
    - 思路2: 通过 #DFS 记录状态, 避免重复枚举
        - 在上面的思路中, 例如计算 (1,2,3) 位的or 与计算 (1,2,3,4) 位的or 是相互独立的, 因此有重复计算.
        - 可以采用DFS, 用空间来避免重复计算. `dfs(i, orVal)` 表示枚举第 i 个位置时的状态为 orVal.
    - 思路3: 利用 #DP 来记录状态
        - 用 dp[mask] 表示利用 mask 所表示的那些数字的 or 和
        - 如何利用之前的数来帮助计算? 我们可以将 mask 分解成两部分然后对这两个数计算或. 如何划分? 可以利用 **位运算得到一个数字最低位1的位置 lowbit**.
        - 例如, `6=0b0110` 的最低位为 `lowbit = 6 & -6 = 0b0010`, 因此,
        - 递推公式: `dp[mask] = dp[mask-lowbit] | nums[lowbitIdx]`
    - see [here](https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/solution/by-ac_oier-dos6/)
- 2045. 到达目的地的第二短时间
    - 一月的每日一题, BFS即可

### 264

- 2047. 句子中的有效单词数
    - 1月每日一题做过了, 要求的验证条件比较复杂.
- 2048. 下一个更大的数值平衡数
    - 定义「数值平衡数」为, 例如 3133, 包含了1个1, 3个3.
    - 现在给定一个数字, 要求返回比这个数字大的下一个数值平衡数.
    - 复杂度: 1e6
    - 思路1: 暴力遍历. 要test一个数字是否为平衡数是简单的. 由于数字范围不大, 可以直接暴力遍历.
    - 思路2: 整体的数量不多, 为了加速查询, 可以 #打表 预计算范围内的所有平衡数, 然后二分查找.
- 2049. 统计最高分的节点数目 #medium #题型
    - 有一棵二叉树, 定义一个节点的分数: 移除这个节点(和相邻边) 后, 其他部分节点数量的乘积.
    - 要求返回分数最大的节点的数量.
    - 思路1: #DFS
    - 对于一个节点, 先探索子节点包含的节点数量, 剩余部分的节点数量为 `n-1-nChild1-nChild2` (注意需要排除为 0 的情况), 然后计算乘积.
- 2050. 并行课程 III #hard #题型
    - 课程之间存在DAG依赖关系, 每个课程修习需要一定的月份, 前序依赖满足的情况下, 不同课程可以同时修习. 求完成所有可能的最小时间.
    - 复杂度: 节点/边数量 5e4,
    - 关联: 1857. 有向图中最大颜色值
    - 思路1: #拓扑排序 在遍历的过程中记录每个节点的timeLimit, 这样, 遍历每一条边的时候, 可以更新 `timeLimit[v]` 为 max(timeLimit[v], timeLimie[u]+time[v])`

### 265

- 2057. 值相等的最小索引
- 2058. 找出临界点之间的最小和最大距离 #medium #链表
    - 给定一个链表, 定义关键点为局部(严格的)极小/极大值, 要求返回这些关键点之间距离的最小和最大值.
    - 例如, head = [5,3,1,2,5,1,2] 这一链表的关键点位置在 2,4,5, 因此返回 [1,3]
    - 思路1: 模拟遍历
        - 自己的思路是每次仅关注到当前遍历的节点, 因此需要记录上一个节点的值, 以及上一个节点与当前节点的大小比较.
        - 而 [answer](https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/solution/zhao-chu-lin-jie-dian-zhi-jian-de-zui-xi-b08v/) 中, 使用 `cur.next.next.val` 来获取连续三个节点的值, 更为方便, 而不需要记录历史信息. 从代码上更为简洁.
- 2059. 转化数字的最小运算数 #medium
    - 给定一组数字nums, 要求将 start 转为 goal. 每一次操作可以从nums中选择一个与start进行 +/-/^ 操作, 每个nums中的数字可以用任意次. 问最小操作数.
    - 限制: 0 <= x <= 1000. 当操作超过这一范围后, 无法再进行操作 (goal可以超过这一范围).
    - 思路1: #BFS 将每一次允许的操作看作是对于当前数字/点的转移边. 因此建模为可达性问题, 用BFS求解.
        - 技巧: operator 包
- 2060. 同源字符串检测 #hard
    - 定义一种压缩字母字符串的方案: 类似将 "internationalization" 简写为 "i18n". 也即, 将整个字符串分解成若干部分, 某些部分用其长度来表示.
    - 现给定两个压缩后的字符串, 要求判断它们是否可能同源.
    - 复杂度: s1,s2 的长度限制 40, 最多出现的连续数字为 3.
    - 思路1: DFS + 分类讨论
        - from [here](https://leetcode.cn/problems/check-if-an-original-string-exists-given-two-encoded-strings/solution/ji-yi-hua-sou-suo-by-endlesscheng-ll3r/)
        - 整体是采用DFS. 分类准则: dfs[i,j,d] 表示用 s1[:i] 和 s2[:j] 子串 (部分匹配成功), 并且前者长度 - 后者长度的差值为 d.
            - 注意这里的 d!=0 的情况出现在, 采用了数字进行匹配, 还有剩余. (因为两者都是字母的情况下不会有剩余)
            - 终止条件: `i==n and j==m and d==0`
            - 如何检查冲突? 当 d==0 时, 若 s1[i], s2[j] 都是字母并且不相等, 则匹配失败.
            - 如何避免重复访问? 例如, 若两个压缩字符串的前缀均为 `a111a111xxx`, 在匹配到位置8的时候, dfs[8,8,0] 会出现很多次. 因此, 用cache记录 (i,j,d) 以避免重复访问.
        - 总结一下: 分类讨论的优先级是: 1) 若 d==0 且待匹配的都是字母, 则将 i, j 同时向后一位; 2) 否则, 匹配较短的字符串 (d>=0, d<=0) 这里取等号, 是为了处理 d==0 并且 i,j 位置为一个数字一个字母的情况. 3)在匹配较短序列的时候, 基于字母和数字进行分类讨论.
        - [官答](https://leetcode.cn/problems/check-if-an-original-string-exists-given-two-encoded-strings/solution/tong-yuan-zi-fu-chuan-jian-ce-by-leetcod-mwva/) 用了DP来理解, 思路是一样的, 并进行了复杂性估计.

### 266

- 2062. 统计字符串中的元音子字符串 #easy #题型
    - 要求统计连续子序列的数量. 条件为: 1) 所有元素为元音字符 2) 包含所有aeiou五个元素.
    - 思路1: 暴力检索. 时间复杂度 O(n^2)
        - 技巧: 这里要检查数组包括的所有元素, 天然就是 #set 问题.
    - 思路2: #双指针.
        - 先用re抽取所有仅由元音组成的子串, 对于每一个符合要求的子串, 双指针遍历.
        - 具体而言, 存储左右指针内包含的元音数量. 遍历有指针的过程中, 维护左指针使得「左右指针包含的包含所有元音的最短序列」, 这样, 以右指针结尾的包含左右元音的子串数量为 left+1.
- 2063. 所有子字符串中的元音
- 2064. 分配给商店的最多商品的最小值 #medium #二分
    - 将一组商品分配给n家商店, 每家店只能有一种商品 (也可以没有商品). 要求一种最「平均」的分配方式, 也即这些店中的商品数量最大值达到最小.
    - 限制: 商品种类 m = 1e5, 每一种的最大数量 a = 1e5
    - 思路1: #二分查找 每次检查的复杂度为 m, 二分的范围最大为 a, 因此时间复杂度为 O(m*log(a)).
        - 左右边界: sum(quantities)/n), quantities[-1]+1
        - 注意二分的边界: 这里的题型是「满足条件的最小值」. 因此不满足时缩小左边界 `left = mid+1`, 最后返回 `left`.
    - 说明: 出了手动写二分算法之外, [here](https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/solution/er-fen-da-an-by-endlesscheng-aape/)
        - 直接调用了 go 中的 `sort.Search` 函数, 简化了代码.
        - 类似的, 在 Python 中可采用 `bisect.bisect_left`, 语法有所不同, 思路是一样的 (其实都是在一个range数组中二分查找).
- 2065. 最大化一张图中的路径价值 #hard #DFS
    - 给定带权图, 每个节点有分数. 在 maxTime 时限下, 从0回到0, 找到最大分数的路径. 注意, 节点可以重复访问
    - 限制: 每个节点的相连边最多为4; 由于 `10 <= time_j, maxTime <= 100`, 所以最大搜索深度为 10.
    - 思路1: 暴力DFS, 注意是可重复访问的
        - 本题的特殊之处在于节点可重复访问.
        - 题中对于图有着较多的限制, 采用最暴力的 DFS, `4**10` 也不超时.

### 267

- 2073. 买票需要的时间 #easy
    - 给定一个队列表示每个人要买的票的数量. 购票规则是, 每个人只能购买一张, 因此购买后只能回到队尾重新排队. 要求第k个人买到所需的所有票的时间
- 2074. 反转偶数长度组的节点 #medium #链表 #题型
    - 给定一个链表, 将其分割成 1,2,3... 长的子序列 (最后一个剩余的长度可以不符合). 对于这些子序列, 反转其中长度为偶数的.
    - 总结: 对于链表题型还不太熟悉; 重点在于总结基本题型, 而非纠结于细枝末节的调试.
    - 思路1: 暴力模拟. 完全按照 #链表 的思路来写
        - 救命, 这题写了两个小时.
        - 思路是实现一个翻转 [i,j] 范围内节点的函数 (同时要求连上 i-1, j+1); 然后遍历
        - 然而如何判断最后剩余的长度是否为偶数呢? 自己的思路尝试用一次遍历用指针记录, 但是极为繁琐 (还不可行)
    - 思路2: 针对第二个问题, 放弃了整合在一次遍历的想法. 而是通过两次遍历: 第一次判断剩余是否为偶数. 然后在确实下一个目标序列的奇偶性的前提下进行翻转
        - 总体来看, 只需要维护 pre, cur 两个指针即可. 1) 若当前长度 i 为奇数, 将两者都前进i步即可; 2) 若为偶数, 则需要实现「将从cur开始的i个节点进行翻转」, 见下代码.
        - [官方](https://leetcode.cn/problems/reverse-nodes-in-even-length-groups/solution/fan-zhuan-ou-shu-chang-du-zu-de-jie-dian-owra/)
- 2075. 解码斜向换位密码 #medium
    - 定义一种加密方案: 给定一个固定行数 rows 的矩阵 (理解为「加密纸条」), 将originalText按照 主对角线、右上方的次对角线... 的规律进行填充. (填充保证右下角是填了的) 这样得到的encodedText是将这一矩阵一行一行拼接得到的序列.
    - 思路1: #模拟 暴力求解
        - 直接叫 encodedText 展开为矩阵, 然后斜方向依次即可取回原字符串
        - 对于加密纸条中未填充的部分, 去除末尾的空格即可
- 2076. 处理含限制条件的好友请求 #hard #题型
    - 有n个用户, 给定一组约束 restrictions, 每一个约束 (u,v) 表示两者不能联通; 对于一系列好友请求 requests, 判断他们能否建立关系(连边).
    - 思路1: #并查集 的基础上利用 #哈希表 记录能否成为关系
        - 判断是否联通显然可以用并查集框架. 关键是如何判断是否违反了约束? 可以将所有的约束条件记录在根节点上
        - 因此, 对于每一个查询, 先找 (u,v) 的根节点, 基于 `cant[rootu][rootv]` (矩阵形式的哈希表) 的值判断是否违反了约束.
        - 若没有, 则请求成功. 然后合并集合 `father[rootu] = rootv` 并将 cant[rootu] 中所记录的约束条件都记录在节点 rootv 上.
        - 参见 [here](https://leetcode.cn/problems/process-restricted-friend-requests/solution/bing-cha-ji-by-endlesscheng-8ipg/)


### 268

- 2078. 两栋颜色不同且距离最远的房子
- 2079. 给植物浇水
    - 模拟法
- 2080. 区间内查询数字的频率 `中`
    - 需求是查询子数组 arr[left...right] 中 value 的 频率; 考虑到查询数量可能较大, 因此设计一个数据结构存储数据分布信息
    - 解法: 用 map 保存数字所出现的位置列表, 从而查询时候可以用**二分查找**.
        - Python 可以直接用 `bisect.bisect` 好方便!
- 2081. k 镜像数字的和 `难`
    - 找到前 n 个, 在 10进制 和k进制下均为回文数的数字, 返回其最大值
    - 注意题目要求, 2 <= k <= 9, 1 <= n <= 30 当k和n均取较大值时会超时(约10**10量级); 因此重点是如何所见搜索空间.
        - 由于是回文数, 因此只需遍历前半部分即可, 注意可生成奇数或偶数长度的, 例如 1234 -> 1234321 或 12344321;
        - 另外, 每次遍历 [1,9], [10,99]... 的数字, 对于j位十进制数, 可分别生成 2j-1, 2j 位十进制数

### 269

- 2089. 找出数组排序后的目标下标
- 2090. 半径为 k 的子数组平均值
- 2091. 从数组中移除最大值和最小值
    - 滑动平均
- 2092. 找出知晓秘密的所有专家 `难`
    - 包括 (x, y, time) 的三元组, 若 x 和 y 中某一个知道了「秘密」, 则会进行传播; 要求最后知道「秘密」的所有人
    - 解法一: **构建图**, 传播
        - 按照时间排序, 难点在于判断同一时间的多人传播关系 —— 简单的方案是构建图
        - 解法的具体实现: 利用 edges 字典记录连接关系, 建立图后, 利用 一个 `deque` 记录所有激活节点, 迭代直至队列空
    - 解法二: **并查集**

### 270

- 2094. 找出 3 位偶数
    - 给你一个整数数组, 找出所有的三位偶数(也即要求首位不为 0), 顺序输出(直接排序即可)
    - 简单题 (也可根据提示的范围知道不复杂) 别想太多, 直接暴力遍历即可; 为了避免重复可以用 set()
- 2095. 删除链表的中间节点 `中`
    - 长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始）
    - 解法一: 快慢指针即可, 可以在最开始加上一个「哨兵」
- 2096. 从二叉树一个节点到另一个节点每一步的方向 `中`
    - 找到二叉树两个节点之间的路径
    - 解法一: 直接 DFS 找到两个点从 root 出发的路径, 除去公共路径即可
- 2097. 合法重新排列数对 `难`
    - 给定 pairs(表示区间), 重新排列要求排列后每个区间首尾数字相同; 核心在于理解「[欧拉通路](https://oi-wiki.org/graph/euler/)」, 将问题转换
    - `Hierholzer 算法`: 首先很容易想到, 若仅为「**半欧拉图**」(即存在两个奇数度数节点), 可以确定开始和结束的数字, 否则为「欧拉图」随便选择初始数字/节点即可.
        - 若随便选择一条边, 则可能走到「死路」, 注意此时剩下的图构成了一个「欧拉图」 —— 可以用DFS探索
        - 因此, 1. 每次选择一条边, 在图上删去这条边; 2. 递归; 3. 记录这条边. 注意这里的边是在遍历之后加入记录的 (也即是逆序的, 最后要再逆序输出), 这样可以保证可能漏过的「欧拉图」在此之前被遍历.
    - 参见 「332. 重新安排行程」「753. 破解保险箱」
    - 332 重新安排行程, `难`
        - 区别在于, 需要返回所有的通路中, 字母排序最小的那一个 —— 也即, 每次应该选择较小的那一个节点
        - [solution](https://leetcode-cn.com/problems/reconstruct-itinerary/solution/zhong-xin-an-pai-xing-cheng-by-leetcode-solution/) 非常清楚
    - 753. 破解保险箱, `难`
        - 密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。要求返回一个最短字符串, 其子字符串包括所有可能的密码.
        - 关键在于将其转化为一个规范的欧拉通路问题: see [here](https://leetcode-cn.com/problems/cracking-the-safe/solution/po-jie-bao-xian-xiang-by-leetcode-solution/) 官方解答有点fancy
        - 解法: 转换为**欧拉通路问题**
            - 简言之, 要求的是 n 长序列, 都可将其看成 n-1长序列加上 0~k-1 的数字. 因此, 可以构建一个图, 节点为所有的 n-1长序列, 其第i个出边就是在最后加上数字i并去除第一位数字, 跳到相应的节点上.
            - 例如, 节点u的第v的出边就跳转到数值为 u*k % (k**(n-1)) + v 的节点上.
            - 可知, 这样构造的图, 每个节点都有 k条出边和入边, 共可代表 $k^{n-1} * k$ 个不同的数字, 正好对应了所有可能的密码.
            - 显然, 这张图是欧拉图, 并且可基于一个欧拉回路对应一个题目所要求的字符串.

### 271

- 2105. 给植物浇水 II
    - 模拟法即可
- 2106. 摘水果 `难`
    - 在一个无限的 x 坐标轴上, 分布一定的水果, 给定 startPos 和可以移动的步数 k, 计算可以拿到的最大数量
    - 题型: 其实就是给定一个累加和, 探索所有可能的范围内的最大值; 问题在于如何在离散存储的数组中找到对应的元素
        - 存储方式: 例如对 `[[2,8],[6,3],[8,6]]` 水果分布而言, 记录位置 `pos=[-Inf, 2,6,8]` 和 累计和 `[0,8,11,17]`
        - **二分查找**. 要注意 **边界情况**, 左边应该是 `bisect.bisect_left`, 而右边是 `bisect.bisect_right`, 注意函数返回的是待插入的 index, 因此最终能采集的水果数量为 `cumsum[rindex-1] - cumsum[lindex-1]`
        - 错误记录: 注意, 先往左边走和先往右边走所能达到的范围是不一样的! 因此两侧的情况都应该考虑到.

### 272

- 2110. 股票平滑下跌阶段的数目
    - 一次遍历即可
- 2111. 使数组 K 递增的最少操作次数 `难`
    - 如果对于每个满足 `k <= i <= n-1` 的下标 i ，都有 `arr[i-k] <= arr[i]` ，那么我们称 arr 是 K 递增 的。
    - 给定一个数组和 k,要求找到使得这个数组 k递增的最小修改次数.
    - 问题可转化为: 寻找一个数组中的最长递增序列, 参见 300 题 [最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/)
        - 思路 1: DP, 定义 `dp[i]` 为 第 i 个数字结尾的最长上升子序列的长度, 注意 第 i 个元素必须被选中; 递推公式 `dp[i] = max(dp[j]) + 1`, 其中的 j 要求 `nums[j]<=nums[i]`
            - 时间复杂度 $O(n^2)$
        - 方法二：贪心 + 二分查找
            - 维护一个数组 `d[i]` ，表示**长度为 i 的最长上升子序列的末尾元素的最小值**, 用 len 记录目前最长上升子序列的长度. 注意到数组 d 是单调递增的
            - 我们依次遍历数组 nums 中的每个元素，并更新数组 d 和 len 的值。如果 `nums[i]>d[len]` 则更新 `len = len + 1`，否则在 `d[1…len]`中找满足 `d[i−1]<nums[j]<d[i]` 的下标 i，并更新 `d[i]=nums[j]`。
            - 由于是递增数列, 可以用二分搜索
            - 时间复杂度 $O(n log(n))$

### 273

- 2120. 执行所有后缀指令
    - 模拟机器人动作即可
- 2121. 相同元素的间隔之和 `中`
    - 给定一个数组, 计算其中相同元素所在的 index 之差, 返回所有这些距离的和
    - 用一个 defaultdict(list) 记录各个元素出现的位置.
    - 问题转化为对于一个数字出现的位置, 计算各个位置的 dist 和.
        - 注意数据量, 直接暴力遍历复杂度为 $O(n^2)$ 会超时
        - 思路1: 观察相邻两个元素相差的(子距离数量), 可得递推公式 `dp[i+1] = dp[i] -(n-2i-2) * (arr[i-1]-arr[i])`
        - 思路2: 计算 cumsum, 则 i 处的距离和为 `(cumsum[-1]-cumsum[i] - arr[i]*(n-1-i)) + (cumsum[i]-cumsum[0] - arr[0]*i)`
- 2122. 还原原数组 `难`
    - 就是对于一个数组 arr, 用一个正整数 k, 分别生成两个数组, `lower[i] = arr[i] - k, higher[i] = arr[i] + k`. 要求给定这两个数组的混合, 还原 arr
    - 注意看约束条件, 数组大小最多为 `1000` 所以暴力搜索即可, 题目只是比较繁琐
        - sort, 得到可能的 k
        - 用 `indexRecord` 记录每个数字对应的位置
        - 关键在判断一个 k 是否满足条件. 这里用了一个 `used` 记录每个所对应的元素所在位置, 遍历 nums 后, 若 `sum(used) == n` 则说明 k 满足条件
    - see [here](https://leetcode-cn.com/problems/recover-the-original-array/solution/huan-yuan-yuan-shu-zu-by-leetcode-soluti-nizi/)

### 274

- 5970. 参加会议的最多员工数 #hard #题型 #基环树 #hardhard
    - 每个人只有一个喜欢的人, 要求安排坐圆桌, 每个人左右要有他喜欢的人, 最大的可安排人数
    - 比较容易想到, 问题主要转化为求这样的有向图上的最大环,
        - **特殊情况** 是两个互相喜欢的人, 他们相互满足了要求, 因此左右可以有一条「喜欢人的链」, 并且左右的人都是满足的; 因此, 这种大小为 2 的环一个桌上可以安排多个
        - 参见 [灵神](https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/solution/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/), 这种图叫做 内向 #基环树 (pseudotree)
    - 所以核心问题在于如何在 pseudotree 中找环, 比赛中的尝试没有想到如何「**剪枝**」超时了; 实际上, 可以通过一次 #拓扑排序 剪掉所有的分支 (最后留在图上的点的度数均为 1)
        - 具体实现上, 维护一个入度为 0 的队列, 对其喜欢的人的入度 -1, 如果减到了 0 则继续加入队列;
        - 这样, **拓扑排序后最终剩下的点都是成环的** (入度为 1).

### 275

- 5976. 检查是否每一行每一列都包含全部整数
- 5977. 最少交换次数来组合所有的 1 II
    - 滑动平均
- 5978. 统计追加字母可以获得的单词数
    - 注意审题
- 5979. 全部开花的最早一天
    - 两个数组, 分别是 播种 和 开花 所需的时间, 要求使得所有花都开放的最小时间
    - 题目给了干扰: 将一种花分成两次播种没有意义, 因为两者总的播种时间是一样的, 因此在过程中两种花都不会提早开花.
    - 于是可以化简为, 给依次播种的花进行排序
    - 可知, 总的播种时间是一定的, 目标在于减少开花所需时间. 因此每次根据开花所需时间排序, 选择需要最长时间的那种即可.

### 276

- 5980. 将字符串拆分为若干长度为 k 的组
- 5194. 得到目标值的最少行动次数
    - 给定一个目标数, 从 1 开始 +1, *2 两种操作, 限定了倍乘的次数 maxDoubles
    - 贪心, 从 target 往下 /2
- 5982. 解决智力问题
    - 给定一系列的题目, questions[i] = [pointsi, brainpoweri], 你选择做某一题的代价是只能跳过后面 brainpower 题
    - DP, 从后往前, 记录从该位置往后的最大解, 递推公式 `dp[i] = max([dp[i+1], point+dp[i+skip+1]])`
- 5983. 同时运行 N 台电脑的最长时间
    - 给定一组电池 batteries, 每个电池可以给一台电脑运行一定的时间. 可以把一个电池替换给不同的电脑, 要求让所有电脑同时运行的最长时间
    - 这里的限制条件为电量最大的 n 个电池, 小的电池看作对它们的补充.
    - 注意到: 一个电池的电量可以以**任意的比例**分到若干块电池上.
    - 因此, 可以将最大的 n 个电池看成一个「阶梯」, 其余的小电池理解为在这个池子里注水, 求高度

### 277

- 2148. 元素计数
- 2149. 按符号重排数组
- 2150. 找出数组中的所有孤独数字
- 2151. 基于陈述统计最多好人数 #hard
    - 两种角色: 好人只说真话, 坏人可能真也可能假
    - 给定一个矩阵表示每个人的陈述 (0,1,2 分别表示 坏人, 好人, 未判断), 要求计算好人最多可能数量
    - 注意到, **此题中坏人的陈述毫无信息量**!
    - 方法一：使用状态压缩枚举所有可能的情况
        - [here](https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/solution/ji-yu-chen-shu-tong-ji-zui-duo-hao-ren-s-lfn9/)
        - 用一个长度为 n 的二进制数 mask 表示好人坏人情况, 针对 mask 所表示的好人坏人分布, 判断是否合法
            - 冲突的情况只会出现在好人 i 的陈述中 (mask[i]=1)
            - 当 `s[i][j]=0 and mask[j]=1`, 或 `s[i][j]=1 and mask[j]=0` 时冲突
        - 实现一个 `check(mask)` 函数判断是否冲突
        - check 复杂度最大为 n^2, 枚举复杂度为 2^n, 因此总体复杂度为 `n^2 2^n`, 这里用位运算所以比较快?
    - 方法二: 回溯
        - 暴力枚举每个人是好人或坏人, 注意剪枝!!

### 278

- 2154. 将找到的值乘以 2
- 2155. 分组得分最高的所有下标
- 5994. 查找给定哈希值的子串
    - 定义一个字符串的哈希值 `hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m`
    - 给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 `k` 的 子串 sub ，满足 `hash(sub, power, modulo) == hashValue` 。
    - 字符串长度为 e4, 如果暴力遍历, 当所要求的 k 数量级接近是复杂度是 e8, 会超时
    - 方法一: **滑动平均**, O(n)
        - 给出的哈希计算函数是一个等比求和数列，两者可以通过减去首元素，除以power再加上新元素的power的k-1次方计算。
        - 但是 **除法不满足取余的恒等性**。因此需要倒序，减去当前的值，乘以power再加上新元素的值。(乘法满足取余恒等)
        - 参见 [here](https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/cha-zhao-gei-ding-ha-xi-zhi-de-zi-chuan-fi8jd/)
- 2157. 字符串分组 #hard
    - 每个字符串包括了一组不相同的字符 (比如 cde), 定义两个字符串「相连」: 其一可以通过 添加/删除/替换(替换成相同字符也可, 即包括相同字符集合的两字符串相连) 一个字符得到另一个字符串。
    - 定义组: 如果一个字符串与该组中的任一字符串相连，则这个字符串属于该组。
    - 给一组字符串, 计算有多少个不同的组, 以及最大组包括的字符串数量。
    - 方法一：状态压缩 + 广度优先搜索
        - 显然是求连通分量的数量, 问题在于如何构建图? 如果是两两计算复杂度为 O(n^2) 超时;
        - 像这类题, 可以从每一个节点出发, 构造其所有可能相连的边, 例如这里就是按照「相连」的定义, 增删或者替换所有可能的字符, 这样复杂度为 O(nD^2), 其中 D 为字符字典大小
        - 具体而言, 为了进行图遍历, 用一个 used 集合记录所有遍历过的节点, queue 来维护当前进行BFS, 对于所有的节点进行遍历.
        - 状态压缩: 如何表示一个(小写字母)字符集合? 01编码转化为数字以进行压缩. 这样的好处还有方便表示相连边, 参见 `get_adjacent`
        - 参见 [here](https://leetcode-cn.com/problems/groups-of-strings/solution/zi-fu-chuan-fen-zu-by-leetcode-solution-a8dr/)

### 279

- 6000. 对奇偶下标分别排序
- 6001. 重排数字的最小值
    - 给一个数字 (可能为负数), 重拍求最小值
- 6002. 设计位集 #medium
    - 能够快速实现 fix(设置某一位为1), unfix, flip(翻转每一位), add, one(至少一个非零), count(非零位数量) 操作
    - 尝试直接用列表存储, 超时了, 可能是 flip, add, one, count 复杂度较高
    - 优化为 位存储+一个变量intcount存储非零位数量, 从而优化时间复杂度; 可以重新看看**位运算**使用技巧
- 6003. 移除所有载有违禁货物车厢所需的最少时间
    - 一个 01 序列表示违禁物品, 前后移除一辆火车代价位 1, 移除中间的一辆代价为2, 求移除所有违禁货车最小代价
    - 思路一: 从左边和右边非别累加计算单面的最小代价, 加起来求最小 (其实就是在不同的点分割).
        - 注意 更新公式(DP): 当 `s[i+1]=='1'` 时 `dp[i+1] = min(dp[i]+2, i+1)`, 因为若从左边全部移除的代价是 i+1, 从中间取走的代价是 +2
        - 为了计算的方便在头部加一个 [0]; 注意到在点 i 处分割的总代价为 `dp1[i]+dp2[i+1]`, 正好错位加和. 参见 [here](https://leetcode-cn.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/solution/qian-hou-zhui-fen-jie-dp-by-endlesscheng-6u1b/)

### 280

- 6004. 得到 0 的操作数
- 6005. 使数组变成交替数组的最少操作数
    - `[2,1,2,1,2,1,2]` 的形式, 要求奇数和偶数位置的数字不同
    - 分别对于 nums[0::2] 和 nums[1::2] 计数, 注意边界情况 (`len(collections.Counter(nums[0::2])) == 1`)
- 6006. 拿出最少数目的魔法豆
    - 给定一组袋子, 要么拿空, 要求最后剩下来的非空袋子里的豆子数量相同
    - 排序, 想像成一个阶梯, 最后留下来的就是一个矩形; 转化为遍历求矩形最大面积
- 6007. 数组的最大与和
    - 有编号为 1,2,...,numSlot的篮子, 要求把一个长度为 n 的数组放入篮子中, 每个篮子最多放两个数字!
    - 定义放置的分数为, 数字和篮子编号与 `nums[i] & (assign[i]+1)`, 其中 assign 表示 第 i 个数字放在第 assign[i] 个篮子中
    - 方式一: 暴力回溯
        - 用一个 records 数组保存每个篮子中球的数量
        - 回溯函数 `dfs(idx, curSum, curMax)`, 遍历 idx 放置每一颗球

### 281

- 6012. 统计各位数字之和为偶数的整数个数
- 6013. 合并零之间的节点
- 6014. 构造限制重复的字符串
    - 给定一组字符, 要求构造字典序最大的字符串, 限制每个字符最多连续的次数.
    - 当两个字符串长度不同时, 先序比较前面部分, 仅当 min(a.length, b.length) 时算较长的字符串字典序较大.
    - 思路
        - 根据题意, 应该是按照字典序, 尽量把大字符连续放在前面, 之间插入一个次大字符即可, 即 bbbabbba... 这样的形式(repeatLimit=3)
        - 关键在构造方法:
            - 每次取最大字符, 后面添加一个次大字符即可! 终止条件是没有次大字符了.
            - `bbba` 这种形式为一次循环所构造的, 当 a 没有的时候即终止 (终止条件!)
- 6015. 统计可以被 K 整除的下标对数目
    - 给定一个数组 nums 和一个正整数 k, 返回满足条件的下标对 `(i, j)` 的数目, 要求 `nums[i] * nums[j] % k == 0`, 即两数之积能够被k整除.
    - 思路
        - 考虑 `n1*n2 % k == 0` 的条件: n1和n2 和 k 的最大公约数之积能被k整除, 即 `gcd(n1, k) * gcd(n2, k) % k == 0`
        - 由于 k 的因子是有限的, 就可以对于 nums 中的数字分组. (Counter)
        - 对于一个组, 其中的数字与k的最大公约数都是 n1, 假设组大小为 len1
            - 考虑两种情况: 1. 其他组中能够能够配合n1的数字个数为 len2, 则交互共有 `len1*len2` 个数字; 2. 若 `(n1*n1)%k == 0`, 即自身就满足条件, 组内组合数为 `C(2,len1) = len1*(len1-1)/2`
        - 累计. 为了避免重复, 对于因子从大到小排序, 每组都和后边的因子比较
        - 注意: 特殊情况是 k==1

### 282

- 6008. 统计包含给定前缀的字符串
- 6009. 使两字符串互为字母异位词的最少步骤数
- 6010. 完成旅途的最少时间
    - 给一组公交车运行一轮的用时: `time[i]` 表示第 `i` 辆公交车完成 一趟旅途 所需要花费的时间。要求计算所有公交车运行至少 totalTrips 圈所需的最少时间。
    - 思路: 二分查找
        - 对于运行时间排序, 在一定区间内二分查找最短时间
        - 初始化: 考虑左边界, 假设所有车运行一圈都为最小的那一辆, 则最短时间 T 需要满足 `T//min(time) * n >= totalTrips`, 则最小为`T = min(time) * math.ceil(totalTrips/n)`
        - 这里复习一下二分: 循环 `l < r`, 每次查找的 `mid = (l + r) // 2` 有可能为 l. 因此在检查条件后, 根据是否满足分别设置 `r = mid, l = mid + 1` 从而保证不会死循环.
        - 具体而言, 这里要求最小的满足条件的数字, 则可以: 每次检查成功收缩右边界, 令 `r = mid`; 失败则拓展左边界 `l = mid + 1`, 从下一个点开始搜索.
        - 算一下这里的时间复杂度: 假设搜索长度为 L, 每次检查有效性复杂度为 O(n), 则总体为 `O(n * log(L))`, 其中长度约为 `L=totalTrips/n * timeSpan`. 本题中, 变量数量级为 `time[i]=totalTrips=1e7, n=1e5`, 可以看到主要复杂度在 `O(n)`
- 6011. 完成比赛的最少时间
    - 给定一组轮胎, `tires[i] = [fi, ri]` 表示第 `i` 种轮胎如果连续使用，第 `x` 圈需要耗时 `fi * ri ** (x-1)` 秒。
    - 同时给你一个整数 `changeTime` 和一个整数 `numLaps` , 表示换轮胎的时间和总圈数. 要求最短用时.
    - 思路: DP
        - 对于dp[i], 考虑两种情况: 1. 用一种轮胎, 则用时为 `f * (r**laps -  1) / (r-1)` (等比数列); 2. 递推, 则用时为 `dp[i] + dp[i-j] + changeTime` (j = 1...i-1).
        - 注意对于第一种情况, 次题中 numLaps=1e3, len(tires)=1e5, 直接暴力会超时. 因此需要对每一轮次可能达到最短时间的 tires 进行筛选,
        - 这里用了简单的策略: 计算换一个轮胎跑一圈的最短用时 `min0 = min(i[0] for i in tires) + changeTime`, 如果此时继续用轮胎i `i[0]*(i[1]**(laps-1))>= min0` 则不需要考虑了.

### 283

- 6016. Excel 表中某个范围内的单元格
- 6017. 向数组中追加 K 个整数 #medium
    - 给一个数组, 请你向 `nums` 中追加 `k` 个 **未** 出现在 `nums` 中的、**互不相同** 的 **正** 整数，并使结果数组的元素和 **最小** 。
    - 思路一: 模拟. 遍历数组 nums, 并从 1开始递增 `inc` 表示下一个可能可以追加的数字, 累计数组中空的元素.
- 6018. 根据描述创建二叉树
- 6019. 替换数组中的非互质数
    - 对于数组定义一个操作: 任意两个相邻的非互质数 (最大公约数gcd != 1), 将它们替换为其最小公倍数 （Least Common Multiple，LCM）. 返回这样操作之后的数组.
    - 思路一: **栈模拟**
        - 一个数字只能和左右两边的数字合并, 并且 x,y,z 如果可以合并的话先后顺序无所谓. 因此可以合并一遍即可.
        - 因此可以用 **栈** 来进行模拟 —— 每次入栈后看它能消去到前面多少数字.
    - 第一时间应该想到 stack 的…… 不过自己写了一个函数, 尽量对于左右两边进行合并, 居然超时了? 复杂度应该是完全一样的...
    - 线性复杂度应该是没问题的, 还尝试了 `@lru_cache` 也过不了, 本地调试完全可以过 LC 不知道为啥不行.

### 284

- 6031. 找出数组中的所有 K 近邻下标
- 5203. 统计可以提取的工件
- 5227. K 次操作后最大化顶端元素
    - 给一个非空栈和可操作数量k, 要求返回执行这些操作后, 能够留在栈顶的最大值. (如果执行完 k 次操作以后，栈一定为空，请你返回 -1)
    - 两种操作: 1. 弹出栈顶元素; 2. 压入弹出的某一个元素.
    - 思路一: 讨论
        - 先考虑边界: 什么情况下最后栈为空? `len(nums)==1 and k%2==1`
        - 而在一般情况下, 对于k次操作, 我们可以在栈顶留下第 1,...,k-1 和 k+1 个元素 (从1开始). 需要对k和数组长度n的关系讨论.
        - 另外, 需要确保 nums[:k-1] 操作中 k-1 非负, 添加到边界条件中.
- 6032. 得到要求路径的最小带权子图
    - 给一张带权图, 给定三个点, 要求返回 **边权和最小** 的子图 (的边权和)，使得在这个子图中从 `src1` 和 `src2` 出发都可到达 `dest` 。如果这样的子图不存在，请返回 `-1` 。
    - 分析
        - 注意到, 双点出发求最短路径的情况, 可能出现共用一条路径的情况. (此时, 最小边权和为 `s1->u, s2->u, u->d` 三条路径之和, 而非 `s1->d, s2->d`). 需要判断这种情况出现的边界:
        - 简单判断, 假设两点的最短路径分别为 d1,d2, 则共用的路径长度不能超过 d1+d2.
        - 因此, 暴力来解, 可以先从 s1,s2 出发BFS, 然后(逆)从d出发进行长度约束为 d1+d2 的BFS.
        - 为了判断所有可能的中间节点, 需要记录正反向BFS过程中所有经过的点的路径长.
    - 思路一: BFS + 节点判断
        - 首先, 从src1和src2出发, 返回距离d和在这一范围内的节点集合(及其路径长); 分别用 dist1, dist2 两个map记录两个范围内所有点的距离.
        - 然后在逆图上进行长度 d1+d2 约束的BFS, 同样记录各个点的路径长 dist
        - 遍历三个字典交集, 取最短距离 `dist[u]+dist1[u]+dist2[u]`.

### 285

- 6027. 统计数组中峰和谷的数量
    - 首尾的不算, 相同数字算一个峰/谷. 例如 [2,4,1,1,6,5] 就有三个
    - 思路: 遍历, 模拟
- 6028. 统计道路上的碰撞次数
    - 给定一个字符串表示车辆方向. L, R, S 分别表示左右和停止 。每辆车移动时速度相同。相向碰撞 2分, 一个静止的1分; 碰撞后都静止; 求最后的分数。
    - 思路: 模拟. 注意一些边界讨论.
- 6029. 射箭比赛中的最大得分
    - 12个区域得分分别为 0...11; 如果 `ak >= bk` ，那么 Alice 得 `k` 分。如果 `ak < bk` ，则 Bob 得 `k` 分; 现在知道Alice的分布, 要求Bob得分最高的一种方式
    - 思路: 复杂度不高, 直接DFS即可
- 6030. 由单个字符重复的最长子字符串 #hard
    - 给定一个字符串和一组查询, 每次查询会将`queryIndices[i]` 的字符更新为 `queryCharacters[i]`, 要求返回每次查询后, 字符串中保留的最大重复字符长度
        - 例如 `s = "babacc", queryCharacters = "bcb", queryIndices = [1,3,3]`, 将返回 `[3,3,4]`
    - TODO: 线段树

### 286

- 5268. 找出两数组的不同
- 5236. 美化数组的最少删除数 #修改数组
    - 定义美丽数组: (1) 长度为偶数; (2) 2i, 2i+1 位的数字不相同. 空数组也符合
        - 要求: 将一组数组转为美丽数组, 最少删除的数字个数
    - 思路: 贪心. 每遇到 **约束对** 不满足的情况, 这两个数字必然是相同的, 随便删除一个即可.
        - 若出现 [..., 1,1,2,2,3,3, ...] 的情况, 不管是前面删除使得三组相同数字处于不同的约束对, 还是删除最前面的 1, 效果是一样的.
- 5253. 找到指定长度的回文数 #回文数 #进制
    - 要求得到长度为 l 的回文数中的第 k 个; 超出限制则返回 -1
    - 思路: 递归
        - 注意这里回文数数量限制有两种: (1) 内部回文数可以以0开始, (2) 回文数定义, 例如长度为3的最小回文数为 101. 可知, 长度为 1/2 的回文数数量为 9, 长度为 3/4 的回文数数量为 90; 内部回文数数量为 10, 100, 1000...
        - 因此, 实际上是一个「进制」问题, 可以用递归来解.
        - 需要注意: 题目中要求得到第 ith个回文数, 从1开始; 但是 **在进制的计算中, 必须应该从0开始**. 例如, 进制为10, 则要求得到第13个 (其实是12)回文数, 应该计算 `div(12, 10) = 1, 2`; 在本题中, 外部的数字从1开始, 因此需要再加上1, 也即 `222`
- 5269. 从栈中取出 K 个硬币的最大面值和 #hard #排列组合
    - 给定一组栈和可以取的硬币数量k, 要求取到的面值最大.
        - 例如给定 `piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7`, 最大应该为 706
        - 复杂度: 栈数量 n<=1000; 操作次数 k<=2000
    - 思路: 转化为 #背包问题 #DP
        - `dp[i][j]` 表示从前 i 个栈中取出 j 个硬币的最大面值. 为了计算方便, 对于 piles 先取前缀和.
        - 遍历所用栈的数量. 对于第 i 个栈, 更新公式 `dp[i][j] = max(dp[i][j], dp[i-1][j-k] + piles[i][k])` 也即, 尝试从第 i 个栈中取出 k 个硬币.
        - see [here](https://leetcode-cn.com/problems/maximum-value-of-k-coins-from-piles/solution/zhuan-hua-cheng-fen-zu-bei-bao-pythongoc-3xnk/)
        - 参见: <https://oi-wiki.org/dp/knapsack/>
    - #技巧: 看到题目的第一感觉应该是背包, 然后因为没刷过题毫无思路. 看到上述解答之后, 发现本质上还是一个DP, 而所谓「背包」不过是更高阶的总结; 所以关键还在于对于问题的理解, 而非单纯套模板.

### 287

- 6055. 转化时间需要的最少操作数
- 5235. 找出输掉零场或一场比赛的玩家
- 5219. 每个小孩最多能分到多少糖果 #题型
    - 给一组糖果, `candies[i]` 表示第i堆糖果有多少, 将其分给k个人, 要求每个人拿到的数量相同, 糖果只能划分不能合并, 可以有多余的 (即堆数>k); 求每个人拿到的最大数量.
    - 思路: #二分搜索
        - 对于不同的糖果数 m, 原本每一堆糖果可以分配出来的数量是变动的; 难以给出一个准确的映射直接求解; 然而, 对于一个给定的 m, 判断是否足够分给k个人是简单的, 复杂度为 O(candidies). 因此, 考虑二分.
        - 用一个 `test` 函数判断分m个糖果是否可行; 在 [1, sum(candies)//k] 之间二分搜索.
        - #技巧: 对于二分搜索如果不确定边界条件, 可以最后再 test 一下进行判断
- 5302. 加密解密字符串
    - 题目好长 Orz, 总而言之就是给一个 {key:value} 的映射, 将一个字符映射到长度为2的一个字符串, key不重复但是允许values重复. 然后 key->value 是加密, value->key 解密.
        - 有约束, **所有允许的原字符串仅包含在一个 len<=100 的dictionary中**. (反向思维!)
        - 要求是设计一个数据结构, 支持加解密操作, 最多调用200次.
        - 复杂度分析: keys, values 的长度 <=26, 给出的待解密的字符串长度 <=200; 最多调用200次.
    - 思路1: 模拟 (DFS+Trie)
        - 正常的思路可能是直接模拟; 然而考虑到解密环节的一对多情况, 暴力求解会超时!
        - 容易想到的改进是 DFS+Trie, 参见 [here](https://leetcode-cn.com/problems/encrypt-and-decrypt-strings/solution/by-class_-8pci/)
    - 思路2: #逆向思维
        - 这里给定了所有可能的原字符串 (并且数量很小), 所以要钻的空子就是预计算所有可能的加密结果.
        - 见 [here](https://leetcode-cn.com/problems/encrypt-and-decrypt-strings/solution/by-endlesscheng-sm8h/)

### 288

- 6037. 按奇偶性交换后的最大数字
    - 注意审题! (虽然这题设置有点奇怪) 是 奇偶性 相同的数字可以交换, 而不是 奇偶index
- 6038. 向表达式添加括号后的最小结果 #medium
    - 在括号左右添加一对括号, 例如 `"12+34"` 变为 `"1(2+3)4"` 也即左中右三个元素的乘积, 要求最小化结果
    - 思路: 遍历两侧可以加入括号的index即可, 要注意边界情况有点烦
- 6039. K 次增加后的最大乘积 #蓄水 #分配
    - 给你一个非负整数数组 `nums` 和一个整数 `k`, 可以将k分配到数组元素上 (相加), 要求乘积最大.
    - 思路: intuition是填充最小的那些数字. 因此可以看作是 **阶梯水池蓄水** 的问题.
    - 注意复杂度: `nums.length, k` 为 1e5. 最开始遍历index时 (模拟蓄水过程), 每「上一个台阶」都修改整个序列 `nums[:index]`, 复杂度为 `O(n^2)` 会超时. 修改为记录遍历的终止位置 (最终蓄水高度) 后一次性修改.
- 6040. 花园的最大总美丽值 #hard #分配
    - 数组 flowers 代表每个花园的花数量, 数字 newFlowers, 可以分配到各个花园中. 花园的分数定义为:
        - 花的数量至少为 `target` 的花园为「完善的」, 每个花园有 `full` 分;
        - 剩余「不完善」的花园, 总共有 `min(num_flower) * partial`, 也即这些花园中 量最少的花数 * 一个分值.
    - 需要注意的是, 即使在可以完全填满的情况下, 也有可能不填满的分数更高. 因此比较繁琐需要遍历.
    - 思路0: 当时很繁琐的想法是, 先尽量尝试填出完善的花园, 然后利用剩余的花来提升其余花园的最少花数. 为此, 先对花园排序, 从右往左计算 `need_for_target` 为填满最大数量花园所需的花朵数; 从右往左 `need_for_partial` 累计「阶梯水池蓄水」所需数量 (将其余花园填到高度 flosers[i] 所需的数量).
        - 然后遍历所有可能的情况. 例如遍历 need_for_target 合法的 index, 然后用剩余数量 bisect `need_for_partial` 以尽量提升其余花园的最少花数.
        - 但是需要注意边界: 1) 本来所有花园都是满的; 2) 在 bisect 时需要考虑 `need_for_partial` 的边界. 当时没想好第一点结果错在了最后一个考验复杂度的用例上, 结果没查出错误.
    - 思路: 好吧, [官方](https://leetcode-cn.com/problems/maximum-total-beauty-of-the-gardens/solution/hua-yuan-de-zui-da-zong-mei-li-zhi-by-le-18d8/) 的解答也是这样的, 不过更简洁些.

### 289

- 6070. 计算字符串的数字和
- 6071. 完成所有任务需要的最少轮数
- 6072. 转角路径的乘积中最多能有几个尾随零 #乘积
    - 给定一个矩阵, 一条「转角路径」最多出现一个转折, 求所有路径乘积的尾随零的最大数量.
    - 思路: 1) 显然, 路径越长越好, 所以折角的两条边可以直接到矩阵的边上. 2) 为了计算乘积的「尾随零」, 注意到0的数量完全取决于 2/5 因子的数量; 3) 因此, 分别计算行和列级别的前缀和, 然后遍历所有可能的折角.
- 6073. 相邻字符不同的最长路径 #DFS #树 #路径
    - 给一棵树上的节点都定义一个 label, 要求返回树上一条相邻节点的label不同的最长路径的长度。
    - 思路: 正常 DFS 即可. 注意: 1) 最长路径可能在节点的子树中, 因此需要在遍历过程中更新全局变量; 2) 注意DFS返回: 「从该节点出发的子路径的最大长度」, 而全局维护的是「一条符合条件的路径的最大长度」, 注意区分.

### 290

- 6041. 多个数组求交集
    - 求给定的所有数组的交集. 思路: 直接调用 Python API 暴力解决
- 6042. 统计圆内格点数目
    - 每个圆通过 (x,y,r) 所定义, 要求计算这些圆所覆盖的整数点数量. 思路: 暴力遍历
- 6043. 统计包含每个点的矩形数目 #bisect
    - 给定一组点所定义的矩形和一组点, 对于每个点, 要求判断包含该点的矩形的数量
    - 重点是数量级分析: `1 <= rectangles.length, points.length <= 5 * 10^4` 因此无法暴力判断
    - 注意这里的条件, (x,y) 中, `1 <= x <= 1^9; 1 <= y <= 100`, 因此, 构建 y2x, 分别排序即可.
    - 此时, 对于每一个点, 从 `recY >= pY` 的最多 100 个序列中进行 bisect 即可.
- 6044. 花期内花的数目 #区间划分
    - 每朵花 [start, end] 定义开花时期; 对于每一个在某时刻来的人, 返回此时开花数量.
    - 思路: 排序累计, 二分.
        - 转化为, 统计时间维度上, 不同区间内的花朵数量 (这样就可以二分查找了). 为此, 对于 start, end 两类节点统一排序, 然后记录各个变化的时间点即可
        - 具体而言, 用 `timeSplits, flowerNums` 两个数组记录变化时刻和该区间内的花朵数量.

### 291

- 6047. 移除指定数字得到的最大结果
    - 给定一个字符串num, 可以删除指定的一个数字d, 要求删除后的数字最大
    - 思路: 从左往右遍历, 对于位置i的数组d满足 `num[i]<num[i+1]`, 则显然可以删除该数字. 否则, 应该删除最后一个数字d所在的位置.
- 6048. 必须拿起的最小连续卡牌数
- 6049. 含最多 K 个可整除元素的子数组
    - 条件: 子数组中能够被数字 p 整除的元素的个数最多为 k
    - 对一个数组的所有 **连续非空** 子数组, 计算满足条件的不同的数组数量.
    - 思路: 本题复杂度为 `1 <= nums.length <= 200`, 因此用一个 isPdivisible 数组记录每个数字是否可被整出, 然后用一个set记录出现的不重复子数组即可.
- 6050. 字符串的总引力 #hard #题型 #排列组合
    - 定义一个字符串的引力: 不同字符的数量. 要求所有子字符串的引力之和.
    - 复杂度: `1 <= s.length <= 10^5`
    - 尝试了对于每一个长度进行「滑动窗口」, 复杂度为 O(n^2), 显然会超时.
    - 思路: 遍历累计
        - 考虑序列中某一个ch会在多少个子串中出现?
        - 不考虑本题, 一般情况下, 对于位置idx的ch, 序列 `...xxx[ch]xxx...` 的子串中出现ch的个数为: `(idx+1) * (len-idx+1)` 也即左右两边的长度分别匹配.
        - 本题中, 只有在子串中第一次出现的ch才计数假设. 因此假设出现的位置分别为 `idx[1], idx[2],...idx[i], ...`. 对于第 i 个, 其 **作为第一个ch出现在子串中** 的数量为 `(idx[i]-idx[i-1]) * (len-idx[i]+1)`. 注意相较于之前的公式左边界进行了限制.
        - 因此, 在遍历过程中, 对于不同的ch分别记录出现的 idx, 并累计计数.
    - 思路二: 类似DP.
        - 考虑从长度为 i 的前缀字符串拓展到 i+1 的变化情况. 增加了 i+1 个子串, 分别是 `s[1:i+1], s[2:i+1]...s[i+1:i+1]`. 我们要计算这些新子串所包括的引力值: 两部分
            - 末尾字符的: `idx[i+1]-idx[i]`
            - 其他字符的引力值 等价于 **所有以第i个字符结尾的子串的引力值**. 记这个值为 `sum_g`, 易知迭代公式 `sum_g[i+1] = sum_g[i] + (idx[i+1]-idx[i])`
        - see [here](https://leetcode-cn.com/problems/total-appeal-of-a-string/solution/by-endlesscheng-g405/)


### 292

- 6056. 字符串中最大的 3 位相同数字
- 6057. 统计值等于子树平均值的节点数
    - 对于一棵二叉树, 统计「节点值 = 节点所定义的子树中所有节点值的平均值」的节点数量
- 6058. 统计打字方案数
    - 按照 0-9 到字母的键盘映射 (例如, 按 `'5'` 两次得到字母 `'k'`). 这样, `33` 可能表示 `dd` 或者 `e`.
    - 给定按键的序列, 计算其映射出来的字母的方案数
    - 思路: #DP + 累乘
        - 首先, 对于一个数字, 比如 `2` 映射到 `abc`; 给一个长度为 i 的连续 2, 其可能的方案数是: `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`. 因此先用DP预先计算好所有的结果.
        - 然后对于案件序列按照上述 DP 累乘即可
        - 注意: 1) 一个数字可能对应 3/4 个字母, 需要区分; 2) 这样 DP 递归的数字很大, 要在计算过程进行 MOD, 自己提交时没有加, **Python 大整数计算超时**.
- 6059. 检查是否有合法括号字符串路径 #括号匹配
    - 给定一个仅包括 `()` 的grid, 要求判断从左上到右下是否存在一条路径, 使得括号序列合法.
    - 思路0: DFS, 超时了! 因为grid搜索的复杂度为 2^n, 这里n=100还是会超.
        - #cache
        - 改进: 参考 [here](https://leetcode-cn.com/problems/check-if-there-is-a-valid-parentheses-string-path/solution/tian-jia-zhuang-tai-hou-dfscpythonjavago-f287/) 加了 cache 之后过了
        - 离谱的是, 用默认的 `lru_cache(maxsize=128)` 会超时, 答案中用的是 Python 3.9 新的 `cache = lru_cache(maxsize=None)` 就可以过, 而且速度很快, 可能是 lru_cache 的实现太重了吧
    - 思路1: #DP
        - 从上往下一层一层遍历: 没一点可以由左侧或者上方的节点转移过来
        - 用 `dp[i][j]` 记录从左上角遍历到 (i,j), 剩余的左括号的数量, 用 set 记录.
        - 转移: 对于 (i,j), 取 `dp[i-1][j], dp[i][j-1]` 的 union, 然后根据 `grid[i][j]` 是左/右括号, 对于集合中的每个元素 +/-1, 注意不能出现负数

### 293

- 5234. 移除字母异位词后的结果数组
    - 给定一组word, 对于相邻的两个词, 若其包含的字符相同, 则删除前一个word (这样可以保证无论删除顺序最后的结果一致). 要求 最后的结果
    - 思路: 模拟.
- 6064. 不含特殊楼层的最大连续楼层数
- 6065. 按位与结果大于零的最长组合
- 6066. 统计区间中的整数数目 #hard #二分
    - 关联: 0715, 那题更全一点
    - 要求实现一个数据结构, 支持插入和查询两种操作. 插入的元素是一个区间, 查询返回这些区间所包含的所有整数.
    - 思路0: 直接暴力排序 (因为两个相邻的区间一定是不相交的).
        - 每次插入采用二分查找. 然而, 由于采用数组存储, 这样插入的复杂度仍为 O(n).
        - 原本修改index的方式采用了 `self.left = self.left[:idxL] + [valueL] + self.left[idxR:]` 的形式, 超时
        - 显然 `self.left[idxL:idxR] = [valueL]` 这样的效率更高, 直接 100% 了
        - see [here](https://leetcode.cn/problems/count-integers-in-intervals/solution/chun-er-fen-by-migeater-t5kh/)
    - 当然, 更优雅的方法是线段树?

### 294

- 6074. 字母在字符串中的百分比
- 6075. 装满石头的背包的最大数量
- 6076. 表示一个折线图的最少线段数
- 2281. 巫师的总力量和 #hard #单调栈
    - 对一个子数组, 定义score为 **最小元素 * 子数组元素和**, 现给定一个数组求所有子数组的score之和.
        - 结合了 0907 和 1856
        - 复杂度: 长度 1e5, 每个元素 1e9
    - 思路1: #单调栈 #前缀和
        - 考虑「一个元素在哪些子数组作为最小值」? 类似 0907, 利用单调栈求左右的边界.
        - 这些子数组的和如何计算? 参见下面的公式分析, 通过「前缀和的前缀和」.
        - 另外注意 cumsum的使用: 为了得到 arr[l:r] 的和, 可以使用 cumsum[r+1] - cumsum[l]
            - 例如, 对于数组 [1,2,3], 通过 `itertools.accumulate(arr, initial=0))` 得到前缀和 [0,1,3,6], 则 arr[0:2] = cumsum[3] - cumsum[0] = 6
    - 总结: 利用数学公式进行严谨的推导 (和思维方式).
    - from [here](https://leetcode.cn/problems/sum-of-total-strength-of-wizards/solution/dan-diao-zhan-qian-zhui-he-de-qian-zhui-d9nki/)

设子数组右端点为 $r$, 左端点为 $l$, 当前枚举的元素下标为 $i$, 那么有 $l \leq i \leq r$ 。 设 strength 数组的前缀和为 $s$, 在范围 $[L, R]$ 内的所有子数组的元素和的和为
$$
\begin{aligned}
& \sum_{r=i+1}^{R+1} \sum_{l=L}^{i} s[r]-s[l] \\
=& \sum_{r=i+1}^{R+1}\left((i-L+1) \cdot s[r]-\sum_{l=L}^{i} s[l]\right) \\
=&(i-L+1) \cdot \sum_{r=i+1}^{R+1} s[r]-(R-i+1) \cdot \sum_{l=L}^{i} s[l]
\end{aligned}
$$
因此我们还需要计算出前缀和 $s$ 的前缀和 $ss$, 上式即为
$$
(i-L+1) \cdot(s s[R+2]-s s[i+1])-(R-i+1) \cdot(s s[i+1]-s s[L])
$$
累加所有贡献即为答案。

### 295


### 296

庆祝一下首次在半小时之内完成, [排名破百](https://leetcode.cn/contest/weekly-contest-296/ranking/4/)!

- 6090. 极大极小游戏 #easy 模拟即可
- 6091. 划分数组使最大差为 K
- 6092. 替换数组中的元素 #medium
    - 给定一个长度为n的数组, 其中每个元素都不相同. 然后给定长为m的操作序列 (顺序执行), 每次将数组中的元素完成 (a->b) 的映射, 这里的操作有限制: 保证了a出现在数组中, 而b不出现在数组中.
    - 限制: 1 <= n, m <= 10**5.
    - 思路: #哈希表
        - 注意这里的操作是顺序执行的, 因此会有  1->2->3 这样的多次映射关系.
        - 这里保证了数组元素互不相同, 而每次操作执行后也能保证形成的数组元素互不相同. 因此, **我们只需要记录从一开始到最后的映射即可**.
        - 具体而言, 用 `numMap` 哈希表记录顺序遍历操作后, 形成的最终的映射表; 再用一个 `numMapBack` 哈希表记录回链.
            - 对于每个映射 `(a->b)`, 如果 `a` 出现在 `numMapBack` 哈希表中, 则利用回链来更新映射表 `numMap[numMapBack[a]] = b`;
            - 之前纠结的点在于, 上述映射链条之后, 是否需要删除回链 `numMapBack[a]`? 没必要, 因为根据题意, 在生成 (a->b) 映射的时候数组中是不包含b的, 因此再经过 (b->c) 之后数组中又不存在b了; 删除与否无所谓.
- 6093. 设计一个文本编辑器 #hard 不太符合? 可能是 Python 字符串操作太方便了
    - 模拟一个文本编辑器, 要求实现 添加、删除、光标移动操作.
    - 限制: 1 <= text.length, k <= 40 其中text为添加的字符串的长度, k为删除和移动光标距离. 操作次数 2e4
    - 思路: 直接用str操作即可.

### 297

一上来看错了顺序直接做第三题超时, 差点崩了, 还好相较于 1723 没有卡复杂度直接暴力+剪枝通过 (子集枚举前两天还写的Orz). 第四题真的想不到.
还是第一次遇到第2,3题都是五分的.

- 5259. 计算应缴税款总额
- 5270. 网格中的最小路径代价
- 5289. 公平分发饼干 #medium 同 1723. 完成所有工作的最短时间
    - 有一组饼干数组 cookies, 要分给k个孩子, 定义分配的不公平程度为所分配数的最大值. 要求所有分配方式中, 不公平程度最小化.
    - 约束: 数组长度 n<=8; 分配数 k<=m
    - 思路1: 暴力 #dfs + #剪枝
        - 直接暴力搜索的复杂度为 k**m
        - 然而因为采用DFS, 若当前分配数大于此前的最小不公平程度时, 可以进行剪枝.
        - 但但不会带来复杂度上的下降. 在 1723题中长度 n==12 无法过.
    - 思路2: #状态压缩 #DP #子集遍历
        - 我们定义 `f[i][mask]` 表示分配完前i个孩子, 当前分配的饼干集合为mask, 时的最小不公平程度.
        - 我们遍历分配给第i个孩子的集合sub, 这样有 `f[i][mask] = min{ max{ f[i-1][mask\sub], sum[sub] } }` 这里的sub是mask的所有子集, sum[sub] 表示sub集合中的元素之和.
        - 因此, 需要两层遍历, 第一层遍历i, 第二层遍历mask (还要遍历mask的所有子集). 注意到, 若我们对于mask从大到小遍历, 则可以省略dp的第一个维度.
        - 遍历子集采用经典的 `sub = (sub - 1) & mask` 方式.
        - 复杂度: 对于mask从1遍历到 `1<<n`, 每次遍历mask所有的子集, 其复杂度为 `O(3^n)` (恰好是排列公式). 因此总复杂度为 O(k * 3^n).
        - from [灵神](https://leetcode.cn/problems/fair-distribution-of-cookies/solution/by-endlesscheng-80ao/)
- 6094. 公司命名 #hard #题型 #互补
    - 有一组数量为n的单词, 从中选择 a,b 两个出来作为公司的名字: 选择方式为, 交换 a,b 的首字母, 若交换后生成的单词不再原数组中, 则用这两个单词作为公司名. 问所有不同的有效公司名的个数.
    - 约束: n<=10^5
    - 思路0: 根据尾序列分组. 但之后没想出来怎么缩减两两匹配的复杂度
        - 根据示例, 容易想到将结尾序列相同的单词分到一组 group/set 中.
        - 什么情况下单词组合是合法的? 假设后缀1的首字母集合为 {c,t}, 后缀2的是 {t,a}, 则两者可以搭配的组合之后 (a,c).
            - 因此: 条件是 交换的首字母不能出现在另一个group中.
        - 因此, 问题转化为: 有一组集合, 每个集合包括了一些字母. 要求从中计算所有的二元组 (ch1,ch2) 使得它们在两个不同的集合 set1,set2 中, 满足 ch1不在set2中, ch2不在set1中.
            - 但可能的集合数量达 2^26, 还需要两两组合复杂度不够.
    - 思路1: 利用 #互补 的思想 #计数
        - 再来看约束目标: 两个首字母 c1,c2 需要满足, 分别单独出现在两个集合中, 也即, 一个集合包含c1不包含c2, 另一个对称.
        - 因此, 我们用 `cnt[i][j]` 表示 **字母i不在集合, 而字母j在集合中的数量**.
        - 答案是什么? 在得到cnt计数中. 我们遍历每一个group, 我们遍历每一个组合 `(i,j) in pair(group, allCh\group)`, 将其与 `cnt[i][j]` 匹配; 将结果相加即可.
        - 注意, 这里是得到了整个cnt计数之后累计的, 因此 (i,j) (j,i) 都会加入到结果中.
            - 而原本是在遍历过程中, 直接累加进答案. 因此只考虑了一个方向; 因此需要将结果 *2.
    - [灵神](https://leetcode.cn/problems/naming-a-company/solution/by-endlesscheng-ruz8/)
    - 总结: 1) 这里 #互补 的思想很有意思. 2) **在需要两两组合但复杂度明显不够的时候, 应该考虑计数, 问题是如何找到一种好的统计方式**.


### 298

T2 用到了基本的数论常识; T3 用DP想到了一个笨解法, 但也算不错. 问题出在T4上, 纠结在一个错误的贪心策略上, 导致最后的解法很冗杂而且没有道理; 仔细分析一下子问题的转化形式, 就可以看出来复杂度具体是多少了 (自己在写搜索的时候完全没有想复杂度应该怎么算).

- 5218. 个位数字为 K 的整数之和 #medium
    - 约束: 一个多重集中的数字个位数都是k, 多重集中的元素之和为num. 现在给定k和num, 问满足条件的多重集的大小最小是多少?
    - 例子: num = 38, k = 9 时, 一种情况是 `{19,19}`. 定义空集的元素和为0.
    - 思路1: 记录每一个末尾元素的最小值.
        - 注意, 集合中用到的仅仅是个位数字, 高位是可以任意指定的
        - 因此, 我们仅需要考虑, **对于末位数字k, 其的倍数可以取到ll时的最小值是多少**.
        - 例如, 对于9来说, num=18是可以满足的, 但 num=8 则不可以, 这是因为9的倍数的个位取到8时的最小值为18.
        - 因此, 我们用一个哈希表 `mmap` 记录 k 的倍数取到ll时的最小值即可. 显然k的末位数字能取到哪些值, 只需要遍历其与 `1...10` 的乘积即可.
        - 注意: 当num=0时, 答案直接为空集; 但比如num=10时, 需要从 mmap 表中查找.
- 6099. 小于等于 K 的最长二进制子序列 #medium #DP
    - 对于一个二进制序列, 要求返回一个小于等于K的所有子序列中, 长度最大的那一个.
    - 思路1: #DP
        - 定义 `f[i, l]` 表示序列的前i的元素的子序列中, 长度为l的子序列的最小值
        - 显然有递推公式: `f[i, l] = min(f[i-1, l], (f[i-1, l-1]<<1) + bits[i])`
        - 答案: f[-1,l] 中, 满足小于等于K的最大l.
        - 复杂度: O(n^2)
    - 思路2: #贪心
        - 上述解法的复杂度是O(n^2), 实际上贪心可以做到 O(n).
        - 重点: 我们可以判断 **序列中的0均可以保留**. 证明: 假设剩余0的一个解法为x, 则我们将0插入任意位置, 替换掉最高位的1, 一定可以得到一个更小的数字.
        - 贪心算法: 从低到高位遍历, 记录当前的数字大小, 遇到0直接加到高位, 遇到1则判断当前数字是否超过了K (当然, 实际上可以提前终止).
        - 见 [here](https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/solution/by-flix-lb02/)
        - 进一步简化: 从上面的贪心过程中可以发现, 我们选择1的区间只能在最后的 `K.bit_length()` 范围内. 对于左侧部分, 我们仅需要记录 0 的个数即可.
            - 参见 [灵神](https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/solution/fen-lei-tao-lun-tan-xin-by-endlesscheng-vnlx/)
- 5254. 卖木头块 #hard #题型
    - 给一组木头定价: (h,w, price). 现在给定一个高宽分别为 (m,n) 的整块木头, 每次分割只能对于整体进行横/竖的切割. 求最多能获得的价值.
    - 约束: 木头长宽 200, 不同大小的可售木头数量 2e4
    - 总结: 典型想复杂了, 没有考虑清楚DP
    - 思路0: 记忆化搜索
        - 显然直接分割木块就得到两个子问题, 因此考虑采用 #cache 来搜索 `dfs(height, width)` 问题的解.
        - 直接采用搜索的方式求解, 用 #cache 避免重复. 子问题的分解见思路1中的讨论.
        - 采用DFS, 执行时间和空间比较下面的DP展开形式要高一点, 但整体的复杂度是一致的.
        - see [here](https://leetcode.cn/problems/selling-pieces-of-wood/solution/python-ji-yi-hua-shen-sou-by-qin-qi-shu-ty3cy/)
    - 思路1: 线性 #DP
        - 定义: f[h,w] 表示可以得到的最大价格
        - 递归形式: 对于一个大小为 (h,w) 的木块, 有三种情况: 直接出售, 从两个方向分割成两块, 变为两个子问题.
            - 三种情况分别对应, `min{ prices.get((h,w), 0); f[i, w]+f[h-i, w]; f[h, j]+f[h, w-j] }`. 其中第一项是看整块木球是否可以出售; 后两项分别对于高宽进行遍历.
            - 复杂度: 每次分割的复杂度为 O(h+w)
        - 复杂度: O(mn * (m+n))
        - from [灵神](https://leetcode.cn/problems/selling-pieces-of-wood/solution/by-endlesscheng-mrmd/)
- 1799. N 次操作后的最大分数和 #hard #题型
    - 给定一个长度为 2n 的数组, 将他们分成n组, 每组两个数字计算gcd, 然后每一组的权重为 1,2...,n, 定义分数为带权和. 求最大的分数
    - 限制: 最大的组数为 n<=7
    - 思路0: 尝试暴力遍历, 超时
        - 初步想了一下, 从所有数字中找一半作为一组, 数量最多为为 `comb(14, 7) = 3432`, 然后遍历其中一部分进行匹配, 数量为 `perm(7) = 5040`. 这样整体的尝试次数似乎在 1e7 级别?
        - 用递归形式, 结果超时了
    - 思路1: #DP
        - 数组的最大长度为 14, 因此考虑用状压来进行表示. 注意这里只有mask中非零位数量为偶数时才是有效的.
        - 采用dp, 定义 dp[mask] 为 **采用mask所表示的大小为2a子集, 权重分别为 1...a 的最大分数**;
        - 则有递推公式 `dp[mask] = max{ dp[premask] + s*gcd(mask^premask) }`. 其中第一项premask枚举mask之前的状态 (查了两个数字), 而第二项是新加的两个数字, 权重 `s=mask.bit_count()//2`
        - 复杂度: dp长度为 `2^(2n)`; 枚举大小为2的子集的复杂度为 `O(len(arr)^2)`. 因此总体复杂度为 `O(2^(2n) * (2n)^2)`
    - 注意: 在考虑DP的时候, 之前在纠结子问题的值进行表示什么? 它们的权重是什么? 但考虑到DP其实就是暴力枚举, 在上面max的过程中自然会遍历到所有的可能, 因此直接定义submask的权重为子问题的即可, 这样, 对于新的pair赋予权重为之后的那一个即可.


### 299

教训: T4写成了class直接超时了, 之后如果卡时间的话还是避免写类吧.

- 6101. 判断矩阵是否是一个 X 矩阵
- 6100. 统计放置房子的方式数 #medium
    - 有长为n的空地, 在上面盖房子, 要求不相邻, 问有多少种方式. 本题设置了河的两岸各有空地, 结果 ^2 即可
    - 思路: #DP
        - 用 f[i][0/1] 分别表示长度为i的空地, 最后一个上有无房子的方案数量.
        - 递推: `f[i+1][0] = f[i][0] + f[i][1]; f[i+1][1] = f[i][0]`
- 5229. 拼接数组的最大分数 #medium #题型
    - 给定两个长度均为n的数组 nums1 和 nums2, 可以将某一数组的 [left...right] 段置换到另一个数组, 问最大可能得到的数组的和.
    - 提示: 假设是nums2中的一段置换到nums1上, 我们计算 diff = nums1-nums2, 则问题等价于, 求diff数组上的一个连续子序列, 使其和为非正的最小值.
    - 思路1: 问题等价于求连续子序列的最小值. #贪心 即可
        - 贪心: 若当前的段落的和 >0, 则这一段没有用, 直接跳过.
        - 遍历过程中记录curr为当前最小和, 每遍历到一个数字, curr += diff[i]; 如果计算的 curr>=0, 我们将curr重制为0即可.
- 6103. 从树中删除边的最小分数 #hard #异或
    - 定义树的分数为, 所有节点的值的异或和. 现在给定一棵树, 可以从中删除两条边, 得到三个联通分量, 要求三个分数的最大最小值之差最小化.
    - 约束: 节点数量 1e3
    - 提示
        - 简单情况, 仅删除一条边, 对于原本树可以预计算每个节点对应子树的异或和, 这样, 假如分割掉了点node, 则两个分量的异或和分别为 `xors[node], xors[root]^xors[node]`
        - 问题等价于, 删除两条边将树分成三个联通分支, 要求枚举所有的可能.
    - 思路1: 枚举所有的边, 分割成两个部分a,a', 然后再枚举a'部分的所有边, 得到 b,c, 于是枚举得到所有的三成分 a,b,c
        - 问题是如何枚举两条分割的边, 然后得到三个分支?
        - 一个基本的思路是, 递归枚举两条可能的边. 固定其第一个分支, 对于第二分支, 再枚举所有的分割边.
    - 思路2: 直接枚举分割的两条边对, 这样就需要分类讨论分割的情况, 两种:
        - 若两个节点没有祖先关系, 则三个分支的异或和为 `xors[root]^xors[node1]^xors[node2], xors[node1], xors[node2]`
        - 若有祖先关系, 不妨设 node1 为 node2 的祖先, 则三个异或和分别为 `xors[root]^xors[node1], xors[node1]^xors[node2], xors[node2]`
        - 如何判断树上两个节点之间的祖先关系? **利用DFS的时间戳**
        - 见 [灵神](https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/solution/dfs-shi-jian-chuo-chu-li-shu-shang-wen-t-x1kk/).
    - 复杂度: 均为 O(n^2)
    - 总结: 注意不要采用class, 这里若用了class, 两种方案都会超时




### 300

这次是30分钟之后才开始的, 不过题目相对简单, 居然也都AC了. T2因为里面说的边界情况WA了一次 (因为是链表还不好调试); T3的公式推导一开始有点乱; T4看上去是一个显然的DP题, 想到排序之后就出来了, 偏简单.

出答案之后又更新几种思路, 清晰了很多.

- 6111. 螺旋矩阵 IV #medium
    - 给定一个 (M,N) 的gird, 顺时针方向往里面填数字, 数字由一个头为head的链表提供. 剩余的空格填入-1.
    - 思路1: 用一个函数 `f(m,n, idx)` 统一计算在一个 (m,n) 的圆环中第idx个位置的坐标.
        - 每一圈的周长为 (2m+2n-4), 从外往里一圈一圈填充, 每填一圈, m,n 减去2, 同时 bias 增加1.
        - 注意, 在上面周长计算公式中, 当 m==n==1 时结果为0, 而实际上有一个点需要填充! 在下面的代码中进行了特判
    - 思路2: 按层 #模拟
        - 和上面的思路一样, 不过维护了每层上下左右点位置, 然后便利右下左上四条边即可.
        - 见 0059题 [官答](<https://leetcode.cn/problems/spiral-matrix-ii/solution/luo-xuan-ju-zhen-ii-by-leetcode-solution-f7fp/>
    - 思路1: #模拟 轮转前进方向
        - 同 0059题, 这里可以利用 -1 特殊变量以及四个方向的轮转, 来更新每一次的前进方向.
        - 具体而言, 四个方向 右下左上 轮转 (可以用一个iDirection来表示, 每次 `(iDirection+1)%4` 更新), 当更新后的位置不合法或者遇到-1时, 更新方向.
    -
- 6109. 知道秘密的人数 #medium #interest #题型
    - 第1天有1个人知道秘密, 在经过delay天之后, 他会每天告诉一个新人, 直到经过forget天之后他忘记秘密. 问经过n天之后多少人知道秘密
    - 限制: n 1e3; 对结果取模
    - 思路1: #模拟 计算; 理解为 #DP
        - 记 f[i] 为第i天知道的人, 可知递推公式 `f[i+1] = f[i] - forgets[i] + news[i]`, 其中 `forgets[i]` 为第i天忘记的人, `news[i]` 为第i天新加的人
        - 我们用一个哈希表 news[i] 记录当天新知道秘密的人的数量, 可知有递推关系 `news[i] = sum{ news[i-forget+1]+...+news[i-delay] }`
        - 对于忘记的人显然有 `forgets[i] = news[i-forget]`
        - 灵神总结这种方法为「填表法」; 注意到, 上面的 news 计算可以利用前缀和优化到 `O(n)`
    - 思路2: 刷表法
        - 上面的这种是从当前日向前找, 还可以对当前日期影响的人往后「刷表」.
        - 注意到, 当天知道秘密的人可以分为 A「知道秘密，但还不能分享」和 B「知道秘密，且可以分享」两类.
        - 用一个 f 列表记录该天 B「知道秘密，且可以分享」的人. 则当前i可以影响的范围为 [i+delay...i+forget]; 另外统计日期n时的 A类人即可.
        - [灵神](https://leetcode.cn/problems/number-of-people-aware-of-a-secret/solution/by-endlesscheng-2x0z/)
- 6110. 网格图中递增路径的数目 #hard
    - 给定一个grid, 问网格中有多少严格递增的路径. 对结果取模
    - 约束: m,n <=1e3; 网格点 1e5
    - 思路1 对于网格值 #排序 之后 #DP
        - 注意看例子 [[1,1],[3,4]], 以1结尾的路径有1条; 以3结尾的路径有 `[3],[1,3]` 2条; 以4结尾的路径有 `[4],[1,4],[1,3,4]` 3条
        - 可知, 以某点结尾的路径数量可由周围点的路径书递归计算.
        - 因此, 先构建 {value: idxs} 的哈希表, 然后对于值排序后进行上面的DP计算.
    - 思路2: #记忆化搜索
        - 相较于上面排序后再DP, 也可以写成记忆化搜索, 代码会更加简洁.

## 周赛 301-350

### 301

- 6112. 装满杯子需要的最短总时长 #easy
    - 有三种类型的物品, 各需要一定数量, 每次操作可以 1) 获得两种物品各一; 或 2) 或者一种物品. 问最少需要多少次操作才能得到所有的物品?
    - 思路1: #归纳 分析
        - 三种类型的数量排序, 假如分别是 a,b,c. 对于a+b与c的关系进行分类讨论记录. 复杂度 O(1)
    - 思路2: #贪心 每次选择剩余数字较大的两个进行操作.
- 6114. 移动片段得到字符串 #medium
    - 两个字符串包括了 `L,R,_` 类别, L只能向左, R只能向右, 不能交替. 问start能否变为target.
    - 限制: 两字符串等长, 1e5
    - 思路1: 字符之间存在一一对应关系, #模拟 检查即可.
        - 由于LR不能交错, 因此要求S,T中, 非空字符的顺序相同. 并且要求: 对应字符中, L的位置满足 `idxS>=idxT`, R的位置 `idxS<=idxT`
- 6115. 统计理想数组的数目 #hard
    - 定义「理想数组」: 所有元素都在 `[1...maxValue]`, `arr[i]` 都是`arr[i-1]` 的倍数 (1,2,3...倍)
    - 限制: n,maxVal 1e4
    - 思路0: #DP
        - 定义 `f[i][j]` 为长度为i的数组, 最后一个值为j的理想数组的数量.则有递推 `f[i][j] = sum{ f[i-1][k] }`, 其中k为j的因子.
        - 但显然复杂度不够, 需要 O(n^3).
    - 思路1: 将数字分解 #因子, 然后利用 #排列 公式计算
        - 定义 `f[k]` 表示已k结尾的长度为n的合法数组数量. 则答案为 `sum{ f[k] }`.
        - 将问题定义为排列问题: 对于每一个质因子计算重复数, 然后进行放置. 注意, 不是 `comb(n, ...)`.
            - 先考虑所有的因子都相同的情况. 例如有2个因子2, 长度n=2, 可以有的排列为 `[2,4], [1,4], [4,4]`, 注意两个因子可以放在一个slot中! 因此, 实际上是将2个相同的球放在2个袋子中的数量. 可以用「挡板法」考虑, 也即将k个球放在n个篮子里, 等价在k+n-1个位置选k-1个位置放挡板, `comb(k+n-1, k-1)`
            - 对于不同的因子, 注意它们之间是独立的! (直观理解, 在上面的例子中加入一个重复数为1的因子3, 则答案数*2).
        - 总之, 对于结尾数字k, 假如k不同因子的分别有 [m1,m2,...] 个重复, 则以k结尾的合法数组数量为 `prod{ comb(n+m_i-1, m_i) }`.
        - 复杂度: 在遍历n的每一步, 计算质因子 O(log n), 计算组合数 O(log n) (这里直接用了math.comb, 在比较小的情况下是线性的), 因此复杂度最多 `O(n log^2(n))`
        - from [灵神](https://leetcode.cn/problems/count-the-number-of-ideal-arrays/solution/shu-lun-zu-he-shu-xue-zuo-fa-by-endlessc-iouh/)

### 302

T4之前正好做了「1819. 序列中不同最大公约数的数目」, 直接15min AK了!

- 6122. 使数组可以被整除的最少删除次数 #共约束 #hard
    - 给定两个数组, 要求找到nums中最小的, 能否整除numsDivide中所有数字的数字.
    - 思路1: 计算numsDivide所有数字的 #最大公约数 g. 然后nums从小到大遍历, 若当前数字可以整除g, 就找到了.


### 303

T4乍一看挺难, 但分析一下可由bit运算规律得到等价形式. 在计数的问题上WA了一发, 一开始用了暴力的二分求解, 然后分析出了更优雅的方案, 挺开心.

- 6127. 优质数对的数目 #hard
    - 给定一个正整数数组, 要求统计「优质数对」的数目. (num1, num2) 优质要求满足, 两者都在数组中出现过, 并且 `num1 OR num2` 和 `num1 AND num2` 两个数字的 `bit_count` 之和 >=k.
    - 限制: 数组长度 1e5. 元素大小 1e9, k<=6
    - 提示: `(a | b).bc() = a.bc() + b.bc() - (a & b).bc()`
    - 思路1: 根据提示, 可知, 两个数字只需要满足 `a.bc() + b.bc() >= k` 即可.
        - 细节: 这里要求统计的不同的数对 `(num1, num2)`, 即使num1仅在数组中出现一次, 也可以有 (num1, num1). 如何区别相同数字和不同数字的情况?
            - 简单思路是直接对于bc进行排序, 每次暴力二分查找可匹配的部分. 复杂度 O(n logn)
            - 另一种思路是对于bc进行Counter (实际上是分组排序). 注意到, 数字的bc最多为 30. 因此, 假设bc从0...30的数量向量为arr, 对于a, `arr[a] * sum{ arr[k-a...30] }` 对于后者可以用前缀和计算 `acc[-1] - acc[max(k-a, 0)]`. 复杂度 `O(n + 30)`

### 304

T3,T4 都是基环树, 各自WA了三发... 结果排名1000+, 简直太烂了! 关联「5970. 参加会议的最多员工数」某次周赛的难题, 参见灵神的讲解, 总结 #基环树.

- 6134. 找到离给定两个节点最近的节点 #medium
    - 给一张有向图, 每个节点至多有一条出边. 找到某一节点, 使得给定的两个节点node1, node2都能到达并且距离最短.
    - 注意: 1) 若距离相等, 则返回较小的那个节点. 2) 可能成环
    - 限制: 节点数量 1e5
    - 提示: 由于每个节点最多只有一条出边, 因此 **从某一节点出发, 距离为x的特定节点无环节点只有一个**
    - 思路1: 分别从两个点「同时」开始 #BFS, 判断是否发生重合
        - 根据提示, 用两个指针表示两节点 (不需要用queue了); 再用两个set记录分别经过的节点 (成环了则终止). 按照层级遍历, 若出现 `q1 in seen2 or q2 in seen1`, 则找到了.
        - 反思: 之前想简单了: **由于可能有环, 因此不能用一个set来记录两节点遍历的所有点**. 错误的例子 [1,0,-1] 图的情况.
    - 思路2: 一种更为简单的方式是, 直接找出两个点可达的所有点的(最短)距离, 两者都可达的条件是两个距离值的最大值非inf; 因此, **对于所有的最大值取最小值即可**.
        - from [灵神](https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/solution/ji-suan-dao-mei-ge-dian-de-ju-chi-python-gr2u/)
- 6135. 图中的最长环 #hard
    - 给一张有向图, 每个节点至多有一条出边. 找到图上出现的最长环.
    - 限制: 节点数量 1e5
    - 思路1: 用一个ava集合记录当前可用的节点. 每次随机选一个出发尝试寻找环.
        - DS: 由于出发节点可能不在环上, 因此需要一个path列表来记录遍历过程, 为了快速检查是否经过, 还需要一个pathseen字典. (找到的话, 答案为 `len(path) - path.index(ne)`)
        - 重复检查: 之前用ava来记录还可用的节点, 但在遍历的过程中如何进行重复判断?  这里需要注意成环点一定会被第二次访问, 因此 **重复检查需要放在环检测之后**!
    - 思路2: 事实上是「5970. 参加会议的最多员工数」的一个子问题.
        - 上题用了拓扑排序将分枝都剪掉了. 除了这一做法, [灵神](https://leetcode.cn/problems/longest-cycle-in-a-graph/solution/nei-xiang-ji-huan-shu-zhao-huan-li-yong-pmqmr/) 介绍了利用 #时间戳 来解的思路
        - 用一个全局clock记录一次的遍历顺序. 每次从某点尝试找环的时候, 记录开始时间, 则在while循环中, 若 **找到一个节点是时间戳不小于开始时间**, 说明成环!
    - 反思: 一开始也想歪了, 还乱用 SortedList

### 305

不难, 结果因为T3一念之差WA了四次 (不可原谅). 34min AK但估计排名800+.

- 6137. 检查数组是否存在有效划分 #medium #题型 其实不难, 但一开始想歪了结果WA了四发😭
    - 对一个数组进行拆分, 合法的子数组为: 1) 两相同元素; 2) 三相同元素; 3) 三个连续递增数字, 例如 [1,2,3]. 问能否进行拆分.
    - 思路0: 尝试对于情况3进行筛选, 一旦出现递增就标记为已使用. 但实际上是 #WA 的, 因为可能有 [1,1,2,3,4] 这种情况.
    - 思路1: 还是应该用 #DP 来求解. 对应三种情况, 递归 `f[i] = (nums[i]==nums[i-1]==nums[i-2] and f[i-3]) or (nums[i]==nums[i-1] and f[i-2]) or nums[i-2]+2==nums[i-1]+1==nums[i]`. 注意边界.
- 6138. 最长理想子序列 #hard 但不难
    - 给定一个小写字母字符串, 要求最长的子序列, 使得相邻元素的差值都不超过k. 思路: 用一个哈希表lastIdx记录每个字母最近出现的位置. 遍历过程中对每个i,ch进行查找: `f[i] = max{ f[lastIdx[ch-k...ch+k]] +1 }`.

### 306

- 6150. 根据模式串构造最小数字 #medium #题型 #构造
    - 给定一个长度为n的I/D表示相邻元素的大小关系; 要求返回一个 **字典序最小的** 并且数字为两两不同的1-9数字的序列 (长度为n+1).
    - 限制: 长度 8
    - 思路1: #回溯 用一个有序数组记录还可用的数字, 每次尽量选择最小的那一个. 复杂度: O(n!), 本题由于最大为9 大概在1e6级别所以还行.
    - 思路2: #贪心
        - 如何最小化字典序? 每次尽量填较小的数字. 为此, **每次考虑 `I..ID..D` 这样先上升后下降的片段**, 例如IIDDD可以填入45321.
        - 在扫描输入序列的过程中, 每次找上述特征片段 (假设长度为x), 然后填入可以数字中最小的x个数字.
        - 复杂度: O(n) from [灵神](https://leetcode.cn/problems/construct-smallest-number-from-di-string/solution/by-endlesscheng-8ee3/)
- 6151. 统计特殊整数 #hard
    - 给定上限n, 要求从 1...n 的数字中, 没有相同元素的数字. 限制: 2e9
    - 思路1: #分类 讨论 + 模拟
        - 首先, 观察长度为 1/2/... 的数字中的特殊正数有多少? 分别有 `9, 9*9, 9*9*8, ...` 注意首位不能是0.
        - 对于长度为l的目标数字, 分成长度小于l的数字和长度等于l的数字进行讨论. 主要是第二种情况, 每次维护可用的数字列表, 假设剩余ava个可用数字, 要构造长l的子序列, 数量有 `math.perm(ava, l)` 个. 注意首位不能为0.
        - 写起来比较繁琐, 见code.
    - 思路2: 通用的 #数位 DP
        - 写成了规范的递归函数形式 `f(i: int, mask: int, isLimit: bool, isNum: bool)`.
            - 这里的i是当前位, mask表示约束条件;
            - `isLimit` 表示当前位是否受到约束. 例如本题中, 一般情况下可以取所有非冲突位, 而当前缀和n相同时, 只能取更小值;
            - `isNum` 表示 当前位之前是否已有了非零数字, 否则首位不能填0.
        - 见 [灵神](https://leetcode.cn/problems/count-special-integers/solution/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/)

### 307

题目显而易见变难了Orz...T4在比赛结束后五分钟过了, 就无语 (虽然是暴力用了sl). 总而言之, 对于问题的理解还不够到位.

- 6166. 最大回文数字 #medium
    - 给定一组0-9数字, 要求从中构造最大的回文串, 不能有前缀零.
    - 思路1: #细节 #构造
        - 如何得到最大回文? 尽量用到多的数字, 大的放在前面. 将一个回文数分割成 [left,mid,right] 三部分, 中间mid可能为空或者单个字符, 左右部分对称.
        - 注意: 由于不能有前缀零, 需要有很多细节的判断.
- 6154. 感染二叉树需要的总时间 #medium 求二叉树上的某一节点到其他点的最大距离.
    - 思路1: 先进行一次DFS得到父亲节点 (变成无向图). 然后就是基本的BFS
- 6155. 找出数组的第 K 大和 #hard #题型 #总结 #star
    - 给定一个数组, 在此数组的所有子序列的和中, 求第k大的.
    - 限制: 数组长度 1e5, 元素大小 +/-1e9. 重点是这里的k最大为 2000
    - 提示:
        - 显然, 最大值就是正数和. 那么, **那些次大元素如何得到呢?** 减去一些正数, 或者加上一些负数.
        - 假设正数和为sum是可能得到的最大值. 然后 **我们可以把nums都取绝对值**, 选取一组数字, 其和就是可能从sum中减去的结果.
    - 思路1: 利用 #堆
        - 直接给结论: 1) 初始化最大堆 `(sum, 0)`, 堆元素 `(val, idx)`, 这里的第二个参数idx表示我们下一个要处理的位置, 注意此时我们一定选择了idx-1. 2) 第i次弹出最大元素, 这里的val就是第i大的和. 考虑选择idx, 或者选择idx并去掉idx-1. 将这两个新元素入堆.
        - 形式化问题: 「**从n个非负数中求k个最小的子序列和**」. 上面的过程就是解法. 这里的正确性来自, 1) 枚举了所有的子序列; 并且 2) 入堆的元素一定比出堆元素大. 见题解2.
        - 关联: 「1982. 从子集的和还原数组」
        - 复杂度: `O(n logn + k logk)`
    - 思路2: #二分 查找子序列和不大于limit的数量.
        - 还是为了解决上面形式化的子问题. 我们可以在 [0, U] 中搜索一个值, 使得取绝对值之后的nums中子序列和不大于该值的数量刚好有 k-1 个 (因为我们要求第k个).
        - 因此, 可以用二分搜索. 我们需要一个函数 `count(limit)` 统计nums中小于等于limit的子序列数量. 这里的基本思想和思路1一致, 见代码. #细节. 注意, 这里最多求k个, 因此count函数的复杂度为 O(k).
        - 复杂度: `O(nlogn + k logU)`. 空间: count函数需要递归, 最多 `min(k,n)` 层.
    - 思路0: 想到了提示1, 但没进一步想到提示2. 所以比较繁琐
        - 步骤: 从正数中找到最小的k个, 负数组合中找到绝对值最小的k个, 两两组合就是减去的最小情况.
        - 面临同样的子问题, 作弊用 SortedList 侥幸过了.
    - [灵神](https://leetcode.cn/problems/find-the-k-sum-of-an-array/solution/zhuan-huan-dui-by-endlesscheng-8yiq/)

### 308

T4 看到约束想到了CSP问题, 但其实要求拓扑排序还是比较清楚的, 应该直接看出来的额.

- 6163. 给定条件下构造矩阵 #hard #题型
    - 给定一个k, 要求构造 k*k 的矩阵, 填充 1~k 共k个数字, 其他位置填0. 要求满足行/列约束. 约束的形式是, 给定一组 (i,j), 要求数字i所在行应该在j所在行的上面. 限制: k 400, 约束数量 n 1e4
    - 思路0: 一开始看到约束条件想到 #CSP 问题, 但一想约束满足问题的搜索复杂度似乎不够? 没想清楚
    - 思路1: 实际上就是一个 #拓扑排序. 


## 双周赛 D001-D049

### D48

- 1798. 你能构造出连续值的最大数目 #medium
    - 给定一组硬币, 问能从这些硬币中组成 0,1,2...n-1 这样最大多少个连续数字, 返回能构成的数量n.
    - 思路: #归纳
        - 根据所给的例子进行归纳猜想. 例如, 给定 `[1,4,10,3,1]`, 答案为20.
        - 先将其排序 `[1,1,3,4,10]`, 第一个最多为1; 前两个最多构成2, 正好接上第三个数字3; 第四个显然可以; 然后前四个数字之和9, 可以接上数字10, 这样最大的数字为19.
        - 因此, 可以总结: 对于第i个数字若前缀和 acc[1...i-1] >= nums[i], 则可以使用第i个数字. 找到最大的满足条件的i, 答案即为 acc+1.

### D49

- 1813. 句子相似性 III #medium
    - 有两个单词单词序列(句子), 问能否在某一个序列中插入一个任意序列(句子), 使得原本的两个句子相等.
    - 思路1: #两端匹配
        - 注意到, 由于最多只能插入一个序列, 无非就是左右两端, 或者中间.
        - 这样, 在上面的任意情况下, 长序列从两端出发, 都可以完全匹配短序列.
        - 因此, 采用 #两端匹配, 用长序列从两侧匹配短的, 完全覆盖了则说明可以.
    - 思路0: 贪心匹配, 错了!
        - 原本打算用短序列顺序匹配长序列, 用一个 `flag` 记录是否用过了插入的机会.
        - 但这样有问题, 例如 "A" 和 "a A b A" 的例子.
- 1814. 统计一个数组中好对子的数目
- 1815. 得到新鲜甜甜圈的最多组数 #hard #TODO
    - [problem](https://leetcode.cn/problems/maximum-number-of-groups-getting-fresh-donuts/)
    - 每次烤 batchSize 个甜甜圈, 然后有一个数组 groups, 表示每次的客人需要购买的数量. 当某次顾客购买的甜甜圈中没有上一次卖剩下的情况下, 该顾客是开心的. 问, 任意调整 groups 顺序的情况下, 最多开心的数量.
    - 约束: 每组数量 batchSize<=9; 客人组的长度最多为 30.

## 双周赛 D050-D100

### D50

- 1827. 最少操作使数组递增
- 1828. 统计一个圆中点的数目
- 1829. 每个查询的最大异或值
- 1830. 使字符串有序的最少操作次数 #hard #math
    - 定义了对于字符串一个复杂的操作, 问经过多少次操作后, 可以原字符串 s 变为递增的形式.
    - 操作定义为: 从后往前找到第一个 `s[i] < s[i - 1]` 的位置, 然后在 s[i:] 中找到最后一个 `s[i-1] > s[j]` 的位置. 然后 1) 将 i-1, j 两个位置的元素调换; 2) 反转 s[i:]
    - 限制: 字符串长度最大为 3000. 对于结果取模.
    - 见 [官答](https://leetcode.cn/problems/minimum-number-of-operations-to-make-string-sorted/solution/shi-zi-fu-chuan-you-xu-de-zui-shao-cao-z-qgra/)
    - 思路1: #组合数学
        - 注意到, 在上述操作中, 找到的坐标满足 s[i:] 是递增的; 然后在后续中找到的 j 是比 s[i-1] 次小的元素; 交换 i-1, j 后, s[i:] 仍然是递增的; 交换后, s[i:] 变为递减的.
            - 简言之, 对于位置 i-1, 我们从其后找到了一个比它次小的元素, 然后让 s[i:] 尽可能大 —— 也即, 找到了一个字典序次小的字符串 (排列).
            - 将上述过程反转过来, 其实就是得到「0031. 下一个排列」
        - 也即, 问题等价于: 原字符串 s 是从小到大的第几个排列?
            - 思路: 递归求解.
            - 例如, 对于 [3,2,1,4] 来说, 从左往右看: 后续中比第 i=0 个数字3小的有两个 (rank=2), 因此考虑第一个数字为1/2, 这样的排列有 `2*perm(3) = rank * perm(n-i-1)`;
                - 然后, 问题递归为大小 -1 的子问题, 考虑 i=1 位置...
            - 还需要考虑重复数字的情况. 一般而言, 假设每个数字的重复数为 dup[ch], 则所有不同的排列数为 `n! / (dup[0]! * dup[1]! * ... * dup[n-1]!)`
                - 具体到本题中, 我们约束第一个数字为比 s[idx] 更小的, 因此公式为 `rank * (n-1)! / prod(dup[ch]!)` 这里的n是从idx位置往后的字符串长度, 而dup[ch]记录了从idx位置往后的数字的重复数.
        - 进阶: #乘法逆元
            - 在本题中, 由于字符串长度为3000, 直接计算排列数会产生很大的数字. 而在上面的公式中出现了除法, 如果要用取模运算来防止数字溢出的话, 可以考虑「乘法逆元」. (超纲了)
            - 所谓「乘法逆元」就是对于一个整数a, 找到另一个整数a' 使得 `aa' = 1 (mod p)`.
                - 利用「费马小定理」, 当p为质数时有 `a^{p-1} = 1 (mod p)`, 因此可以找到一个逆元为 `a^{p-2}` (可以在再 MOD p).
            - 利用乘法逆元, 我们有 `b/a = b*a' (mod p)`, 因此可以将除法转为乘法 (从而可以对两个因子分别取模).
            - 幸而Python不用考虑数字溢出的问题, 直接暴力计算也可以过 (就是时间慢了点).

### D51

- 1844. 将所有数字用字符替换
- 1845. 座位预约管理系统 #medium
    - 实现一个类管理n个座位, 可以 1) reserve 返回最小的空位; 2) unreserve(i) 取消座位i.
    - 复杂度: 座位数量n为 1e5, 总的函数调用次数 1e5
    - 思路0: 无脑用了 SortList 类
    - 思路1: 实际上用一个最小推, 来维护还剩余的座位即可 (因为每次 reserve 只需要得到最小值)
- 1846. 减小和重新排列数组后的最大元素
- 1847. 最近的房间 #hard
    - 有一组房间 [(id, size)]; 每次查询 (preferred, minSize) 要从至少为 minSize 的房间中找到与 preferredID 绝对差最小的房间号 (相同的话返回较小的).
    - 限制: 房间数量n 1e5; 查询次数 k 1e4; 房间大小 1e7
    - 思路1: #离线查询 #SortedList
        - 由于每个查询有minSize的限制, 考虑对其从大到小排序, 这样可选的房间 potential 逐渐变多.
        - 如何在potential中找到与preferredID绝对差最小的房间号? 维护房间id有序然后, 二分查找. 具体实现上又用了 SortedList.
    - [官答](https://leetcode.cn/problems/closest-room/solution/zui-jin-de-fang-jian-by-leetcode-solutio-9ylf/) 也是一样的思路, 不过做了更高级的抽象.

### D52

- 1859. 将句子排序
- 1860. 增长的内存泄露 #meium
    - 有一个程序每一秒新占用的内存数以 1,2,3,... 形式递增; 现有两个大小分别为 memory1, memory2, 分配策略为: 每次选择空余较多的那个分配, 如果相同则分配第一个. 要求返回内容不够分配的时刻, 以及此时两内存的剩余.
    - 限制: 2^31-1
    - 思路1: 模拟
        - 要死, 看成了大小限制为 1e31 级别, 想了半天如何找规律...
        - 在32进制的大小下, 可以直接模拟求解. 时间估计如下: 到时刻t分配的总内存为 `1+2...n = O(n^2)` 级别, 因此时间复杂度为 `O(sqrt(memory1 + memory2))`, 这样 `2**16 = O(5)` 没问题
- 1861. 旋转盒子 #medium
    - 有一个矩形的盒子, 有两类物体: 障碍物(不会移动), 石头(占据一个格子). 要求将盒子顺时针转90度之后的物体分布.
    - 思路: 直接 #模拟
- 1862. 向下取整数对和 #hard #题型
    - 给定一个整数数组 nums, 对于所有的下标组 (i,j), 计算 nums[i]//nums[j], 求和
    - 思路0: 尝试讨巧借用 numpy, 结果发现超时了. 因为服务器是单核?
    - 思路1: 遍历 + #前缀和 复杂度为 #调和级数
        - 不妨考虑从小到大排列, 对于数字 y, 我们遍历 x/y 的所有可能: `1,...,upper//y`.
        - 如何统计 `x//y==`a, 也即 x 在 [ay, ay+y) 范围内的个数? 可以用一个cnt数组记录所有数字出现的次数, 这样只需要对该区间求和即可; 显然用前缀和可以 O(1) 得到
        - 这里的复杂度分析: 假设最大值为`C, 有 C/1 + C/2 + ... C/C`, 是一个调和级数, 复杂度为 `O(C log(C))`
        - [here](https://leetcode.cn/problems/sum-of-floored-pairs/solution/xiang-xia-qu-zheng-shu-dui-he-by-leetcod-u3eg/)
    - 思路2: #二分 + #cache
        - 既然上述的遍历 x//y 的方式可以过 (有调和级数保障), 那么如果想不到用cnt计数, 直接排序之后二分查找也是可以的.
        - 为了得到 [ay, ay+y) 范围内的数字, 显然可以在排好序的数组中二分查找边界.
    - Note: 调和级数的边界
    - $\sum_{i=1}^{n} \frac{1}{i}=\ln (n+1)+\gamma$

### D53

- 1876. 长度为三且各字符不同的子字符串
- 1877. 数组中最大数对和的最小值
- 1878. 矩阵中最大的三个菱形和 #medium
    - 在一个矩形中, 找出所有的「菱形」中, 边所经过的点的最大(三个)和. 这里「菱形」的定义, 就是正方形旋转45度. 见 [描述](https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/)
    - 思路0: 本题的复杂度长款分别为 100, 因此直接暴力枚举, 大概是 O(n^4) 级别
    - 思路1: 斜方向 #前缀和
        - 考虑菱形每一条边的计算方式: 就是四条线段, 因此容易用前缀和的方式加速计算.
        - 为此, 需要预先计算两个方向上的前缀和.
        - 复杂度: 遍历每一个可能的中心点, 需要枚举所有可能的边长, 每次计算和只需 O(1), 因此总的复杂度为 O(n^3).
        - 见 [官答](https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/solution/ju-zhen-zhong-zui-da-de-san-ge-ling-xing-hpko/); 下面灵神的解答更为简洁
- 1879. 两个数组最小的异或值之和 #hard
    - 给定两个数组, 对于nums2重排序, 然后和nums1一一匹配计算异或值, 要求返回最小的异或值之和.
    - 限制: 数组长度n为 14; 元素大小 1e7
    - 思路1: #状压 DP
        - 考虑依次用nums2中的元素元素匹配nums1中的每一个; 记nums2中所用元素的二进制表示为 mask, 则已经匹配了 `c = mask.bit_count()` 个元素 (顺序匹配nums1的前 c 个数字).
        - 因此有: `f[mask] = min{ f[mask\i] + nums2[i] * nums1[mask.bit_count()-1] }`. 这里枚举所有mask中为1的位 i, 将其与第 nums1[c-1] 个元素匹配.
        - [here](https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/solution/liang-ge-shu-zu-zui-xiao-de-yi-huo-zhi-z-2uye/)


### D54

- 1893. 检查是否区域内所有整数都被覆盖 #easy #题型
    - 给定一组闭区间 ranges, 然后再给一个区间 [left, right], 要求判断这一区间的数字是否被ranges中至少一个区间覆盖.
    - 思路1: #排序 之后依次判断
        - 复杂度: 假设区间数量为 n, 则复杂度 O(nlogn)
    - 思路2: #差分数组
        - 注意本题中的数字范围有限再 [1,50] 之间; 因此, 如何记录ranges中的区间? 可以对于 [l,r] 之前的数字都计数+1; 然后检查查询区间 [left, right] 是否都大于零即可
        - 简化复杂度的方式为, 利用 #差分数组 记录这些ranges, 然后累加一边即可得到每一个数字的被覆盖次数. 这样复杂度为 O(n+l) 其中l为维护的数字大小 (这里为 50)
        - [官答](https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/solution/jian-cha-shi-fou-qu-yu-nei-suo-you-zheng-5hib/)
- 1894. 找到需要补充粉笔的学生编号
- 1895. 最大的幻方 #medium #前缀和
    - 要求在一个矩阵中找到「幻方」, 也即行和、列和、两条对角线元素和都相同的正方形.
    - 思路1: 记录四个方向上的 #前缀和 即可.
        - 需要注意的是, 一般用 (m+1, n+1) 大小的矩阵距离前缀和, 第一行第一列为哨兵. 在这里, 行列和主对角线是可以这么做的, 但是对于副对角线 (右上-左下), 需要设置哨兵为第一行和最后一列, 这样造成idx会有一点区别.
- 1896. 反转表达式值的最少操作次数 #hard #双栈 #语法分析
    - 关联: 0224. 基本计算器
    - 给定一个形如 `"1&(0|1)"` 的布尔表达式, 问最少通过多少操作使其的值发生改变, 例如将这个例子的值变为0, 可以将|操作变为&, 或者将其中一个1变为0.
    - 允许的操作是: 翻转 0/1, 或者翻转&/|
    - 限制: 表达式长度 1e5
    - 思路1: 使用 #双栈 记录 操作符和运算元. 运算元记录将节点变为 0/1 所需的最小操作数. 利用 &| 节点的性质得到递推公式.
        - 参考 0224, 为了处理操作和括号语句, 采用双栈来分别存储数字和运算符.
            - 不同之处在于, 这里不是求表达式的值, 而是问最少操作次数. 为此, 将运算元记录变为 `(x,y)` 表示将该节点变为 0/1 分别所需的最小操作数.
            - 如何确保 **相同级别的操作符顺序执行**? 这里的策略是遇到布尔值就尝试用掉前面的操作符, 直到遇上左括号.
        - 显然, 遇到叶子节点, 即布尔值的时候, 记录分别为 (1,0) 和 (0,1)
        - 关键在于, 遇到一个操作符的时候如何更新?
            - 例如, 当前为 &节点, 假设两子节点返回的分别为 (x1,y1) (x2,y2)
            - 在不改变节点为| 的情况下, 要求其值为 0/1, 所需的最少操作数分别为 `min{x1+x2, x1+y2, x2+y1}` (实际上就是 `min{x1, x2}`, 这里应该是为了和or节点保持一致), `x2+y2`, 记为 `x_and, y_and`
            - 然而, 另一种将表达式值变为 1 的方式是将操作符变为 or, 然后只需要 `y_or` 个操作即可.
            - 综上, 节点记录的更新公式为 `(min(x_and, x_or + 1), min(y_and, y_or + 1))`
        - [官答](https://leetcode.cn/problems/minimum-cost-to-change-the-final-value-of-expression/solution/fan-zhuan-biao-da-shi-zhi-de-zui-shao-ca-s9ln/)
    - 思路2:
        - 符合自己一开始的想法: 如果已有了输入字符串对应语法树, 求解是比较简单的 (不一定需要上面的策略). 但问题还是如何构建语法树?
        - 下面还是用 #双栈 分别存储数字和运算符, 然后定义节点构建二叉树结构.
        - 还是那个问题, 如何保证 **相同级别的操作符顺序执行**? 可以给操作符定义优先级 (例如 `dict(zip('(&|', (0, 1, 1)))`), 当遇到某一操作符的时候, 将更高或相同优先级的运算符全部用掉. 这一思路比上面的更为通用.
        - [here](https://leetcode.cn/problems/minimum-cost-to-change-the-final-value-of-expression/solution/zhong-zhui-biao-da-shi-gou-zao-er-cha-bi-gman/)

### D55

总结: 对于相对简单的题, 在陷入复杂判断的时候, 尝试跳出来尝试更「笨」的想法, 或许更加清晰.

- 1909. 删除一个元素使数组严格递增 #easy #题型
    - 给定一个数组, 最多删除一个元素, 判断其是否可将其变为递增数组.
    - 思路0: #反思
        - 居然被一道简单题卡住……思路比较乱.
        - 混乱的原因在于, 本题有两种情况: `[1,2,10,5,7]` 是需要删除一个峰值, 而 `[105,924,32,968]` 是要删除一个低谷.
        - 假如在位置i检测到 `nums[i] <= nums[i-1]`, 情况一需要将 `i, i-2` 比较, 而情况二则是 `i+1, i-1`. 因此判断比较复杂.
        - 下面答案就比较清楚: 反正最多删除一个元素, 我们可以分别尝试删除 `i, i-1`, 对于每种情况进行判断即可 (写成函数 `check(i)` 来封装逻辑).
        - 总结: 对于相对简单的题, 在陷入复杂判断的时候, 尝试跳出来尝试更「笨」的想法, 或许更加清晰.
- 1910. 删除一个字符串中所有出现的给定子字符串
- 1911. 最大子序列交替和 #medium #dp
    - 定义「序列交替和」为: 序列中偶数元素之和 - 序列中奇数元素之和. 要求求出给定序列的所有子序列中, 这一差值的最大值.
    - 思路1: #dp
        - dp递归的元素为 (x,y) 分别表示所选的子序列长度为 odd,even 时的最大差值.
        - 这样, 有递推公式 `dp[i] = [max{dp[i-1][0], dp[i-1][1]-nums[i]}, max{dp[i-1][1], dp[i-1][0]+nums[i]}]`
- 1912. 设计电影租借系统 #hard #sortedcontainer
    - 有一组n家电影租借店, (shop, movie, price) 表示在shop中有一个movie租借价格为price (注意每家店最多只有一份电影拷贝). 顾客在某一家店租界后会在原店归还.
    - 主要是实现两种查询: 1) 对于给定的电影m, 查找还有这份影片(未租借出去)的店中价格最低的5个; 2) 查询所有已租借的影片中价格最低的5个, 按照 (price, shop, movie) 排序.
    - 思路1: #最小推
        - 要实现最小值的查询, 首先考虑到堆结构.
        - 如何维护信息? 对于查询1, 可以给每部影片建立一个堆(索引); 然后, 用一个结构来记录该影片是否被租借: 当出堆的时候, 发现该片已被租借则舍弃, 否则加入答案中 (最后将答案中的记录再放回堆). 对于查询2, 维护一个最小堆, 每个元素为 `(price, shop, movie)` 结构; 同样, 当出堆的时候, 若发现已归还则舍弃, 否则加入答案.
    - 思路2: #sortedcontainer
        - 官答则更为简单地调用了 SortedList 来记录 尚未租借的, 以及全部已经租借的影片.

### D56

- 1925. 统计平方和三元组的数目 #easy
    - 总计 `1 <= a, b, c <= n` 的三元组, 满足 `a^2 + b^2 = c^2`
    - naive 的思路是暴力遍历, 复杂度 O(n^2).
    - [here](https://leetcode.cn/problems/count-square-sum-triples/solution/gei-yi-ge-on23-log-n-de-suan-fa-by-hqztr-p91c/) 给出了 O(n) 乃至更小的方法.
- 1926. 迷宫中离入口最近的出口
- 1927. 求和游戏 #medium #博弈
    - 一道博弈论: 有一个长度为 2n 的数组, 每个位置要么是 0-9, 要么为空. 游戏规则是, AB两人分别在空位填数字, 直到全部填满.
    - 结算: 做数组左半部分之和等于右半部分, 则B获胜, 否则A获胜.
    - 思路1: #归纳
        - 考虑简化情况: 记 `spaceL, spaceR` 分别为左右空格数, 若两者相等. 则A的一种策略是往和大的部分填9, 这样B只能在另一边填一个9...
            - 总之, 只有当 `sumL = sumR` 时 B才获胜.
        - 一般情况下, 不妨令右半部分有更多空格 `spaceL <= spaceR`
            - 显然, 当差值 `d = sumL - sumR < 0` 左侧空格更少而数值和反而更小, A只要不断在左侧填9即可获胜.
            - 当空格数为奇数时, A填最后一个, 显然可以获胜.
            - 如上所述, A的策略是往较大的部分填9, B只能在另一侧补充9; 因此, 两侧都有空格的情况可以最终会变为只有一侧有空格并且差值d不变.
            - 在假设下有右侧空格更多, 有 `ava = spaceR - spaceL` 个; 两侧的差值 `d = sumL - sumR >= 0`.
            - 考虑B如何应对A的阻挠获胜? 显然是两个数字之和应该为9. 因此, B的获胜条件为 `d == ava//2 * 9`.
    - 另见 [官答](https://leetcode.cn/problems/sum-game/solution/qiu-he-you-xi-by-leetcode-solution-06ti/)
- 1928. 规定时间内到达终点的最小花费 #hard
    - 给定一张地图, 要从0走到 n-1 号节点. 经过每一个节点需要交fee[i] 的费用. 每条边有距离. 需要在所有长度不超过 maxTime 的路径中, 计算最小的fee.
    - 思路0: 尝试通过UCS来搜索. 但问题是, 需要维护一个visited记录确定的最短路径; 但实际的最小花费路径的长度可能是更大的.
        - 根本原因在于, 我们 **维护的避免重复访问的值不符合题意**.
    - 思路1: 根据fee大小建立 #最小堆.
        - 反思了上面的问题, 这里考虑按照fee来构建最小堆.
            - 注意, 此时不能基于路径超出限制就break循环. 因为一条较长路径的fee可能更小.
        - 那么, 如何避免重复访问? 注意到, 我们第一次到达节点i的时候, fee是最小的. 但是这条路径的距离可能很长无法到达终点.
            - 我们用一个哈希表minDist 来维护遍历过程中每个点的最短路径. 当下一次遍历到时比记录的 minDist[i] 小, 说明这条路径更短, 仍要入队列. 否则, 我们知道新的这条路径比已记录的某条路径fee更高, 距离也更大, 直接舍弃.
        - 终止条件: 注意我们第一次到达终点即可退出循环, 因为第一次到达的fee最小. 若遍历到队列为空时仍为到达终点, 说明没有在距离限制内的路径可以到达终点.
    - 思路2: #dp
        - 更为暴力的解法: 用 f[t][i] 表示恰好在时刻t到达地点i, 所需要的最小fee.
        - 则有转移方程 `f[t][i] = min_j{ f[t-weight[j,i]] + fee[i] }` 这里j是所有与i相连的节点 (j,i).
        - 具体来说, 可以采用两层遍历: 外层循环t 从1到maxWeight, 内层遍历所有的边.
        - 复杂度: O((n+m) * maxWeight). 其中第一项是初始化dp矩阵的代价, 第二项是遍历过程. 显然要比思路1慢.
        - [官答](https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/solution/gui-ding-shi-jian-nei-dao-da-zhong-dian-n3ews/)

### D57

- 1942. 最小未被占据椅子的编号 #medium
    - 有n个朋友来派对, 每个人的到达和离开时间为 (arrival, leaving); 每个人到达时, 挑选位置最小的座位坐下. 问第 target 个朋友所坐的位置.
    - 思路0: 维护 #sortedlist 记录所有的空闲座位
        - 将所有人的到达和离开时间作为两类事件, 统一排序. 然后暴力模拟.
        - 用一个 sortedlist 维护所有空闲座位, 每到达一个人移除 available[0]; 离开一个人则将该座位号添加到 available 中.
        - 注意, 同一时刻到达和离开, 需要先处理离开的人.
        - 复杂度: O(n log(n)). 我们维护长度为n的有序列表, 每次操作复杂度为O(log(n)).
    - 思路1: 相较于有序列表这一复杂结构, 采用最小堆更为轻量.
- 1943. 描述绘画结果 #medium
    - 在数轴上有一组线段 (start, end, color) 表示该区间被涂上了 color. 当一个点被涂上多种颜色后, 颜色叠加, 简记为 sum(solors). 要求返回一个数组, 元素 (start, end, color) 表示绘画结果.
    - 限制: 题目中每个线段的颜色均不同
    - 思路1: #差分
        - 如何表示累加的颜色信息, 还要记录线段位置? 不难想到 #差分数组. 也即在线段的开始位置分别 +/- color.
        - 得到差分数组后, accumulate 即得到最后的每个点的颜色值.
        - 注意到可能出现 1+4 == 2+3 的颜色记录, 但这表达的其实是两种颜色. 由于题目说明了每种颜色都只涂了一个线段. 因此可知交接点两侧的颜色值一定不同. 因此, 基于所有线段的边界划分输出结果即可.
        - 细节: 一开始对于 sorted(pivots) 所定义的每一个线段都输出了, 但忽略了空白线段 (颜色为 0), 注意考虑这一情况.
- 1944. 队列中可以看到的人数 #hard #单调栈
    - 给一个数组表示序列中每个人的身高. 一个位置为i的人只能看到其右边的满足条件的人: (i,j) 满足它们中间的人的身高要小于 `min(arr[i], arr[j])`. 要求返回每个人能看到的人数.
    - 思路1: #逆序 #单调栈
        - 显然, 一个人向右能看到的人的身高呈递增, 并且看到的最远的一个人满足 `arr[i] < arr[j]`. 所以, 可以用单调栈来解决.
        - 为此, 我们可以从右往左遍历, 维护一个单调栈. 一个人能够看到的人数为: 加入i时候其弹出栈的数量, 加上(如果有的话)栈顶那个人.


### D58

第三题的题目很有意思, 还是比较明显的DP题型, 不过躁乱之下没有细想; 第四题 #Manacher 显然不会做, 不过第二步中的卡了好久, 不应该.
反思: 1) 总结分析DP的数组构造; 2) 写代码之前应该先分析验证有效性.

- 1959. K 次调整数组大小浪费的最小总空间 #medium #题型
    - 题目的背景是动态内存分配: 对于一个数组, 可以在其中调整k的所分配的内存, 要求最小的总空间浪费.
    - 抽象: 对于一个数组, 将其分成 k+1 个部分, 每个部分取最大值矩形进行覆盖, 要求所有矩形的面积和最小.
    - 限制: 数组长度 n<=200, 调整次数 0<=k<n
    - 思路1: #DP
        - 考虑采用动态规划求解. 每次利用之前状态的记录.
        - 具体而言, 记 `dp[i][j]` 表示 **覆盖数组的前i个元素, 使用j次调整(j+1个区间)所浪费的最小空间**.
            - 于是, 有 `dp[i][j] = min_ii { dp[ii][j] + g[ii+1][i] }`
            - 对于每个 `dp[i][j]`, 我们将 0...i 区间根据 ii 进行拆分, 将右边分成一个区间, 左边进行 j-1 次调整.
            - 这里的 `g[a][b]` 表示区间 [a,b] 分成一组的空间浪费, 可以预先双重遍历计算出来.
            - 具体实现中, 可以将更新公式中的 j维度省略.
        - 说明: 为了要求 num[0...ii] 被分成 j 个区间, 显然 ii 必须小于 j. 但实际上由于 ii<=j-1 时空间浪费必然为0, 因此在下面的代码中没有考虑这一边界情况.
        - [官答](https://leetcode.cn/problems/minimum-total-space-wasted-with-k-resizing-operations/solution/k-ci-diao-zheng-shu-zu-da-xiao-lang-fei-wxg6y/)
- 1960. 两个回文子字符串长度的最大乘积 #hard #题型
    - 给定一个字符串, 要求找到两个连续的不相交子串 (0 <= i <= j < k <= l < s.length), 都是长度为奇数的回文串, 使得两者的乘积最大.
    - 限制: 长度 1e5
    - 思路1: #Manacher 算法计算所有回文串长度, 然后分别计算左右两侧的最大回文串长度, 遍历匹配.
        - [here](https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-substrings/solution/ma-la-che-suan-fa-xiang-xi-tu-jie-by-new-m2zj/)
        - 首先, 利用 Manacher 马拉车算法计算所有位置为中心的回文串长度. 算法概要:
            - 初始化: 遍历 i=0...n-1 为当前位置; 初始化 mx=-1 表示之前的回文串拓展到达的最右边界, j=-1 表示mx所对应的中心位置.
            - 拓展: 当 i<=mx 时, 我们可以利用已有信息, 初始化 `plen[i] = min(plen[2*j-i], mx-i)`; 否则初始化为 1 (仅包括i位置)
                - 从 plen[i] 出发, 向两侧检测拓展回文串
            - 更新: 若本次拓展的位置超过了之前的边界 `i+plen[i]>mx` 则更新 mx, j.
            - 说明: plen[i] 表示一半的长度, 可以从0开始也可以从1开始, 需要注意代码.
        - 然后, 如何保证两个子串不相交?
            - 我们分别从左右两侧遍历, 例如 left[i] 表示 nums[:i+1] 中所包含的最大回文长度. 然后根据分割点, 匹配左右位置即可.
            - 思路: #DP 在遍历 i=0...n-1 的过程中, 维护一个此前的中心位置 l 和最大长度 mx.
                - 当进入下一个位置i时, 不断尝试右移l, 直到 `l + plen[l] -1 >= i`.
                - l+plen[l] 可能会超过当前位置i, 此时需要进行裁剪. 这需要和 l+=1 以及 mx 的计算相匹配.
            - 注意: 这里维护的指针 l 的更新公式中, 确保了 (l, i) 范围内不会出现更长的合法回文串. 其实和 Manacher 算法中的思想类似.
            - 这里看上去简单, 实际折腾了很久 —— 主要写之前没有考虑dp的更新公式.


### D59

第四题好难, 不过解答思路很精彩!

- 1976. 到达目的地的方案数 #medium #题型 #最短路径
    - 求出从s到e的最短路径的数量.
    - 约束: 节点数量 n为200, 题目确保了是连通图; 需要对答案取 MOD
    - 思路1: #BFS
        - 题目中提示了要对答案取模, 说明了等长的路径数量可能很多, 不能暴力累计所有路径.
        - 因此, 在BFS过程中维护一张哈希表 `cnt` 记录每个节点的最短路径数, 然后在到达v的时候增加计数 `cnt[v] + cnt[u]`
        - 如何保证每次增加的计数都是正确/最短的? PQ中的元素为到达节点v的 cost 以及 (u,v) 信息. 也即, 每次取出的一定是到v的最短路径.
        - 需要注意的是, 一个节点可能会被多次加入 PQ, 如何保证不会出现重复? 仅第一次拓展的时候入 PQ即可.
    - 思路2: 先计算所有节点的最短路径, 然后在构造的 #DAG 上 #DP 求解路径数量.
        - 具体而言, 在计算到每个点的距离之后,构建一个DAG仅包含最短路径上的边, $\operatorname{dist}[v]-\operatorname{dist}[u]=\operatorname{length}(u \rightarrow v)$
        - 然后在这张图上DP就比较直观了.
        - [官答](https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/solution/dao-da-mu-de-di-de-fang-an-shu-by-leetco-5ptp/)
    - 总结: 是计算「最短路径数量」的题型
- 1977. 划分数字的方案数 #hard #题型
    - 给定一个数字串, 问有多少种分割方式, 使其变为非递减的正数序列, 要求数字没有前导零.
    - 约束: 数字长度 n<=3500. 注意最多支持 O(n^2) 复杂度.
    - 思路1:
        - DP框架
            - 形式: `f[i][j]` 表示对于序列nums[0...j]的分割方案中, 最后一个数字为 nums[i...j] 的方案数.
            - 迭代: 既然最有一个数字为 nums[i...j] 其要满足条件要求上一个数字 nums[k...i-1] 更小, 因此迭代公式为 `f[i][j] = sum{ f[k][i-1] }` 这里的k的范围为上面的约束
                - 注意数字不包含前导零, 因此若 `j-i > i-1 - k` 则一定满足, 反之则不满足. 两者相等时的情况需要另外讨论 (见下).
                - 因此, 求和范围为 `2i-j(or -1) ... i-1`.
            - 边界: `f[0][...] = 1`; 要求的答案为 `sum{f[...][n-1]}`
            - 前缀和优化: 直接求和复杂度 O(n^3) 不够. 可以采用前缀和计算. 记 `pre[k][i-1]` 为上一迭代中的前缀和, 则有 `f[i][j] = pre[i][i-1] - pre[2i-j(or -1)]` 其实是否有 2i-j-1 项根据 nums[2i-j-1...i-1] <=nums[i...j] 判断.
                - 观察: 实际上不用前缀和利用迭代也可. 假如我们按照 i,j 的前后顺序来进行两次枚举, 根据 j, j+1 两个相邻状态的元素, 发现后者只多了1/2项, 因此用一个idx记录累计的元素即可.
            - LCP: 预计算 #最长公共前缀, 快速比较两个数的大小
                - 上述过程中, 还需要比较 `nums[2i-j-1...i-1], nums[i...j]` 两个数字的大小, 但直接算的复杂度为 O(k), 会超时
                - 用 DP 预计算LCP, 形式为: lcp[i][j] 表示分别从 i,j 位置出发向右的最长公共串长度.
                - 显然有递推公式: 若num[i]==num[j] 则有 `lcp[i][j] = lcp[i+1][j+1] + 1`, 否则为 0.
                - 在此基础上, 比较 `nums[2i-j-1...i-1], nums[i...j]` 的大小就很简单: 若 `lcp[i][2i-j-1] >= j-i+1`, 说明公共部分比比较的部分更长, 满足大于等于; 否则, 直接比较 num[i+ll], num[2i-j-1+ll] 即可.
    - [官答](https://leetcode.cn/problems/number-of-ways-to-separate-numbers/solution/hua-fen-shu-zi-de-fang-an-shu-by-leetcod-env6/)
    - 总结: 想到DP迭代公式就挺难的; 更为复杂的是之后的LCP等技巧. 本题比较综合.

### D60

- 1991. 找到数组的中间位置 / 0724. 寻找数组的中心下标
- 1992. 找到所有的农场组 #题型
    - 找到一个 grid 中的所有矩形, 矩形之间满足不相邻
    - 思路: 模拟
- 1993. 树上的操作
    - 需要构建一种树结构, 能够实现 Lock, Unlock, Upgrade 操作. 其中 Lock, Unlock 操作针对单个节点比较 naive.
    - Upgrade(node, user) 操作要求满足: 1) 节点及其祖先节点未上锁, 2) 其孩子节点至少有一个上锁.
    - 思路: 对于节点维护 parent, children, lockUser 属性, 在 Upgrade 操作中向上向下分别遍历检查条件.
- 1994. 好子集的数目 #hard
    - 给定一组数字, 都不大于30. 求满足条件的所有子集的数量, 条件为: 子集中所有数字的乘积可以 = 不同的质数的乘积.
    - 方法一：#状态压缩动态规划 #状态压缩
        - [here](https://leetcode-cn.com/problems/the-number-of-good-subsets/solution/hao-zi-ji-de-shu-mu-by-leetcode-solution-ky65/)
        - 由于数字都比较小, 可以罗列所有的质数 `primes=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]`
        - 对于一组数字, 它们所用到的质数可以通过状态压缩来表示, 即 0/1 表示以上10个质数用到了哪几个, 记为 mask
        - 考虑 DP: 用 d`p[i][mask]` 表示只使用数字 `2~i`, 并且所用的数字的质数组合为 mask, 这样的子集的数量.
            - 状态转移方程: 若 数字i本身包含平方因子, 例如 4, 12 等, 则该数字无法采用, `dp[i][mask] = dp[i-1][mask]`;
            - 否则, 假设i包含的质数组合为 subset, 则 `dp[i][mask] = dp[i-1][mask] + dp[i-1][mask\subset] * freq[i]`, 其中的 subset 必然是 mask 的子集, mask\subset 可以异或得到
        - 因此, 从 i=2开始遍历到 30, 最后的结果 `sum(dp[30][mask])` 表示所用的质数组合为 mask 的方案数量. 注意 `dp[][0]` 没有意义: 因为 mask=0 表示没有取到任意质数.
        - 需要注意的是数字 1, 其作为因子不影响乘积, 因此可以取任意数量; 然而, 单纯用数字1不满足条件. 两种方案:
            - 取 `dp[1][0] = 1`, 从而避免 `dp[i-1][mask\subset] * freq[i]` 式子中的判断; 最后取 `sum(dp[30][1:]) * 2**freq[1]`
            - 也可以初始化 `dp[1][0] = 2**freq[1]`, 表示单纯用 1 的组合数量; 最后取 `sum(dp[30][1:])` (因为单纯用数字1不满足条件)

### D61

- 2006. 差的绝对值为 K 的数对数目
- 2007. 从双倍数组中还原原数组 #题型
    - 对于一个数组的所有数字变为双倍, 混入原数组. 现在要求还原数字.
    - 思路: Counter 之后从大到小遍历.
    - 特殊: 0 的双倍还是 0
- 2008. 出租车的最大盈利 #medium #题型
    - 出租车从 1开到n, 给定一组 `rides[i] = [start_i, end_i, tip_i]` 表示可以接到的单子, 每单的价格为 `end_i - start_i + tip_i`, 要求一趟下来最多获得多少钱.
    - 复杂度 n 为 1e5, rides 长度 3e4
    - 思路: #DP
        - 用 dp[s] 表示从时刻 s 开始接单的最大收益.
        - 因此, 对于 rides 基于 start 逆序排序. 对于第i个交易 `dp[start] = max(dp[start], dp[end] + fee_i)`.
        - 存储方式1: (超时了, 按理说复杂度应该还行?) 考虑到不连续性, 对于dp key 采用排序数组, 然后对于有值的那部分用字典存下来 (bisect 查找)
        - 存储方式2: 更为经典的连续存储方案, 保存一个长度为 n 的数组, 通过 `dp[start] = dp[start+1]` 进行初始化
- 2009. 使数组连续的最少操作数 #题型
    - 给定一个长度为L的数组, 每次可以对于数组的任意一个元素替换为任意的值, 要求最少替换次数, 是的数组中的元素构成连续的L的整数. 例如 nums = [4, 2, 5, 3] 是 连续的
    - 思路1: 排序+ #双指针
        - 注意到出现多次的数字一定需要被修改, 因此取 unique 然后对于数组排序. 用 left 指针从左往右扫描, 尝试移动 right 指针, 满足 `nums[right] - nums[left] < L`.
        - 这样对于每一个 left 位置, 原数组中保持不变的index区间为 [left, right], 每次更新答案 `ans = min(ans, L-(right-left+1))`
        - see [here](https://leetcode-cn.com/problems/minimum-number-of-operations-to-make-array-continuous/solution/on-zuo-fa-by-endlesscheng-l7yi/) 对于 right 如果不用双指针还可以直接 bisect

### D62

- 2022. 将一维数组转变成二维数组
- 2023. 连接后等于目标字符串的字符串对
    - 给定一组字符串 和一个目标字符串 target, 返回从这组字符串中选择两个拼接可以得到 target 的组合数量.
- 2024. 考试的最大困扰度 #题型
    - 给定一个包含两种元素的序列, 最大改动数量为 k, 尽可能使得出现的连续相同元素最大
    - 思路: #双指针 #滑动窗口
    - 针对每种元素遍历数组 (可以写成一个函数), 在双指针遍历过程中, 维护左右指针之间的修改数量不超过 k. 具体而言, 可以 for 循环 `right`, 在超出条件的时候步进 `left`
    - 参 [here](https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/solution/kao-shi-de-zui-da-kun-rao-du-by-leetcode-qub5/)
- 2025. 分割数组的最多方案数 #题型
    - 给定一个数组和一个数字k, 允许将数组中的某一个数字修改为k (也可以不修改), 要求最大化满足条件的分割数量.
    - 条件: 给定一个 `1<=pivot<n`, 将数组分割为 nums[0:pivot-1] 和 nums[pivot:n-1] 两部分 (闭区间), 使得两部分的和相等.
    - 思路: #双哈希表 #前缀和
    - 计数组的前缀和为 cumsum, 总和为 total.
    - 在不修改的情况下, 合法分割为 cumsum[i] = total-cumsum[i], 即 cumsum[i] = total/2.
    - 考虑修改的情况: 将第i个元素进行修改, 记变化量为 `d = k-nums[i]`, 对于i之前的元素其累计和不变, 之后的元素累计和增加d.
        - 因此, 1) 对于之前的元素, 合法条件变为 cumsum[j] = total+d-cumsum[j], 即 `cumsum[j] = (total+d)/2`; 2) 对i及其之后的元素, cumsum[j]+d = (total+d)-(cumsum[j]+d), 即 `cumsum[j] = (total-d)/2`
    - 因此, 在遍历修改元素 i 的过程中, 用双哈希表记录前后的 cumsum 分布情况.
    - 参 [前缀和+双哈希表+枚举修改元素](https://leetcode-cn.com/problems/maximum-number-of-ways-to-partition-an-array/solution/qian-zhui-he-ha-xi-biao-mei-ju-xiu-gai-y-l546/)
    - 注意: 这里要求的分割点必须在数组的中间, 在维护双哈希表的时候应该去掉total的情况. (见代码)

### D63

- 2037. 使每位学生都有座位的最少移动次数
    - 给定一组座位的位置和一组学生当前的位置, 要求对每个人匹配到合适的位置所需最少移动次数
    - 思路: 直接按照排序的结果一一匹配
- 2038. 如果相邻两个颜色均相同则删除当前颜色
- 2039. 网络空闲的时刻 #网络
    - 有 n 个节点, 0 号为服务器, 其他为数据节点. 节点之间通过网络连接, 经过一个时间段信息传递一条边.
        - 现所有的数据节点需要向服务器发送信息, 服务器收到后发送反馈. 每个数据节点还有一个 `patience[i]`, 表示在经历这么长时间没有收到回复则重发消息.
        - 要求计算经过多少时刻后, 网络上没有数据包 (空闲).
    - 思路: #BFS + 遍历
        - 每个数据节点和服务器的关系是独立的, 因此, 分别计算每个数据节点到服务器的距离, 遍历计算即可.
        - 对于数据节点 i 来说, 其距离和等待时间为 distance[i], patience[i], 则收到最后一个数据包的时间为: `2*distance[i] + 1 + 2*distance[i]//patience[i]*patience[i]`
        - 其中, `2*distance[i] + 1` 是第一个数据包发送到收到回复的时间, `2*distance[i]//patience[i]*patience[i]` 是可能有的接受不了重发数据包所需的额外时间.
- 2040. 两个有序数组的第 K 小乘积 #hard
    - 对于两个有序数组 nums1 和 nums2, 定义它们之间的交互乘积 `nums1[i] * nums2[j]`, 要求返回这些数中第 k 小的 (从1开始).
    - 复杂度: 两数组的长度为 5e4, 数字范围为 -1e5~1e5.
    - 思路 1: #二分查找 + #双指针 + #分类讨论
        - 基本的思路是二分查找可能的范围 `[-1e10, 1e10]`
        - 根据零将两个数组分别分为负数和非负数两部分, 然后分类统计两两组合之下, <= 待搜索的 m 的组合的数量; 由于采用双指针形式, 二分判断的复杂度为 O(L), 因此总复杂度为 O(Llog(N)), 这里 L为数组长度N为搜索空间大小.
        - [解答](https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays/solution/yi-ti-san-jie-shuang-zhi-zhen-jie-bu-den-sqsu/) 还可以对于四种条件进行合并讨论
    - 思路 2: 也是二分查找框架, 不过在组合 nums1, nums2 的时候, 直接利用不等式条件, 内部进行一次二分搜索.
        - 这样, 内部二分的复杂度为 O(LlogL), 整体的复杂度为 O(NLlogL).
        - 具体而言, 对于 nums1[i], 要求 nums1[i] * nums2[j] <= m, 根据 nums1[i] 与0 的关系, 可以直接计算出如 nums2[j]<=m/nums1[i], 基于这个条件进行二分搜索.
    - 思路 3: 通过前缀和代替二分
        - 在上一种解法中, 复杂度增加了, 实际上我们可以通过 #前缀和 来避免内部的二分. 注意到 nums 的元素范围为 `[-1e5, 1e5]`, 我们可以利用前缀和得到 `cumsum[m]` 表示数组中包括多少个小于等于 m 的元素.

### D64

- 2053. 数组中第 K 个独一无二的字符串
- 2054. 两个最好的不重叠活动 #medium #题型
    - 有一组活动 (start, end, value), 可以选择其中一个/两个不重叠的活动, 要求value最大化.
        - 要求: 两个活动不重叠, 也即 end1 < start2
        - 复杂度: 活动数量 1e5, 起止时间 1e9
    - 思路1: #统一排序
        - 将活动的s/e时间统一进行排序, 排序元素为 (time, type, value), 这里的time是活动的起止时间, type是0/1, 0表示s, 1表示e, value是活动的value.
        - 维护 bestEnd 为截止到当前时间已经结束的单个事件的最大value. 这样在遍历排好序的数组的过程中: 1) type=0, 更新 `ans = max(ans, bestEnd+value)`; 2) 否则更新 `bestEnd = max(bestEnd, value)`
        - 注意, 这里有效的排序是 time和type. 题目要求两活动不重叠, 因此将 start排在end 之前 —— 这样如果有s/e时间相同, 会先更新 ans, 此时用的是上一时刻的 bestEnd.
        - [官方解答](https://leetcode.cn/problems/two-best-non-overlapping-events/solution/liang-ge-zui-hao-de-bu-zhong-die-huo-don-urq5/) 很优雅
    - 思路2: 排序 + #最小堆
        - 更为直观的思路: 先对于start进行排序. 在遍历的过程中, 如何得到早于该时刻的所有事件的最大value? 显然可以用一个最小堆来维护.
        - 具体而言, 堆的元素为 `(end, value)`. 遍历过程中同样维护 bestEnd: 对于当前事件的 start, 从堆出取出所有 end_i < start 来更新 bestEnd.
        - 参见 [here](https://leetcode.cn/problems/two-best-non-overlapping-events/solution/yong-you-xian-dui-lie-wei-hu-ling-yi-ge-8ld3x/)
- 2055. 蜡烛之间的盘子
    - 一个数组包括两种元素 (蜡烛、盘子). 给一个查询 [l,r], 要求返回在该子序列中, 被蜡烛包围的盘子数量.
    - 思路: 二分搜索. 先抽取提取所有蜡烛的idx, 然后在这个数组中进行二分. 注意边界判断.
- 2056. 棋盘上有效移动组合的数目 #hard
    - 大小为 8*8 的棋盘上有三种类型的的棋子 车, 象, 后 (rook, bishop, queen), 分别可以按照横竖、斜, 以及两者的组合这些方向移动.
        - 每个棋子可以在指定的方向上移动 k步, 然后停在该点. 若一个棋子先到达某点, 另一个棋子也需要经过该点, 则冲突.
        - 已知棋盘上最多有四个棋子 (最多只有一个后), 要求返回最终所有棋子的组合中有效移动的组合的数目.
    - 思路: #模拟 #product. 先根据棋子类型计算出其所有可能的 (direction, step) 组合, 然后模拟移动 (也即判断该组合是否合法).
        - 见 [here](https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/solution/python-producthan-shu-de-yong-fa-by-9813-p0cp/) typing 写得很规范
    - 总结: 可以充分 **利用 Python 的相关函数简化代码**, 例如这里用了两次 product 来 生成棋子的走法, 和生成所有棋子的走法组合.
    - [这里](https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/solution/go-mo-ni-by-endlesscheng-kjpt/) 还用了 DFS 的思路, 但复杂度上应该差不多.
        - 其实是更为「直觉」的想法 —— 用DFS来避免重复枚举, 然后DFS感觉上似乎比上面暴力组合可以降低一点计算? 但实际上代码会更复杂些.

### D65

- 2068. 检查两个字符串是否几乎相等
- 2069. 模拟行走机器人 II #medium
    - 模拟一个机器人沿着矩形的边缘行走, 每次下一步要出边界的时候, 进行右转. 要求实现一个类, 可以 1) 查询机器人的位置和方向; 2) 要求机器人前进 num步.
        - 初始状态为 (0,0)点, 方向向右.
    - 思路1: 直接模拟.
        - 然后, 由于矩形的范围不是很大, 而前进的步数可能很高, 因此需要避免重复走圈 (`num = num%self.circleLen`)
        - 这样就遇到一个边界情况: 当机器人到达边界点的时候方便不变, 要走下一步方向才会变化; 因此其实状态的方向为向右, 但下一次机器人到达该 (0,0) 点时的方向应该是向下. 需要特殊处理一下
    - 思路2: 直接记录位置到方向的映射
    - 如[官方答案](https://leetcode.cn/problems/walking-robot-simulation-ii/solution/mo-ni-xing-zou-ji-qi-ren-ii-by-leetcode-lhf24/) 所言, 可以直接得到位置到行动方向的映射
        - 这样, 对于矩形的每一个位置建立 index, 然后在行动的时候根据前进方向整除得到机器人的 index 即可.
- 2070. 每一个查询的最大美丽值 #题型 #medium
    - 有一组 (price, beauty) 所定义的商品. 要求在小于 O(n) 的复杂度内查询价格在 p 以下的商品中, beauty 的最大值.
    - 复杂度: 物品数量 1e5, price/beauty 值 1e9.
    - 思路: #索引 + #二分
        - 不能直接对于每一个价格建立到最大美丽值的映射, 因此考虑只对出现过的价格建立映射, 然后二分查找答案即可.
        - 具体而言, 对于出现过的所有价格, 预计算 (price, maxBeauty) 的索引, 表示在price以下的所有价格中, 最大的美丽值.
        - 查询时, 对于所要查询的 p, 在price中二分搜索 index, 然而返回对应的 maxBeauty 即可.
- 2071. 你可以安排的最多任务数目 #题型 #二分
    - 给定一组任务和工人, 当工人的分数高于任务分数时可以完成; 另外给 k 个药丸可以增加单个工人的 strength 点能力值 (一个人只能用一次). 求最多匹配的数量.
    - 复杂度: n 个任务和 m 个工人为 5e4, 能力值大小 1e9
    - 思路: #二分搜索.
        - 匹配的数量范围为 [0, min(m,n)]. 关键在于如何检查是否可以得到 k 个匹配?
        - 用贪心: 如果可以有 k 个匹配, 显然是 k个能力最大的工人和 k个所需点最小的任务. 排序, 然后对任务从高到低遍历: 1) 能力值最大工人可以胜任, 则直接匹配; 2) 否则, 从吃了药丸可以胜任的功能中找到能力值最小的, 小号一颗药丸.
        - 终止条件: 药丸用完了, 或者加上 strength 也没有人可以胜任.
    - 注意复杂度分析: 每一次检测, 最多需要再 min(m,n) 个候选工人中进行二分搜索, 因此为 `O(min(m,n) * log(min(m,n)))`. 整体二分的复杂度为 `O(min(m,n) * log^2(min(m,n)))`.
    - 事实上可以优化: 用「双端队列」来维护所有可以（在使用药丸的情况下）完成任务的工人，此时要么队首的工人被选择（删除），要么队尾的工人被选择（删除），那么单次删除操作的时间复杂度由 O(log(min(m,n))) 降低为 O(1)
    - see [here](https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/solution/ni-ke-yi-an-pai-de-zui-duo-ren-wu-shu-mu-p7dm/)
    - 技巧: **二分查找时, 可以额外用一个 ans 记录二分的结果, 而不需要纠结最后返回 l or l-1**

### D66

- 2085. 统计出现过一次的公共字符串
- 2086. 从房屋收集雨水需要的最少水桶数 #题型 #medium #贪心
    - 给定一个字符串, 两种元素表示房屋和空地; 要求在每一栋房屋边上放一个水桶, 最少的数量 (无法安排则返回 -1).
    - 第一次做的时候思路很乱: 尝试一次遍历解答, 用两个指针分别记录最近的一个水桶和最近的一个没有被覆盖的房屋. 但是判断比较复杂.
    - 思路1: 重新做发现了更简单粗暴的思路 (没有必要追求一次遍历, 反正复杂度不要超即可). 也是 #贪心 的思路: 这里能够节省水桶的情况就是其两侧都有房屋.
        - 因此, 每遇到 `H.H` 的情况就放置一个水桶 (注意 `H.H.H` 这种情况, 要对于以覆盖的房屋进行标记). 这样, 剩余的没有被覆盖的房屋在其相邻的空地放一个水桶即可.
    - 思路2: 贪心 see [官方答案](https://leetcode-cn.com/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/solution/cong-fang-wu-shou-ji-yu-shui-xu-yao-de-z-w2vj/)
        - 这里的想法更为简洁: 因为实际上, 我们放置冗余水桶的情况只可能为 `.H.H` 这样的特征错放在第一个位置上了. 因此, 贪心只需要 **优先将水桶放在右侧**.
        - 只考虑遍历到房子的情况: 1) 两侧有了, 则不放; 2) 否则, 判断该点的房屋是否可被覆盖, 优先放右侧.
        - 改进: 这里需要记录水桶的放置情况, 1) 可以通过修改数组 (将原本的字符串转为可变结构); 2) 进一步可知, 对于右侧放水桶的情况, 可以直接向前跳两个, 从而避免了修改字符串.
- 2087. 网格图中机器人回家的最小代价
- 2088. 统计农场中肥沃金字塔的数目 #hard #题型
    - 给定一个gird, 每个格子 0/1 表示是否肥沃. 定义「肥沃金字塔」为 `.:.` 这种样子的 (高度 > 2). 要求统计所有肥沃金字塔 (还有倒三角也算) 的数目.
    - 解法1: #DP, 参见 [here](https://leetcode-cn.com/problems/count-fertile-pyramids-in-a-land/solution/tong-ji-nong-chang-zhong-fei-wo-jin-zi-t-paok/)
        - 关键在于如何判断一个格子是否是 (以及是多少个) 肥沃金字塔的顶点? 注意到, **一个高度为 h 的金字塔, 其顶点之下的三个元素也必然为高度为 h-1 的金字塔的顶点**. 例如这一观察, 可以得到递归方程.
        - 这样, 一个最大高度为 h 的金字塔, 顶点元素作为金字塔顶点的所有可能为 h-1 个. 为了计算的方便, 定义 dp 矩阵的元素:
        - 若不合法 -1, 合法则为最大可能三角的 h-1. (也即单一个肥沃格子, 无法构成三角, 定义其元素为 0)
        - 这样, 可以得到统一的递推公式: 当 i,j 位置合法的时候, `dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + 1`.
    - 思路2: #前缀和 判断底边中心点可以构成几个金字塔
        - 上一种 DP思路聚焦顶点, 我的直觉是看底边可以构成多少金字塔. 注意到, 一个金字塔, 其底边的每个元素之上肥沃土地的数量形如 `12321`. 因此可以从上往下累计每块土地之上的肥沃土地数量 (复杂度 mn).
        - 然后, 对于每一行序列, 例如 `[3,3,3,3,1]`, 我们需要判断以这一行为底边的金字塔数量.
        - 分析可知, 以每个元素为底边中心的金字塔数量为 [0,1,2,1,0]. 如何计算? 我们用左右两个数组来表示当前元素左右的情况.
        - 例如, 这一例子中, left=[0,1,2,2,0], right=[2,2,2,1,0]. 综合这两个约束, 求和可知这一行共包含 4个金字塔.
        - 如何更新这一约束? 以left为例, 初始化 lLimit=-1, 对于位置j的元素有递推公式 `lLimit = min(lLimit+1, v-1)`: 1) 金字塔是阶梯形的; 2) 当前高低为v点的元素为中心最多有 v-1 个金字塔.


### D67

- 2099. 找到和最大的长度为 K 的子序列 #题型 #easy
    - 给定一个序列, 要求返回一个长度为 K 的子序列 (元素可以不连续, 但要求顺序不变), 使其和最大.
    - 思路: 返回最大的 k 的元素, 同时要求保留idx信息.
- 2100. 适合打劫银行的日子 #medium #题型
    - 求数组中所有满足条件的idx. 条件为: 该元素在 nums[i-k:i+k] 这一区间内为谷底.
    - 思路0: 对于第i个元素, 符合条件意味着左侧长度k的区间非递增, 右侧长度k的区间非递减. 因此考虑滑动窗口: 计算窗口内的增加元素数量.
        - 这样, 对于每个idx, 从左往右和从右往左计算 validL, validR, 汇总所有符合条件的idx即可.
        - 这里具体实现上复杂了: 先用 isUpL, isUpR 记录每个idx是否左/右上升, 然后滑动窗口计算 validL, validR. [here](https://leetcode.cn/problems/find-good-days-to-rob-the-bank/solution/gong-shui-san-xie-qian-zhui-he-yun-yong-gf604/) 指出滑动窗口可以通过前缀和直接得到.
    - 思路1: [官方](https://leetcode.cn/problems/find-good-days-to-rob-the-bank/solution/gua-he-da-jie-yin-xing-de-ri-zi-by-leetc-z6r1/)解答
        - 没有必要限制窗口大小: 对于每个元素, 分别维护左右非递增元素的数量, 只需要判断 `left[i] >= time and right[i] >= time` 即可.
- 2101. 引爆最多的炸弹
    - 每一个炸弹由 (x,y,r) 所定义, 若另一个炸弹在该炸弹的r范围内, 则可连环引爆. 要求返回最多引燃一个可以引爆的炸弹数量.
    - 思路: 构图后BFS
    - 注意: 这里炸弹之间是有向边! 因此不是 #并查集 ! 思路, 对于炸弹两两构建有向边, (复杂度 n^2), 然后从每个点出发 BFS (整体复杂度n*n^2), 找到最大可引爆数.
- 2102. 序列顺序查询 #hard #题型 #优先队列
    - 比较特殊的插入和查询要求: 实现一个数据结构, 支持插入元素, 查询大小为第 k 个元素. 这里的查询有些特殊: 第i次查询需要返回的是第i大的元素.
    - 复杂度: add, get 两种操作的复杂度为 1e4. 元素结构为 (score, name) 要求 score 降序 name 升序. score 范围 1e5.
    - 思路0: #二分 理论的插入复杂度为 O(n), 但这里没有掐直接过了.
    - 思路1: 考虑本题的特殊性: 每次查询的元素是特定的. 具体而言, 我们每次关心的只是查询次数k附近的元素.
        - 因此, 可以分别维护一个最小堆MinHeap 和最大堆MaxHeap: 用最小堆存储前k大的元素, 用最大堆存储其他元素.
        - 每次查询时, 返回最大堆堆顶元素即可
        - 而插入时, 若元素比 MinHeap 堆顶元素大, 则 pushpop, 然后加入到 MaxHeap; 否则直接入 MaxHeap.
    - Python: 注意heapq只提供了最小堆 (优先队列), 并且需要对于数字和字符串按照不同的方式排序, 因此需要手动写数据结构实现 `__lt__` 或 `__gt__`. 例如对于最小堆而言, 更小的元素优先, 则较小元素的 `__lt__` 函数应该返回 True.
    - 技巧: Python 的 sortedcontainers 还提供了现成的 SortedList 使用. 插入、删除的复杂度约为 O(log n).

### D68

- 2114. 句子中的最多单词数
- 2115. 从给定原材料中找到所有可以做出的菜
    - 给定一个菜单, 每道菜的成分可能包括食材或其他的菜品, 要求在一定的初始食材下能够得到的所有菜品
    - 思路一: 本题数据量比较小, 可以暴力遍历. 用一个 flag 记录一次遍历是否有新的菜品(食材) 生成, 当没有时即结束
    - 思路二: 依赖关系构成图, 显然可以用 `拓扑排序` 解决, see [here](https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/solution/cong-gei-ding-yuan-cai-liao-zhong-zhao-d-d02i/)
- 2116. 判断一个括号字符串是否有效 `中`
    - 给定一个在某些位上固定的字符串 (例如 `s = "))()))", locked = "010100"`), 判断能够通过修改其他自由位使其成为合法的括号序列
    - 思路一: 关注 lock 部分 (剩下偶数个自由位一定可以匹配)
        - 先尝试匹配 lock 部分的字符串, 记录未成功匹配的位置 (三种情况, 最后剩下 `((`, `))` or `))((`; 和 空白符号的位置;
        - 利用 space 字符串来匹配剩下的左右括号 leftStack, rightStack
        - 原本分了上面三种情况讨论, 实际上可以合并: 用 space 最前面的部分匹配右括号, 最后面的部分匹配左括号, `len(spaces)>=len(leftStack)+len(rightStack) and all([i>j for i,j in zip(spaces[-len(leftStack):], leftStack)]) and all([i<j for i,j in zip(spaces[:len(rightStack)], rightStack)])`
    - 方法一：数学, see [here](https://leetcode-cn.com/problems/check-if-a-parentheses-string-can-be-valid/solution/pan-duan-yi-ge-gua-hao-zi-fu-chuan-shi-f-0s47/)
        - 定义了有效字符串「分数」的概念, 然后通过: 维护 1. 前缀 s[0..i] 可以达到的最大分数；2. 前缀 s[0..i] 「可以达到的最小分数」及「作为有效前缀所需的最小分数」两者的较大值. 这两个数组来进行判断.
- 2117. 一个区间内所有数乘积的缩写 `难`
    - 放弃了
    - 参见 [思路详解+详细讨论一下精度问题](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/fen-bie-ji-suan-qian-5wei-he-hou-5wei-si-dc9x/), Python 超时了. 另外 [here](https://leetcode-cn.com/problems/abbreviating-the-product-of-a-range/solution/yi-ge-shu-ju-tuan-mie-jue-da-bu-fen-dai-234yd/) 做了更多的分析

### D69

- 2129. 将标题首字母大写
- 2130. 链表最大孪生和
- 2131. 连接两字母单词得到的最长回文串
    - 给一组长度为2的字符串, 将他们拼接, 形成最大的回文串
    - 考虑 1. aa 的形式, 若数量为奇数, 只能放在中间, 若为偶数, 可以两侧对应位置放置; 2. ab + ba 的形式, 左右对称放置
- 2132. 用邮票贴满网格图
    - 给一个矩阵grid, 其中数字为1的位置不能使用; 要求用 stampHeight x stampWidth 的邮票去贴满所有空的位置, 返回能否实现. 矩阵不可旋转, 可以重叠.
    - 二维前缀和 + 二维差分
        - from [here](<https://leetcode-cn.com/problems/stamping-the-grid/solution/wu-nao-zuo-fa-er-wei-qian-zhui-he-e>
        - r-wei-zwiu/)
        - 首先, 利用 **二维前缀和矩阵** 可以快速计算 (x1,y1), (x2,y2) 区域内的元素和.
            - 前缀和 `m[x,y]` 表示 (0,0),(x,y) 所定义的矩阵之和;
            - 递推计算公式为 `m[x+1,y+1] = m[x+1,y]+m[x,y+1]-m[x,y]+matrix[x,y]`. 这里的前缀和矩阵 m 有哨兵, 即大小为 (m+1,n+1)
            - 利用二维前缀, 求 (x1,y1),(x2,y2) 所定义的子矩阵之和的计算公式为 `m[x2+1,y2+1] - m[x2+1,y1] - m[x1][y2+1] + m[x1,y1]`.
            - 在本题中, 计算grid的前缀和矩阵, 即可以用来判断该区域内是否有1.
        - 根据二维前缀和的计算, 可以定义 **二维差分矩阵**. 另参见 [here](https://zhuanlan.zhihu.com/p/439268614)
            - 计算公式为 `s[x,y] = matrix[x,y] - matrix[x-1,y] - matrix[x,y-1] + matrix[x-1,y-1]` (注意和上面前缀和的递推计算意义不一样)
            - 可知, 我们所定义的差分矩阵, 其前缀和就是原矩阵!!
            - 根据差分矩阵, 我们可以快速在 (x1,y1), (x2,y2) 范围内都加上一个数字: 等价于在其差分矩阵的 `(x1,y1),(x2+1,y2+1)` 位置+1, `(x2,y1+1),(x1+1,y2)` 位置-1.
            - 在本题中, 利用对于每个为空的坐标,尝试以其为左上角贴邮票, 利用差分矩阵记录贴上去的邮票所占据的位置. 最后利用差分矩阵还原, 计算每个位置的邮票数量, 若出现原本为空的位置没有贴上邮票, 说明不满足.
        - 注意, 为了边界条件, 1. 这里定义的前缀和矩阵第一行第一列为0; 2. 而根据差分的定义, 在更新(x2,y2)位置时候用到了 s(x2+1,y2+1), 因此形状也为 (m+1,n+1).

### D70

- 2144. 打折购买糖果的最小开销
- 2145. 统计隐藏数组数目
- 2146. 价格范围内最高排名的 K 样物品
    - 网格搜索, 0表示不能走, 不同的格子有价格, 要求找到价格在 pricing = [low, high] 区间内的位置.
    - 要求找到优先级最高的k个, 优先级为: 1. 距离; 2. 价格; 3. 行坐标; 4. 列坐标.
    - 思路: BFS.
        - 广度优先, 每一轮维护 paths 记录当前可到达的坐标, potentials 为满足pricing约束的坐标集合, 然后 `select(potentials, k)` 根据优先级筛选.
        - 注意边界条件: 1. 每一轮中,当paths为空时说明无法继续搜索; 2. 开始状态, 需要判断start点是否符合要求并加入visited.
- 2147. 分隔长廊的方案数
    - 简单

### D71

- 2160. 拆分数位后四位数字的最小和
- 2161. 根据给定数字划分数组
- 2162. 设置时间的最少代价
    - 设置四位的时间, 前后两位分别表示分钟和秒钟, 例如 `8090` 表示 80*60+90 秒
    - 给定 startAt ，moveCost ，pushCost 和 targetSeconds 分别表示初始的手指位置, 移动和按按钮的代价, 以及目标的秒数, 要求返回最小的代价. **前置0可以不输入**
    - 思路: 模拟
        - 注意到, 犹豫两位数字可以大于59, 因此同样的秒数可能有多种表示. 除了 1. 基本的 `minutes, seconds = targetSeconds//60 , targetSeconds%60`, 还有可能 2. 是 `minutes-1, seconds+60` (`seconds+60<100`), 计算两者较小的代价.
        - 用函数 `getCost(minutes, seconds)` 模拟该方案的代价.
        - 需要注意边界: 1. 当 `targetSeconds<60` 时 第二种方案非法; 2. 当 `targetSeconds>=60000` 时, 第一种方案非法. 因此可以在 getCost 函数中增加判断: `minutes>99 or seconds>99 or minutes<0 or seconds<0` 时返回 Inf, 更简单.
- 2163. 删除元素后和的最小差值
    - 给一个长度为 3n 的数组 nums, 要求删除其中 n个数字, 使得删除后, 数组前n个数字之和 - 后n个数字之和最小.
    - 方法一：优先队列 [here](https://leetcode-cn.com/problems/minimum-difference-in-sums-after-removal-of-elements/solution/shan-chu-yuan-su-hou-he-de-zui-xiao-chai-ah0j/)
        - 目标: 前n个数字之和最小, 后n个数字之和最大.
        - 可知, 最后剩余的两组数字, 其原始的分割点一定在 [n, 2n] 之间. 因此, 可以 遍历遍历每一个分割点, 分别计算前后的最小和最大和, 然后求最小值.
        - 为此, 可以分别建立一个最大堆和最小堆, 遍历 [n, 2n] 个数字 (pushpop), 记录每一个分割点的的值. 需要注意的是, 后半部分应该逆序, 注意代码.

### D72

- 2176. 统计数组中相等且可以被整除的数对
- 2177. 找到和为给定整数的三个连续整数
- 2178. 拆分成最多数目的偶整数之和
- 2179. 统计数组中好三元组数目
    - 给两个数组, 分别是 [0:n-1] 的一个排序, 要求找满足条件的三元组数量, 条件: (x,t,z) 出现在两数组中的次序是一致的.
    - 分析可知, 将nums1中数字在num2中的index依次写出来, 记为 numMap, 则结果就是该数组中递增的三元组的个数
    - 思路1:
        - 遍历 numMap, 对于一个数字 num, 考虑以num结尾的长度为2的递增数组的数量 —— 为数组之前部分比num小的元素数量; 记为 last1
        - 进一步考虑以num结尾的长度为3的递增数组的数量, 可知其为 last1 中, 所有小于num的组数之和.
        - 因此, 这里的核心问题在于: 实现一个数据结构, 可以 1. 查询其中比 query 小的数量; 2. 插入某一个数值的数量.
        - 该问题可以建模为 「**树状数组/线段树**」, 参见 [here](https://oi-wiki.org/ds/fenwick/)
    - 思路2 树状数组:
        - 已知, 问题可以转化为, **在一个数组中计算递增三元组的数量.**
        - 分别用两个 BIT, 计算位置i之前的比 num[i] 小的数量, 以及位置i之后的比 num[i] 大的元素数量. 这样最终的结果就是 `sum(low[i]*high[i] for i in range(n))`
    - 另见 [here](https://leetcode-cn.com/problems/count-good-triplets-in-an-array/solution/deng-jie-zhuan-huan-shu-zhuang-shu-zu-by-xmyd/)

### D73

- 6024. 数组中紧跟 key 之后出现最频繁的数字
- 5217. 将杂乱无章的数字排序
- 5300. 有向无环图中一个节点的所有祖先
    - 给一个 DAG, 要求返回每一个节点的所有祖先节点 (排序)
    - 思路一: 可以通过 DFS 找到节点的所有孩子, 在 **逆图** 上做即可
- 5237. 得到回文串的最少操作次数 #hard
    - 给一个字符串, 仅有的操作为交换相邻两个字符, 要求转为回文串的最小交换次数
    - 思路一: 两次贪心 [here](https://leetcode-cn.com/problems/minimum-number-of-moves-to-make-palindrome/solution/de-dao-hui-wen-chuan-de-zui-shao-cao-zuo-nnis/)
        - 首先需要理解: **逆序数** 等于一个 序列要变成升序排列所需要的相邻元素交换的最小次数。 see [here](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/ni-xu-shu-yu-pai-xu-de-nei-zai-lian-xi-wu-dai-ma-b/)
        - 先考虑偶数长度的情况: 可知, 对于 2m 个字符ch, 其中的前m个字符, 也一定在最终的回文串的前一半中, 并且它们之间的相对位置保持不变.
            - 因此, 分解为两步: (1) 组间交换. 先划分左右两个子串. 由于不改变相对位置, 其实我们就知道了原本字符串的每一个位置的元素, 在分为好左右组的字符串中的位置.
            - (2) 组内交换, 也即是的左右子串转换为对称. 由于没有相对位置变化, 因此我们固定左子串, 则对于右子串中每一个字符最终的位置其实我们就确定了 —— 等于求逆序数.
        - 而对于奇数情况, 简单令右子串多一个元素, 然后在左子串后加上那个中心的(奇数)字符, 则约束了右串排序中将其移动到中间.
    - 思路二: 贪心 [here](https://leetcode-cn.com/problems/minimum-number-of-moves-to-make-palindrome/solution/tan-xin-zheng-ming-geng-da-shu-ju-fan-we-h57i/)
        - 其实在上面的思路中, 我们已经知道了最终的回文串是怎样的 —— 左子串由所有字符的前一半出现位置决定, 右子串对称.
        - 因此, 更为贪心的策略是: 每次保留左侧的第一个字符, 将最右边的该字符移动到右侧, 这样就完成了匹配.
        - 对于奇数的情况, 只需要将其移动到中心即可.

### D74

- 2206. 将数组划分成相等数对
- 2207. 字符串中最多数目的子字符串
    - 有可以字符串 text 和长度为 2 的 pattern (记为字符 a 和 b), 可以对 text 插入一个字符 a/b.
        - 要求计算操作后 text 的子字符串恰好是 pattern 的数量. 注意「子字符串」的定义不要求连续, 因此 `aabb` 包括 四个子字符串 `ab`.
    - 思路: 注意到, 这里插入的字符最优解为在最前面插入a 或最后插入b (取决于text中a/b的数量). 而原本text自身的子字符串数量可以 O(n) 求解 (记录 countA, countB).
        - 特殊情况: a==b
- 2208. 将数组和减半的最少操作次数
    - 每次选择数组中的一个元素减半, 要求使得数组和减半需要的次数.
    - 思路: 每次选最大的即可. 采用 heap 实现. 注意 heapify 默认是最小堆, 因此需要取反.
- 2209. 用地毯覆盖后的最少白色砖块
    - 给一条黑白地板 floor 铺地毯, 要求剩余最少的白色. 给定 numCarpets 条长度为 carpetLen 的黑色地毯.
    - 思路: DP
        - 定义状态: dp[i][j] 表示用 i 条铺 **前面 j 个地砖**, 剩余的最少白色砖块数.
        - 状态转移: dp[i][j] = min(dp[i][j-1]+(floor[j]=="1"), dp[i-1][j-carpetLen]). 其中第一式表示不用地毯.
        - 参见 [here](https://leetcode-cn.com/problems/minimum-white-tiles-after-covering-with-carpets/solution/by-endlesscheng-pa3v/)

### D75

- 2220. 转换数字的最少位翻转次数
- 2221. 数组的三角和
    - 对于一个数组, 重复进行如下操作, 直到长度为 1, 返回最后的数据
        - 将相邻两个元素相加, 得到新的长度 -1 的数组.
    - 分析可知, 就是杨辉三角, 调用 math.comb(n-1, i) 即可.
- 2222. 选择建筑的方案数
    - 有两类建筑, 要求从中选择三栋, 选择的三个中相邻的类别不能相同. 返回所有方案的数量.
    - 思路: 1) 考虑中间的那栋楼, 则两侧的选择必须是另外一个类型; 2) 为了计数, 考虑 cumsum; 3) 为了避免确定变量, 可以讲 "001101" 转为 [2,2,1,1] 的形式
        - 具体而言, 可以分别从左到右, 从右到左计算累加和 (间隔为2的累加和, 例如上例为 [2,2,3,3]), 然后直接 `cumsumLeft[i-1] * newS[i] * cumsumRight[i+1]` 即可.
    - 写得复杂了, 由于形式只可能为 010/101, 实际上遍历一次index即可; 记录下目前已有的 1, 则遇到0时, 以这个0为中间数的方案数为 `count_a * total_a - count_a`, 参见 [here](https://leetcode-cn.com/problems/number-of-ways-to-select-buildings/solution/xuan-ze-jian-zhu-de-fang-an-shu-by-leetc-jhup/)
- 2223. 构造字符串的总得分和 #hard
    - 对于一个字符串, 从右往左得到长度为 1,2,... 的连续子串, 分别计算该子串与原字符串的最大前缀长.
    - **Z 函数**（**扩展 KMP**） 参见 <https://oi-wiki.org/string/z-func/>
    - 我们定义 Z 函数为: **z[i] 为 s[i:n-1] 与原字符串 s 的最长前缀匹配长度**.
        - 也即, `s[i:i+z[i]-1] = s[0:z[i]-1]` (闭区间), 称为 匹配段, 也可以叫 **Z-box**
    - 核心是要维护一个匹配区间 [l,r] (Z-box)) 满足该区间为前缀匹配; 在遍历过程中, 维护 `l<=i`.
        - 对于遍历到的 i, 若 `i<=r`, 此时有 `s[i:r] = s[i-l:r-l]` (闭区间),
            - 若还满足 `z[i-l]<r-i+1` (区间 [i,r] 的长度为 r-i+1, 我们已经在遍历 i-l 时发现了前缀匹配长度比它小), 则有 z[i] = z[i-l]
            - 否则, 说明 [i,r] 区间是前缀, 从 r+1 开始继续匹配
        - 若不满足 `i<=r`, 则从 i+1 开始继续匹配 (和上面的情况2一样)
        - 注意当我们遍历超过 r 时需要更新 `l, r = i, i+z[i]-1` (显然维护的条件 `i<=l` 仍满足)
    - 复杂度分析 (看下面的代码): 外层 i 循环一遍, 内部的 while 训练每执行一次都会使得 r 向后移动, 因此最多执行 O(n) 次; 所以总的复杂度为 O(n).

### D76

- 2239. 找到最接近 0 的数字
- 2240. 买钢笔和铅笔的方案数
- 2241. 设计一个 ATM 机器 #medium
    - 难度不大. 需要写一个类. 通过这题希望写一个函数进行本地调试.
- 2242. 节点序列的最大得分
    - 给一张带节点权重的无向图, 求长度为4的节点序列的最大得分. 序列之间需要连接, 四个节点不得重复.
    - 复杂度: 节点和边均为 5*1e4
    - 思路: 直接遍历肯定会超时. 关键看这里的序列长度为4, 因此可以考虑 **遍历中间的两个节点** (边)
        - 进一步降低复杂度: 从边 uv 的两个节点出发, 各拓展出一个节点 a,b; 为了使得分数和最大, 则搜索的 ab 节点权重必然是最大/次大的; 因此, 仅需要对每个节点维护最大的三个邻居即可 (还要考虑 uv 边可能最最大邻居)
        - 在简化了搜索空间的基础上, 可以用 `itertools.product(neighbors(u), neighbors(v))` 直接遍历所有可能的节点对, 而不需要 uv 的邻居进行排序比较等复杂的判断.
        - 参见 [here](https://leetcode-cn.com/problems/maximum-score-of-a-node-sequence/solution/by-endlesscheng-dt8h/)

### D77

- 6051. 统计是给定字符串前缀的字符串数目
- 6052. 最小平均差
- 6053. 统计网格图中没有被保卫的格子数
    - grid 上有一组墙和一组guard, 守卫可以守护上下左右四个方向的格子, 遇到墙就停止. 要求累计grid中没有被守卫守护的格子数.
    - 思路: 对于每个guard 的四个方向遍历即可, 时间复杂度 O(m*n*4)
- 6054. 逃离火灾 <https://leetcode-cn.com/problems/escape-the-spreading-fire> #hard
    - 给定一个 grid, 有一组火源和一组墙, 每过一个时刻, 火网四周蔓延一圈, 但是不能穿过墙. 人要从左上角逃到右下角, 问人能够在起点等待的最长时间.
    - 思路1: #BFS.
        - 1) 先从所有的火点开始进行BFS, 记录所有点距离火的位置; 2) 然后从起点出发BFS, 对于路径上的每一个点, 火到达的时间为 `fireDist[(nx,ny)]`, 而距离为 `nd`, 因此:
            - 若 fireDist[(nx,ny)]<=nd 说明火先到达, 该点探索失败; 否则, 所能等待的时间为 `nLimit = fireDist[(nx,ny)] - nd - 1`;
        - 3) 这样, 进行 BFS遍历后, 若能到达终点, 该条路径的最大等待时间为 `max([nLimit])`.
        - 繁琐的是要处理边界情况: 当人和火同时到达终点时, 算成功逃生.
        - 另外, 在本题中, 可能出现多条路径都能到达终点的情况, 因此遍历到终点后, 不能直接返回!
    - 注意: DFS 若要不重复访问节点, 就要用visited记录访问的点; 但第一次访问不一定是最短, 因此无法得到最短路径; 若要得到最短路径, 就只能记录当前路径经过的点, 会带来重复访问的问题!
        - 用BFS 同样可以记录路径: 只需要记录当前路径经过的点即可, 增加少量的存储开销
    - 一开始纠结于BFS如何记录路径的问题, 采用DFS求最短路径, 结果因为重复访问超时了
    - 思路2: #二分
        - [灵神](https://leetcode.cn/problems/escape-the-spreading-fire/solution/er-fen-bfspythonjavacgo-by-endlesscheng-ypp1/)
        - 我们可以快速检查等待时长t是否可行.
        - 因此, 相较于上面的分析, 直接二分更为方便.

### D78

- 2269. 找到一个数字的 K 美丽值
- 2270. 分割数组的方案数
- 2271. 毯子覆盖的最多白色砖块数 #medium #双指针
    - 给定一组 [l,r] 所定义的白色砖块 (闭区间), 这些区间之间不重叠. 给一个长度为 carpetLen 的地毯, 要求返回最多可以覆盖的地砖数.
    - 思路: #贪心 注意到, 如果毯子覆盖多个区域, 我们手动令毯子的最左侧放在最左边那个区间的左端点上即可.
        - 具体而言, 可以用双指针 (i,j) 来记录毯子可以覆盖的范围, 并且用一个数字记录当前指针范围内的白色砖块数量. 遍历 j:
            - 当 `tiles[j][1] - tiles[i][0] + 1 <= carpetLen` 时, 说明足够长 j+=1
            - 否则, 需要更新答案 `ans = max(ans, tmp + max(0, carpetLen + tiles[i][0] - tiles[j][0]))` 并更新 i+=1
- 2272. 最大波动的子字符串 #题型 #hard
    - 定义字符串的波动为「出现次数 最多 的字符次数与出现次数 最少 的字符次数之差」. 要求计算一个字符串中, 所有可能的连续子串的波动最大值.
    - 注意, 这里有一个限制是, 加入最多最少的字符是 a/b, 则要求b一定要在子串中出现.
    - 复杂度: 长度为 1e4
    - 思路1: 转为 #最大子数组和 问题 + 变形
        - 注意到, 假若我们关注的是 a/b 次数之差, 则将它们记作 +1/-1, 其他字符记作 0, 则问题转为求子数组最大和问题. 题目复杂度为 1e4, 暴力遍历 a/b 的组合即可.
        - 需要注意的是, 与原问题不同之处在于, 题目要求子串中一定要包括 b: 而原本 最大子数组和 的DP: `dp[i+1] = dp[i] + nums[i+1] * (nums[i+1] > 0)` 无法记录是否包含了b.
        - 为此, 相较于记录两数字之差的 `diff` (dp迭代的数字), 这里加了一个辅助变量.
            - 当遇到 b时, 我们先            00000000000 `diff -= 1` 并且用 `diff_with_b = diff` 记录, 然后再 `diff = max(diff, 0)` 更新;
            - 当遇到 a时, 直接对于 `diff, diff_with_b` +1.
        - 注意到, 相较于 diff>=0, 这里的变量 diff_with_b 最小值为 -1 (延后执行了 max(0, diff)), 因此是「包含了b的a/b最大差」.
        - 优化: 上面的时间复杂度为 O(n * 26^2), 空间复杂度 O(1)
            - 注意到这里 a/b 之外的字母取值都为 0, 而我们每次是针对 a/b 更新的, 因此实际上计算浪费了.
            - 可以用 diff[a][b] 记录两字母的差值, 随着对于字符串的遍历更新矩阵中的相关元素. 这样, 计算复杂度为 O(n * 26).
            - 具体见 [here](https://leetcode.cn/problems/substring-with-largest-variance/solution/by-endlesscheng-5775/)
    - 思路2: 动态规划
        - [这里](https://leetcode.cn/problems/substring-with-largest-variance/solution/mei-ju-chu-xian-zui-duo-he-zui-shao-de-z-g9gz/) 给出了更容易想到的思路
        - 我们用 dp0 正常求解最大子数组和; 另外用一个 dp1 记录「以第i个字符结尾的, 至少包括一个b的的最大差值」.
        - 注意两者的更新公式区别在于, `nums[i+1]==b` 时后者需要考虑 dp0[i] 的转移.

### D79

- 6083. 判断一个数的数字计数是否等于数位的值
- 6084. 最多单词数的发件人
- 6085. 道路的最大总重要性
- 10011. 以组为单位订音乐会的门票 #hard #线段树 #题型
    - 场景是一个订票系统, 有n排座位每排m座. 要求实现两种需求: 1) gather(int k, int maxRow) 要求在 maxRow 以下的行中(同一行中)有连续k个座位; 2) scatter(int k, int maxRow) 要求在 maxRow 以下的行中有k个空座位 (不要求连续).
    - 思路1: #线段树
        - 灵神 [here](https://leetcode.cn/problems/booking-concert-tickets-in-groups/solution/by-endlesscheng-okcu/)
        - 先看基本的gather操作: 要求在maxRow范围内找到最小的位置进行插入, 也即求最小值, 可以用 #线段树. (注意看这里的index函数)
        - 对于 scatter操作而言, 维护一个sum线段树, 然后依次从前往后安排座位即可


### D80

- 2301. 替换字符后匹配 #hard #题型
    - 给定一个替换列表 mappings, 对于每一组字符 (old, new), 可以将待处理字符串中的任意字符 old 替换为 new. 现给定两个字符串 s, sub, 问能否通过替换操作将sub转化为s的某一子串?
    - 复杂度: 两个字符串长度 5e3, 映射数量 1e3
    - 思路1: 暴力枚举
        - 直接用一个哈希表记录一个字符串所有可能的原始字符, 然后暴力枚举s所有可能的子串, 看是否匹配
        - 复杂度: 每次检查是否可以替换得到的复杂度为 O(1), 因此总的复杂度为 O(n^2), 大概是1e7 够了
    - 思路2: #正则
        - 暴力得到正则表达式, see [here]*(<https://leetcode.cn/problems/match-substring-after-replacement/solution/-by-migeater-gdqi/>)
    - 哈哈, 大佬认真考虑了这题[为什么标成了hard](https://leetcode.cn/problems/match-substring-after-replacement/solution/shu-ju-fan-wei-geng-da-de-hua-zen-yao-zu-d9es/), 是我不懂的
- 2302. 统计得分小于 K 的子数组数目 #hard #题型
    - 定义一个连续子数组的分数: 数组和*长度. 现给定一个数组, 求分数小于k的子数组数量.
    - 约束: 数组长度 1e5
    - 思路1: #双指针
        - 遍历子数组的右端点 idx, 只需要求出最左边的满足条件的位置即可.
        - 注意到: 维护一个全局的左端点left, 当 idx右移的过程中, left也一定是右移的.
        - 因此, 双指针的复杂度为 O(n)
        - see [灵神](https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/solution/by-endlesscheng-b120/)
    - 思路2: 傻叉的 #二分
        - 一开始没考虑清楚双指针的复杂度, 仅仅利用了left是肯定不断右移的性质, 考虑每次在 [left, idx+1] 区间内二分找到满足条件的最有位置
        - 结果, 采用了bisect库中的 `key` 参数, 结果用错了Orz, 浪费了好久...
            - 因为, `bisect_right(a, x, lo=0, hi=None, *, key=None)` 中的key作用对象是 `key(a[mid])` 而不是idx!!!
        - 后面手写了二分, 结果速度比思路1慢了很多. 因为这里的复杂度变为 O(n log(n))


### D81

哇, 第二次进 30min, 排名83! see [here](https://leetcode.cn/contest/biweekly-contest-81/ranking/).

- 6106. 统计无向图中无法互相到达点对数 #medium
    - 给定一张图, 统计不可达的 (u,v) 节点对的数量.
    - 约束: 节点数量 1e5
    - 思路1: 统计所有联通分量的大小. 考虑 #反问题
        - 提示: 相互不可达的节点对属于不同的联通分量.
        - 因此, 可以统计所有联通分量, 两个联通分量之间的节点对为 size1*size2. 但这样的复杂度可能是 O(n^2).
        - 可以考虑反问题: 所有节点对 - 可达的节点对. 所有节点对的数量为 comb(n, 2), 而可达节点对在同一联通分量中, 对数为 comb(size, 2).
- 6105. 操作后的最大异或和
- 6107. 不同骰子序列的数目 #hard
    - 投骰子n次, 问满足条件的序列数量. 条件: 相邻数字的最大公约数为1, 两个相同数字之间的间距至少为3.
    - 约束: n的数量级1e4
    - 思路1: #状压 #DP
        - 可知, 第idx位置的数字可取的值仅由前两个数字决定, 只需要满足上述条件即可.
        - 考虑状态压缩, 用mask表示相邻两个数字, 采用6进制. 预计算: 所有合法的长度为2的序列, 合法的转移序列.
        - 用 `f[i][mask]` 表示长度为i, 最后两位为mask的序列数量.
        - 状态转移: `f[i+1][mask] = sum{ f[i][newmask] }`, 其中 newmask 表示第一位等于mask第二位并且符合条件的所有情况.

### D82

这次的T2,3都比较细碎, 分别WA了三四次, 根本原因在于思路不清晰吧 (晚上写确实不太在状态). T4在群友的提示下写了出来, 一开始想的时候完全忘记了「巫师」, 还是需要总结记忆啊.

- 6117. 坐上公交的最晚时间 #medium #细节 #模拟
    - 给定一组 passengers 的到达时间和 buses 的出发时间, **同组中的数字各不相同**. 每辆车有capacity限制, 若人超过了则需要等下一辆. 问你想要赶上最后一辆车, 最晚要到达车站的时间.
    - 注意: 若 `buses = [10,20], passengers = [2,17,18,19], capacity = 2` 第二辆车上的人是 [17,18], 但你不能和他们相同时间, 因此需要16的时刻到达
    - 思路1: #双指针 遍历到结尾, 然后注意最后的判断
        - 需要 #分类讨论, 一般情况下, 我们在最后一个人的后面上车即可 (掐点); 那什么情况下必须像例子一样往前遍历? 1) 人数满了, 要赶在最后一个人之前; 2) 这辆车的最后一个人的到达时间刚好为发车时间.
- 6118. 最小差值平方和 #medium
    - 化简下来, 目标是是数组中所有元素的平方和最小化, 每次可以对任意元素+/-1, 一共k次机会. 求最小值.
    - 提示: 显然, 要求所有元素的绝对值尽可能小, 每次都对于大数字做操作即可.
    - 思路1: 先对于数组排序, 然后按照 #阶梯 的方式往下减.
        - 形象化: 每次「削去」高峰, 直到操作数不够.
        - 好像前面的题目中有类似「蓄水」的题目, 肯定不是按照下面来写的? 但找不到题目了, 感觉下面的写法也挺烦的.
        - 具体如何做? 用一个哈希表记录每个高度的数量, 然后从高到低尝试「削峰」. 若操作数够, 则将当前最大值均变为次大值; 否则, 根据 divmod 将剩余操作数平均分配到这些最大值上.
    - 关联: 找相关题进行总结.
- 6119. 元素值大于变化阈值的子数组 #hard #单调栈
    - 给定一个整数数组和一个threshold, 要求找到一个整数k, 使得数组中包括一个长度为k的所有元素都大于 threshold / k 的子数字. (找到任意一个)
    - 思路1: 找到每一个元素作为最小值的左右边界. 这样, 我们可以得到哈希表 len2max, 记录每一个长度限制下, 子数组最小值的最大值.
        - 为了求左右边界, 可以利用 #单调栈 求解.
        - 复杂度: O(n)
        - 关联: 「2281. 巫师的总力量和」
    - 思路2: #并查集
        - 直觉: 对于数组中的元素, 从大到小考虑他们所在的以其为最小值的连续子数组 (满足当前元素是最小值), 依次判断是否满足条件即可.
        - 如何记录连接关系? 采用并查集. 但题目要求是相邻的两个才能连接, 如何做? 下面的思路是: 每次将被遍历的元素连接到其右侧节点上 (在最右侧加一个哨兵). 这样, **对于第i个节点, 合并到i+1节点之后, i元素的值是 `sz[j] - 1` 个元素只最小的那个**! 这是因为, 由于从大到小访问, 第i节点的大小必然是1. 若i+1节点更小, 则其大小也为1; 若i+1节点更大, 则它是一条链并且最右侧一定连着一个更小的点, 也符合上述论述.
        - 复杂度: 排序 O(n logn)
        - from [灵神](https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/solution/by-endlesscheng-j6pp/)
    - 总结: 思路1是更为清晰的, 关键是要想到「某一元素最为最小值的左右边界」, 之前做过巫师题的情况下, 一开始没有想到有点可惜. 思路2用到并查集, 灵神的代码很简洁, 但实际上的思维量还挺大的.

### D83

T1, T3 各失误错了一次, T4 因为理解错题意WA了无数次...结果总用时 1h54min. 只能说是大失误. 结果排名700+

- 6131. 不可能得到的最短骰子序列 #hard #题型
    - 给定一个面为 `1...k` 的骰子, 然后长度为n的rolls结果. 要求得到一个最短的数组, 其在rolls的所有子序列中不存在.
    - 问题等价于, **求长度l, 满足 k^l 种长为l的不同序列在rolls中都存在**.
    - 提示: 什么情况下, 最后一个元素为x 并且长为l的排列都存在? 假设所有长为l-1的序列中, 最靠前的末尾位置是tails. 那么要求都存在, 则要求在 `max(tails)+1:` 的范围内存在数字x.
    - 思路1: #转换 #模拟
        - 根据提示, 对于任意的数字, **若要求能够以其结尾的所有的长l的序列都存在, 则需要在 `rolls[max(tails)+1:]` 范围内存在该数字**.
        - 具体, 在遍历rolls过程中, 可以用一个set记录未出现的数字, 当set为空时, 说明该长度的所有序列都存在. 结果+1, 重制set.
    - 思路0: 一开始错理解为k的所有permutation... #error 下面简单记录思路
        - 用一个 num2idxs 数组记录所有的数字出现的位置.
        - 然后, 对于非重复序列的长度进行遍历.
            - 用 `perm2idx` 记录 perm 的首次出现的末尾位置, 例如 perm2idx[(3,1)] 记录最靠左的 (3,1) 序列中1的位置.
            - 在每次遍历过程中, 每次在后面可以填充的数字是 `x in set(range(k)) \ set(perm)`, 我们在 `num2idxs[x]` 中二分查找 `perm2idx[perm]`. 若找不到则失败
        - 复杂度: 似乎挺高? 但可能的结果应该不是很大? 没分析过, 但 `math.perm(10, 10)` 的数量级就很大了...
    - 总结: 要看清题意啊!!!

### D84

手速场, 居然是T2比较绕. 22min拿了[51名](https://leetcode.cn/contest/biweekly-contest-84/ranking/).

- 6142. 统计坏数对的数目 #medium
    - 给定一个数组, 对于 (i,j), `i<j` 假如 `j - i != nums[j] - nums[i]` 则是一个「坏数对」. 统计数组中坏数对数量.
    - 思路1: 对于位置为idx的大小为num的元素, 其对应到位置0的大小应该是 num-idx, 用一个 Counter记录位置0出现各个数字的次数.
- 6174. 任务调度器 II #medium 贪心即可
- 6144. 将数组排序的最少替换次数 #hard 但完全不难. 对于一个数组, 每个可以将其中的一个数字拆分成两个数字之和. 问最少操作使其变为「非递减」.
    - 思路1: 逆序, 贪心保留最大的拆分结果.

### D85

T1 原来用滑动窗口就可以, 想复杂了写了乱七八糟的DP; T2也是很细节的模拟; T3的差分有一定难度; T4庆幸之前写了写并查集比较清晰. 总结: 难度显著提升的情况下, 对于问题的理解不够到位, T1和T3的思路都不清楚, 看到灵神的解答后有种恍然大悟.

- 6156. 得到 K 个黑块的最少涂色次数 #easy #滑动窗口
    - 有黑白格子, 每次操作可以涂黑一个白色, 问得到k个连续黑格的最小操作. 限制: n 100
    - 思路0: #DP 感觉好蠢 复杂度 `O(n^2)`
        - 记 `f(c,i)` 表示在c次操作以内, 以i结尾的连续黑块的起始位置 (-1)
        - 递推: 若i为黑格, 则f(c,i) = f(c,i-1); 否则, f(c,i) = f(c-1,i-1)
        - 初始化: 可以用一个变量维护最近出现的白色位置
    - 思路1: 目标是长为k的一个子数组, 因此直接 #滑动窗口 取最小值即可. 复杂度 `O(n)`
        - [灵神](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solution/on-hua-dong-chuang-kou-by-endlesscheng-s4fx/) 利用zip简化了代码.
- 6157. 二进制字符串重新安排顺序需要的时间
    - 给定一个二进制字符串, 在每一轮中, 将所有的 01 转换为 10. 问经过多少次操作后终止? 限制: 1000
    - 思路1: #模拟 复杂度 O(n^2)
    - 思路2: 一次遍历, 复杂度 O(n)
        - 显然, 每次操作的过程会将1往左移动. 模拟「车辆移动」的过程; 特殊在于, 只有当一辆车前面有空格时才能前进.
        - 用DP, 记 `f[i]` 为将前i个字符移动所需的时间.
        - 递归: 若 s[i]==0, 则 `f[i] = f[i-1]`; 否则, 考虑两种情况: 1) 假如前面有 pre0 个0, 则移动的步骤至少为 pre0步; 2) 但连续的两辆车可能会「堵车」, 但 **若发生堵车, 它和前一辆车的距离最多有一个空格**, 因此这种情况下时间为 `f[i-1]+1`. 综合考虑即 `f[i] = max(pre0, f[i-1]+1)`.
- 6158. 字母移位 II #medium 就是一道 #差分 题
    - 限制: 序列长度, 区间操作数 5e4;
- 6159. 删除操作后的最大子段和 #hard
    - 给定一个长n的数组, 然后给一个n的全排列, 定义了每次删除的元素顺序. 要求返回在每一步删除操作后, 剩余元素所构成的区间中的最大区间和.
    - 思路1: #逆向 考虑, 用 #并查集 记录相连情况.
        - 细节: 由于逆向过程中只有一部分的点才是合法的(未被删除), 可以用一个set来记录合法的点.
        - 在逆向「加点」的过程中, 连接合法的左右邻居(所对应的区间), 更新全局的mx.
    - 关联: 2334. 元素值大于变化阈值的子数组 也是逆序并查集 参见 [线段树]
    - from [灵神](https://leetcode.cn/problems/maximum-segment-sum-after-removals/solution/by-endlesscheng-p61j/)


### D86

T2 不知道是否有数学解法; T3 复杂度分析一开始没想好; T4 的题目描述也有点奇怪, 虽然最后实现比较简单就是...


## 其他

### 2022 年度杭州

[比赛](https://leetcode.cn/contest/zj-future2022) 这类附加赛的题目好像不在题库中?

- zj-future03. 快递中转站选址 #medium 关联 0465 Optimal Account Balancing
    - 在一个grid上有一组快递分发点, 想要加一个中转站, 问放在哪里, 它距离所有分发点的曼哈顿记录之和最小?
    - 提示: 两个坐标的计算是可分离的!
    - 思路1: 计算 #中位数 即可
        - 等价于, 在一个坐标轴上有一系列的点, 找一个点, 使其与所有点的距离之和最小. 注意到, 该问题的解就是中位数!
- zj-future04. 门店商品调配 #hard
    - 问题转化: 有一组门店借出, 另一组调入. 每次操作用a转x个物品到b门店, 问最少的操作次数.
    - 限制: 门店数量12
    - 提示:
        - 对于一组大小为s的借入借出关系 (和为0), 最多的最优操作是多少次? `s-1`. (一种naive的方法是, 先将正数集中到一个人, 然后一次分配给其他的负数)
    - 思路1: #状压 #DP
        - 我们考虑用DP, 记 `f[mask]` 为mask所表示的一组店, 用多少次可以平衡. 可知若该组之和≠0则不能平衡, 定义为inf.
        - 当所选组可以平衡的时候, 可考虑递归 `f[mask] = min{ mask.bit_count()-1, f[subset]+f[mask\subset] }`. 也即考虑最坏情况和所有的可递归子问题.
        - 复杂度: 枚举所有子集 `O(n^3)`. see [灵神](https://leetcode.cn/circle/discuss/3p5v9B/view/8FQhy2/)
    - 思路2: 暴力 #DFS
        - 我们仅考虑没有平衡的账户. 然后遍历idx, 对于每一个idx, 检查在其后的账户, 若两者符号相反, 将idx的值加到后者上 (不管绝对值谁大谁小), 然后后移idx.
        - 正确性: 实际上我们利用了提示中的上界, 遍历了所有的情况.
        - 参见 「0465 Optimal Account Balancing 最优账户平衡」 (会员题, 见 [here](https://developer.aliyun.com/article/336702))
    - 总结: 关键是想到提示中的上界, 然后思路1其实枚举了所有的情况; 思路2更加暴力点, 代码更简单但理解更玄学.
