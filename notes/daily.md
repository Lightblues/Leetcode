
## 每日一题

- 0219 存在重复元素 II
  - 一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k
- 2029. 石子游戏 IX `中` 但实际上可以说很难!
  - 分别取石子, A优先, 两条规则
    - 当某个人取出后总和为 3的倍数时, 其失败;
    - 当取完所有的石子, 条件1不成立, 则 A 失败(不管最后一个是谁取的).
  - 博弈, 参见 [官方解答](https://leetcode-cn.com/problems/stone-game-ix/solution/shi-zi-you-xi-ix-by-leetcode-solution-kk5f/).
  - 首先的失败条件是取出的石子总和为 3, 因此可将石子除以3的余数为 0,1,2 分成三类
  - 先不考虑 0, 假设只有 1,2. 由于每个人都是最佳决策, 因此只会出现
    - `1,1,2,1,2,1,...` 或者 `2,2,1,2,1,2,...` 的序列. 也即除了第一颗, 两个都回去相同的石子.
    - 条件 1 的失败条件为对方没有可取的石子, 因此 A 的策略是取数量少的那一类.
      - 以 `1,1,2,1,2,1,...` 序列为例, A 获胜条件为: 有类型 1 的石子并且数量少于类型 2, `0 < cn1 <= cn2`
    - 综合两种情况, A 获胜条件为 `cnt1 >= 1 and cnt2 >= 1`
  - 还要考虑 1, 当 0 的数量为偶数时, 条件不改变. 考虑 0 有奇数个
    - A 的策略仍然是选择较少的类, 然而此时 B 可以有一次选类型 0 石子的机会, 因此条件变为
      - `cnt1 - cnt2 > 2 or cnt2 - cnt1 > 2`
- 1345. 跳跃游戏 IV `难`
  - 给一个数组, 只能前后一格, 或者跳到相同数字的格子上, 求到达终点的最小跳数
  - 显然可以建模为最短路径问题;
  - 然而直接建图 BFS 超时了. 问题在于, 当存在大量点的数字相同, 变为稠密图, BFS 复杂度为 `O(n^2)`
  - 方法一：广度优先搜索 see [here](https://leetcode-cn.com/problems/jump-game-iv/solution/tiao-yue-you-xi-iv-by-leetcode-solution-zsix/)
    - 考虑这一问题的特殊性: 所有相同元素构成稠密图, 因此没有必要遍历改子图上所有的边 —— 递归一遍这些节点后, 没有必要在这一稠密图上搜索了
    - 因此, 直接不构建这一部分的图
    - 具体而言, 不构建显式的图, 直接记录每个数值包括的位置集合 val2index. 当从一个点 index 出发遍历了所有 val2index[arr[index]] 中的节点后, 直接 `del val2index[arr[index]]` 从而避免构建这一稠密图
- 1332. 删除回文子序列 `易`
  - 给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。求删除次数
  - 注意审题，只包含两个字母，并且删除的 **回文子序列**，因此最多是两次
- 2034. 股票价格波动 `中`
  - 股票数据可能会更新，以后到的为准，要求实现：1. 更新；2. 返回最近时间的价格；3. 找到最高/最低价格
  - 核心在于：之前记录的价格可能是错的，**如何在这种状态下维护最大值**
  - 方法一：哈希表 + **有序集合**
    - 用 map 存储每个时间对应的价格；有序列表存储所有的价格（要求最大最小直接返回列表的首尾元素即可） `from sortedcontainers import SortedList`
  - 方法二：哈希表 + 两个 **优先队列**
    - 用两个优先队列分别存储最大和最小值， (price,timestamp)；在返回时，将存储的 price 和 map 中对应时刻的价格比较，若不一致则说明过期了
- 2045. 到达目的地的第二短时间 `难`
  - 给定一张图，求从 1 到 n 的第二短路径；在这些节点上定义了红绿灯，每条边的开销是一样的，当到达节点时，次节点是红灯状态下无法离开，需要等待到下一次绿灯；所有节点的红绿灯变化是一样的，求第二短时间。
  - 方法一：广度优先搜索
    - see [here](https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/solution/dao-da-mu-de-di-de-di-er-duan-shi-jian-b-05i0/)
    - 第一步，计算次短路径。直接暴力 BFS 会超时，注意到 **仅需要记录一个节点的最短和次短路径**，因此可以剪枝
    - 第二步，计算时间。迭代的方式求解，当 `time_j % (change*2) >= change` (红灯状态) 时需要等待 `change*2 - time_j % (change*2)`
- 2013. 检测正方形 `中`
  - 实现一个类，实现 count：输入一个坐标，返回这个点和已有的点能够组成正方形（平行坐标轴的）的数量
  - 注意审题，因为是正方形所以遍历的复杂度不是很高，所以逻辑实现在 count 函数中即可
  - 用一个 `map{x:[ys]}` 记录每一行出现过的列（或者 [官答](https://leetcode-cn.com/problems/detect-squares/solution/jian-ce-zheng-fang-xing-by-leetcode-solu-vwzs/) 中直接 `map{[x][y]:count}` 记录每一个点出现的次数，数据结构 `defaultdict(Counter)`）遍历所有可能的正方形即可
- 2047. 句子中的有效单词数 `易`
  - 根据空格分隔单词，一个正确的词要求：1. 不包含数字；至多一个连字符，其前后必须是字母；2. 至多一个标点符号（'!'、'.' 和 ','），必须在结尾
  - 作为一道简单题还是挺烦的 [here](https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/solution/ju-zi-zhong-de-you-xiao-dan-ci-shu-by-le-hvow/) 用了一次遍历；自己实现的时候调用了 count 相对会慢一点？测下来差不多
- 1996. 游戏中弱角色的数量 `中` 大概是比较经典的双排序场景
  - 定义“弱角色”：包括攻击和防御两个属性，两个指标都严格小于另一个角色的角色，返回一组人物中弱角色的数量。参见 [here](https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/solution/you-xi-zhong-ruo-jiao-se-de-shu-liang-by-3d2g/)
  - 方法一：排序
    - 可以按照攻击从大到小排序；题目中要求两个属性严格小于才成立，如何保证当 maxY>y 时，所对应的 maxX 是严格大于当前的 x？一种方式当然可以对 x 分组记录之前分组的 maxX，另一种方法是设定第二排序指标为 防御值Y 从小到大排序，这样遍历的时候仅需记录 maxY 即可。
    - 也即 `properties.sort(key=lambda x: (-x[0], x[1]))`
  - 方法二：单调栈
    - 思路其实差不多，而且也要双指标排序；不过用了递增栈逻辑上清楚一点。
- 1765. 地图中的最高点 `中`
  - 给定一个矩阵表示水域和陆地. 约束为相邻的两个点高度差至多为1, 要求最高点.
  - 从所有的水域 (高度为 0) 出发, BFS即可. 注意这里的起始状态是一组点, 这样一层层拓展出去是不会违反约束的.
- 0884. 两句话中的不常见单词 `易`
  - 给定两句话, 输出「不常见」的词. 定义不常见: 如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。
  - 尝试过用 set 解决, 不太方便; 实际上该题词数最多 200, 暴力遍历更方便
- 1342. 将数字变成 0 的操作次数 `易`
- 1763. 最长的美好子字符串 `易`
  - 定义「美好字符串」: 当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中
  - 暴力遍历
- 2000. 反转单词前缀 `易`
- 1414. 和为 K 的最少斐波那契数字数目 `中`
  - 给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。
  - 贪心, 每次取最大可能的斐波那契数字即可
- 1725. 可以形成最大正方形的矩形数目 `易`
- 1763. 最长的美好子字符串 `easy`
- 2000. 反转单词前缀 `easy`
- 1725. 可以形成最大正方形的矩形数目 `easy`
- 1219. 黄金矿工 `medium`
  - DFS
- 1405. 最长快乐字符串 `medium`
  - 给定三个数字 a,b,c 分别是字符 abc 的数量, 构造最长字符串, 满足其中不包含三个连续的相同子字符串, 例如 aaa
  - 思路一: 分解+讨论
    - 先考虑两种字符的情况(假设按照数量多少记为 xy): 优先利用数量较多的字符 (每次取两个y, 一个x); 可知 1. 当 `len(x)<len(y)<=2len(x)+2` 时, 某一时刻 y 剩余数量会等于 x, 然后交错排列即可, 得到的字符串长度为 len(x)+len(y); 2. `len(y)>2len(x)+2` 时, y 不会用完, 得到的字符串长度为 len(x)+2len(x)+2
    - 然后考虑三种字符的情况(假设按照数量多少记为 xyz, 数量分别为 n1,n2,n3): 记上述构造方式为函数 construct
      - 当 `n1+n2<n3` 时, 把前两种字符当作一种即可, `construct(x*n1+y*n2, z*n3)`;
      - 当 `n1+n2>n3` 时, 注意此时必然可构造全长 (n1+n2+n3) 字符串, 先尽量基于前两种字符构造, 然后插入数量最多的那种字符.
        - `szy = construct(x*n1, y*n2)`
        - 注意到, 当 `n2 > 2*n1` 时, 利用前两种字符构造时次多字符会有剩余, 因此将剩余的次多字符放在前面 `construct(z*n3, y*(n2-countb)+sxy)`
  - 方法一：贪心
    - 上面典型想复杂了, 而且不可拓展. 此题直接贪心即可: 每次选择数量最多的字符.
- 1001. 网格照明 `hard`
  - 大小为 n x n 的网格 grid, lamps 给定了一组灯, lamps[i] = [rowi, coli] 可以照亮 行、列、两条对角线
  - 再给一组查询坐标 queries[j] = [rowj, colj], 每次查询返回该点是否被照亮, 并且查询后关闭该点为中心的 3*3 九个坐标上的灯
  - 思路: 用四个字典 defaultdict(set) 记录 行、列、两条对角线 上的亮灯情况
